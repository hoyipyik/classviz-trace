{"elements": {"nodes": [{"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A list to store all ghosts in the level."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "labels": ["Variable"], "properties": {"simpleName": "isAlive", "qualifiedName": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The new alive status of the player."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getSquare()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The square for this node.\r\n */\r\nprivate nl.tudelft.jpacman.board.Square getSquare() {\r\n    return this.square;\r\n}", "docComment": "\r\n@return The square for this node.\r\n", "metaSrc": "source code", "description": "Returns the square associated with the node.", "returns": "The square object stored in the node.", "reason": "This method provides access to the underlying square data of a navigation node, which is essential for determining the position and properties of the ghost within the game board.", "howToUse": "To use this method, simply call it on an instance of `Navigation$Node`.", "howItWorks": "The method returns the `square` field directly, which holds a reference to the square object associated with the node. This allows for easy access to the square's properties and methods.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getGhostFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the sprites from {@link #getSpriteStore()}.\r\n */\r\nprotected nl.tudelft.jpacman.npc.ghost.GhostFactory getGhostFactory() {\r\n    return new nl.tudelft.jpacman.npc.ghost.GhostFactory(this.getSpriteStore());\r\n}", "docComment": "\r\n@return A new factory using the sprites from {@link #getSpriteStore()}.\r\n", "metaSrc": "source code", "description": "Returns a GhostFactory instance initialized with the current SpriteStore.", "returns": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "reason": "The method provides a factory for creating ghost entities in the game, using the current sprite store to define their appearance and behavior.", "howToUse": "Call this method from within the Launcher class to obtain a GhostFactory instance.", "howItWorks": "The method creates a new GhostFactory object by passing the current SpriteStore to its constructor. This factory can then be used to create ghost entities in the game.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "boolean", "labels": ["Primitive"], "properties": {"simpleName": "boolean", "qualifiedName": "boolean", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Moves the specified player one square in the given direction.\r\n *\r\n * @param player\r\n * \t\tThe player to move.\r\n * @param direction\r\n * \t\tThe direction to move in.\r\n */\r\npublic void move(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Direction direction) {\r\n    if (this.isInProgress()) {\r\n        // execute player move.\r\n        this.getLevel().move(player, direction);\r\n        this.pointCalculator.pacmanMoved(player, direction);\r\n    }\r\n}", "docComment": "Moves the specified player one square in the given direction.\r\n\r\n@param player\r\n\t\tThe player to move.\r\n@param direction\r\n\t\tThe direction to move in.\r\n", "metaSrc": "source code", "description": "Moves a player in the game board and updates their points based on the direction they move.", "returns": "Void.", "reason": "This method is responsible for updating the game state when a player makes a move, including moving the player on the board and calculating points based on their movement.", "howToUse": "Call this method with a Player object and a Direction object to make a move in the game.", "howItWorks": "The method first checks if the game is in progress. If it is, it moves the player using the `move` method of the Level class and then updates the player's points using the `pacmanMoved` method of the PointCalculator class.", "assertions": {"preConditions": ["The game must be in progress."], "postConditions": ["The player should have moved on the board.", "The player's points should have been updated based on their movement."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.Action.doAction()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "doAction()", "qualifiedName": "nl.tudelft.jpacman.ui.Action.doAction()", "kind": "method", "sourceText": "/**\r\n * Executes the action.\r\n */\r\nvoid doAction();", "docComment": "Executes the action.\r\n", "metaSrc": "source code", "description": "Performs an action in the Pacman game.", "returns": "", "reason": "The method is part of the user interface layer, as it handles actions that interact with the game's UI components.", "howToUse": "Call this method to perform an action in the game, such as moving a character or changing the game state.", "howItWorks": "The method may involve updating the game state based on user input and rendering changes to the game display.", "assertions": {"preConditions": ["The game is running", "The player has initiated an action"], "postConditions": ["The game state is updated accordingly", "The UI is rendered with the new state"]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game instance to which the stop button will be added."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that the player collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "/**\r\n * Draws the sprite on the provided graphics context.\r\n *\r\n * @param graphics\r\n * \t\tThe graphics context to draw.\r\n * @param x\r\n * \t\tThe destination x coordinate to start drawing.\r\n * @param y\r\n * \t\tThe destination y coordinate to start drawing.\r\n * @param width\r\n * \t\tThe width of the destination draw area.\r\n * @param height\r\n * \t\tThe height of the destination draw area.\r\n */\r\nvoid draw(java.awt.Graphics graphics, int x, int y, int width, int height);", "docComment": "Draws the sprite on the provided graphics context.\r\n\r\n@param graphics\r\n\t\tThe graphics context to draw.\r\n@param x\r\n\t\tThe destination x coordinate to start drawing.\r\n@param y\r\n\t\tThe destination y coordinate to start drawing.\r\n@param width\r\n\t\tThe width of the destination draw area.\r\n@param height\r\n\t\tThe height of the destination draw area.\r\n", "metaSrc": "source code", "description": "Draws the sprite at the specified position on the given graphics context.", "returns": "void", "reason": "This method is part of the Sprite interface and is used to render the sprite on a graphical context at a specified position.", "howToUse": "To use this method, you need to have an instance of a class that implements the Sprite interface. You then call the draw method with the Graphics object, x and y coordinates, width, and height as parameters.", "howItWorks": "The method uses the provided Graphics object to draw the sprite at the specified position on the screen. It takes into account the width and height of the sprite to determine how much of it should be drawn.", "assertions": {"preConditions": ["A valid Graphics object is passed.", "The x, y, width, and height parameters are within the bounds of the screen or game area."], "postConditions": ["The sprite is drawn on the screen at the specified position."]}, "stereotype": "Accessor", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setAlive(boolean)", "qualifiedName": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "kind": "method", "sourceText": "/**\r\n * Sets whether this player is alive or not.\r\n *\r\n * If the player comes back alive, the {@link killer} will be reset.\r\n *\r\n * @param isAlive\r\n * \t\t<code>true</code> iff this player is alive.\r\n */\r\npublic void setAlive(boolean isAlive) {\r\n    if (isAlive) {\r\n        this.deathSprite.setAnimating(false);\r\n        this.killer = null;\r\n    }\r\n    if (!isAlive) {\r\n        this.deathSprite.restart();\r\n    }\r\n    this.alive = isAlive;\r\n}", "docComment": "Sets whether this player is alive or not.\r\n\r\nIf the player comes back alive, the {@link killer} will be reset.\r\n\r\n@param isAlive\r\n\t\t<code>true</code> iff this player is alive.\r\n", "metaSrc": "source code", "description": "Sets the player's alive status and updates their death sprite accordingly.", "returns": "", "reason": "Manages the player's state and visual representation based on their health.", "howToUse": "Call `setAlive(true)` to make the player alive, or `setAlive(false)` to make them dead.", "howItWorks": "Updates the death sprite's animation status and sets the player's alive flag.", "assertions": {"preConditions": ["The method is called with a boolean value."], "postConditions": ["The player's alive status is updated to the new value.", "The death sprite's animation is set based on the player's alive status."]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getGameFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getGameFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the players from {@link #getPlayerFactory()}.\r\n */\r\nprotected nl.tudelft.jpacman.game.GameFactory getGameFactory() {\r\n    return new nl.tudelft.jpacman.game.GameFactory(this.getPlayerFactory());\r\n}", "docComment": "\r\n@return A new factory using the players from {@link #getPlayerFactory()}.\r\n", "metaSrc": "source code", "description": "Returns a new instance of GameFactory using the current PlayerFactory.", "returns": "nl.tudelft.jpacman.game.GameFactory", "reason": "The method creates a new GameFactory that uses the current PlayerFactory, which is essential for initializing game entities and settings.", "howToUse": "Call this method to obtain a GameFactory instance that can be used to create a new Pacman game.", "howItWorks": "The method constructs a new GameFactory by passing the current PlayerFactory as an argument. This setup ensures that all game-related objects are created with the correct settings and configurations.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "format(nl.tudelft.jpacman.level.Player)", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "kind": "method", "sourceText": "/**\r\n * Format the score of a given player.\r\n *\r\n * @param player\r\n * \t\tThe player and its score\r\n * @return Formatted score.\r\n */\r\njava.lang.String format(nl.tudelft.jpacman.level.Player player);", "docComment": "Format the score of a given player.\r\n\r\n@param player\r\n\t\tThe player and its score\r\n@return Formatted score.\r\n", "metaSrc": "source code", "description": "Formats the score for a given player in the Pacman game.", "returns": "A string representation of the player's score.", "reason": "This method is part of the user interface layer as it formats and displays the score for a player in the Pacman game.", "howToUse": "Call this method with an instance of Player to get a formatted string representing their score.", "howItWorks": "The method retrieves the score from the player object, converts it to a string, and returns it. This is typically done using a simple formatting function or template.", "assertions": {"preConditions": ["A valid instance of Player is provided"], "postConditions": ["A non-null string representing the player's score is returned"]}, "stereotype": "Accessor", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquareIndex", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The start current selected starting square.\r\n */\r\nprivate int startSquareIndex;", "visibility": "private", "simpleName": "startSquareIndex", "qualifiedName": "nl.tudelft.jpacman.level.Level.startSquareIndex", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getInheritance(java.lang.Class)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "kind": "method", "sourceText": "/**\r\n * Returns a list of all classes and interfaces the class inherits.\r\n *\r\n * @param clazz\r\n * \t\tThe class to create a list of super classes and interfaces\r\n * \t\tfor.\r\n * @return A list of all classes and interfaces the class inherits.\r\n */\r\n@java.lang.SuppressWarnings(\"unchecked\")\r\nprivate java.util.List<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>> getInheritance(java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> clazz) {\r\n    java.util.List<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>> found = new java.util.ArrayList<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>>();\r\n    found.add(clazz);\r\n    int index = 0;\r\n    while (found.size() > index) {\r\n        java.lang.Class<? extends java.lang.Object> current = found.get(index);\r\n        java.lang.Class<? extends java.lang.Object> superClass = current.getSuperclass();\r\n        if ((superClass != null) && nl.tudelft.jpacman.board.Unit.class.isAssignableFrom(superClass)) {\r\n            found.add(((java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>) (superClass)));\r\n        }\r\n        for (java.lang.Class<? extends java.lang.Object> classInterface : current.getInterfaces()) {\r\n            if (nl.tudelft.jpacman.board.Unit.class.isAssignableFrom(classInterface)) {\r\n                found.add(((java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>) (classInterface)));\r\n            }\r\n        }\r\n        index++;\r\n    } \r\n    return found;\r\n}", "docComment": "Returns a list of all classes and interfaces the class inherits.\r\n\r\n@param clazz\r\n\t\tThe class to create a list of super classes and interfaces\r\n\t\tfor.\r\n@return A list of all classes and interfaces the class inherits.\r\n", "metaSrc": "source code", "description": "Returns a list of all classes that are subclasses or implement interfaces of the given class.", "returns": "A List of Class objects representing the inheritance hierarchy of the input class.", "reason": "The method is designed to explore and return the entire inheritance chain of a given class, including its superclasses and implemented interfaces.", "howToUse": "Call this method with a Class object as an argument to get all related classes in the hierarchy.", "howItWorks": "The method iterates over the input class's superclass and interfaces, adding them to a list if they are subclasses or implement the Unit interface. This process continues until no more relevant classes are found.", "assertions": {"preConditions": ["Input is a valid Class object that extends nl.tudelft.jpacman.board.Unit."], "postConditions": ["The returned List contains all classes in the inheritance hierarchy of the input class, including its superclasses and implemented interfaces."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite map, one sprite for each direction.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "kind": "method", "sourceText": "/**\r\n * Returns the height of this sprite.\r\n *\r\n * @return The height of this sprite in pixels.\r\n */\r\nint getHeight();", "docComment": "Returns the height of this sprite.\r\n\r\n@return The height of this sprite in pixels.\r\n", "metaSrc": "source code", "description": "Returns the height of the sprite.", "returns": "The height of the sprite as an integer.", "reason": "Provides access to the visual dimensions of a sprite, which is essential for rendering and collision detection in games.", "howToUse": "Call `getHeight()` on any instance of `Sprite` to retrieve its height.", "howItWorks": "The method returns the value stored in an internal field that holds the height of the sprite. This value is typically set during the initialization or creation of the sprite object.", "assertions": {"preConditions": [], "postConditions": ["The returned value is a non-negative integer representing the height of the sprite."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "labels": ["Variable"], "properties": {"simpleName": "visited", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A set of visited squares to avoid revisiting them."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "Y-coordinate to check"}}}, {"data": {"id": "char", "labels": ["Primitive"], "properties": {"simpleName": "char", "qualifiedName": "char", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.NORTH", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * North, or up.\r\n */\r\nNORTH(0, -1)", "visibility": "public", "simpleName": "NORTH", "qualifiedName": "nl.tudelft.jpacman.board.Direction.NORTH", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The destination y coordinate to start drawing."}}}, {"data": {"id": "long", "labels": ["Primitive"], "properties": {"simpleName": "long", "qualifiedName": "long", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor", "labels": ["Structure"], "properties": {"docComment": "A list of supported ghost colors.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "GhostColor", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor", "kind": "enum", "metaSrc": "source code", "description": "The enum `GhostColor` in the Pacman implementation is responsible for representing different colors associated with ghosts in the game. It provides a way to identify and manage various ghost types based on their color.", "keywords": ["enum", "Pacman", "ghosts", "colors"], "roleStereotype": "Information Holder"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSquareAt(nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Returns the square adjacent to this square.\r\n *\r\n * @param direction\r\n * \t\tThe direction of the adjacent square.\r\n * @return The adjacent square in the given direction.\r\n */\r\npublic nl.tudelft.jpacman.board.Square getSquareAt(nl.tudelft.jpacman.board.Direction direction) {\r\n    return this.neighbours.get(direction);\r\n}", "docComment": "Returns the square adjacent to this square.\r\n\r\n@param direction\r\n\t\tThe direction of the adjacent square.\r\n@return The adjacent square in the given direction.\r\n", "metaSrc": "source code", "description": "Returns the square in the specified direction from the current square.", "returns": "The Square object at the given direction from the current square.", "reason": "This method provides a way to navigate through the game board by specifying a direction and retrieving the corresponding square.", "howToUse": "Call this method with a Direction object to get the adjacent square in that direction.", "howItWorks": "The method uses the 'neighbours' map, which is assumed to be initialized with squares in all possible directions, to retrieve the square at the specified direction.", "assertions": {"preConditions": ["The current square has a valid 'neighbours' map initialized with squares in all possible directions."], "postConditions": ["The method returns the correct Square object if the direction is valid and within bounds."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "labels": ["Variable"], "properties": {"sourceText": "private static final int PINKY = 2;", "visibility": "private", "simpleName": "PINKY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate of the top-left corner of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new animating sprite that will change frames every interval. By\r\n * default the sprite is not animating.\r\n *\r\n * @param frames\r\n * \t\tThe frames of this animation.\r\n * @param delay\r\n * \t\tThe delay between frames.\r\n * @param loop\r\n * \t\tWhether or not this sprite should be looping.\r\n */\r\npublic AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[] frames, int delay, boolean loop) {\r\n    this(frames, delay, loop, false);\r\n}", "docComment": "Creates a new animating sprite that will change frames every interval. By\r\ndefault the sprite is not animating.\r\n\r\n@param frames\r\n\t\tThe frames of this animation.\r\n@param delay\r\n\t\tThe delay between frames.\r\n@param loop\r\n\t\tWhether or not this sprite should be looping.\r\n", "metaSrc": "source code", "description": "Initializes an animated sprite with given frames, delay, looping, and animation status.", "returns": "The newly created AnimatedSprite instance.", "reason": "This method provides a convenient way to create an animated sprite with default animation status set to false, which is useful for initializing sprites without specifying the initial animation state.", "howToUse": "To use this method, you need to provide an array of frames and specify the delay between frames. Optionally, you can also specify whether or not the sprite should loop.", "howItWorks": "The method calls another constructor with the same parameters but sets the last parameter (isAnimating) to false by default.", "assertions": {"preConditions": ["frames is a non-null array of Sprite objects", "delay is a positive integer"], "postConditions": ["A new AnimatedSprite instance is created with the specified frames, delay, and looping status."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The height of the destination draw area."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "directions", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of directions specifying the path to follow."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPacmanSprites()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A map of animated Pac-Man sprites for all directions.\r\n */\r\npublic java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> getPacmanSprites() {\r\n    return this.directionSprite(\"/sprite/pacman.png\", nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES);\r\n}", "docComment": "\r\n@return A map of animated Pac-Man sprites for all directions.\r\n", "metaSrc": "source code", "description": "Returns a map from directions to animated sprites for Pacman based on a base image.", "returns": "A map from directions to animated sprites.", "reason": "This method provides a convenient way to create and manage animated Pacman sprites for different directions, which is essential for the game logic.", "howToUse": "Call this method with the resource name of the sprite and the number of frames to get a map of animated sprites for each direction.", "howItWorks": "The method uses the `directionSprite` helper method to create animated sprites for each direction based on the provided base image and frame count. It returns a map from directions to these animated sprites.", "preConditions": ["A valid resource name is provided."], "postConditions": ["A map of animated sprites for each direction is returned."], "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction in which the unit should move."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getSprites()", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "kind": "method", "sourceText": "/**\r\n * The sprites created by the factory.\r\n *\r\n * @return The sprites for the player created.\r\n */\r\nprotected nl.tudelft.jpacman.sprite.PacManSprites getSprites() {\r\n    return this.sprites;\r\n}", "docComment": "The sprites created by the factory.\r\n\r\n@return The sprites for the player created.\r\n", "metaSrc": "source code", "description": "Returns the PacMan sprites used in the game.", "returns": "The PacManSprites instance containing all the necessary sprites for the game.", "reason": "This method provides a convenient way to access the sprites required for rendering PacMan and other entities in the game.", "howToUse": "To use this method, simply call it on an instance of PlayerFactory. It will return the current set of sprites used by the factory.", "howItWorks": "The method directly returns the `sprites` field of the class, which is assumed to be initialized with all necessary PacMan-related sprites.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addStartButton(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "/**\r\n * Adds a button with the caption {@value #START_CAPTION} that starts the\r\n * game.\r\n *\r\n * @param game\r\n * \t\tThe game to start.\r\n */\r\nprivate void addStartButton(final nl.tudelft.jpacman.game.Game game) {\r\n    assert game != null;\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION, game::start);\r\n}", "docComment": "Adds a button with the caption {@value #START_CAPTION} that starts the\r\ngame.\r\n\r\n@param game\r\n\t\tThe game to start.\r\n", "metaSrc": "source code", "description": "Adds a start button to the game interface that, when clicked, starts the game.", "returns": "", "reason": "This method provides a way to add a user interface element that allows users to initiate the game.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.game.Game to add a start button to the game's UI.", "howItWorks": "The method uses the buttons.put() method to associate the START_CAPTION string with a lambda expression that calls the start() method on the provided game instance.", "assertions": {"preConditions": ["game is not null"], "postConditions": []}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createPinky()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "kind": "method", "sourceText": "/**\r\n * Creates a new Pinky / Speedy, the pink Ghost.\r\n *\r\n * @see Pinky\r\n * @return A new Pinky.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createPinky() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Pinky(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.PINK));\r\n}", "docComment": "Creates a new Pinky / Speedy, the pink Ghost.\r\n\r\n@see Pinky\r\n@return A new Pinky.\r\n", "metaSrc": "source code", "description": "Creates an instance of Pinky ghost using its sprite based on the specified color.", "returns": "An instance of the Pinky ghost class.", "reason": "The method creates a specific type of ghost based on its color and sprite configuration.", "howToUse": "Call this method with the appropriate GhostColor to get an instance of Pinky.", "howItWorks": "The method retrieves the animated sprite for Pinky from the sprites map using the specified color, then constructs a new Pinky object with that sprite.", "assertions": {"preConditions": ["this.sprites is not null", "GhostColor.PINK exists in this.sprites"], "postConditions": ["A new instance of Pinky is created and returned."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore", "labels": ["Structure"], "properties": {"docComment": "Utility to load {@link Sprite}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "SpriteStore", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore", "kind": "class", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The SpriteStore class is responsible for managing and retrieving sprites used in a Pacman game. It initializes a HashMap to store sprite mappings, provides methods to create animated sprites and load sprites from resource files.", "keywords": ["Sprite management", "Pacman game", "sprite mapping", "animated sprite", "resource loading"], "roleStereotype": "Structurer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "invariant(nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "kind": "method", "sourceText": "/**\r\n * Verifies that all occupants on this square have indeed listed this square\r\n * as the square they are currently occupying.\r\n *\r\n * @return <code>true</code> iff all occupants of this square have this\r\nsquare listed as the square they are currently occupying.\r\n */\r\nprotected final boolean invariant(nl.tudelft.jpacman.board.Square this) {\r\n    for (nl.tudelft.jpacman.board.Unit occupant : this.occupants) {\r\n        if (occupant.hasSquare() && (occupant.getSquare() != this)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}", "docComment": "Verifies that all occupants on this square have indeed listed this square\r\nas the square they are currently occupying.\r\n\r\n@return <code>true</code> iff all occupants of this square have this\r\nsquare listed as the square they are currently occupying.\r\n", "metaSrc": "source code", "description": "Checks if all units on the square are correctly associated with their squares.", "returns": "Boolean indicating whether the invariant is satisfied.", "reason": "Ensures that each unit is only occupying one square and that no two units occupy the same square.", "howToUse": "Call this method to verify the integrity of the board state.", "howItWorks": "Iterates over all occupants on the square, checking if they have a square associated with them and if it matches the current square. Returns false if any unit is not correctly associated.", "assertions": {"preConditions": ["The method should be called on an instance of Square."], "postConditions": ["The method returns true if all units are correctly associated, otherwise false."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Whether is animation should be looping or not.\r\n */\r\nprivate final boolean looping;", "visibility": "private", "simpleName": "looping", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet", "labels": ["Structure"], "properties": {"docComment": "A pellet, one of the little dots Pac-Man has to collect.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Pellet", "qualifiedName": "nl.tudelft.jpacman.level.Pellet", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The Pellet class is responsible for representing pellets in the Pacman game, which are collectible items that provide points to the player. It manages the visual representation and point value of these pellets.", "keywords": ["Pellet", "Pacman", "Collectible Item", "Points", "Sprite"], "roleStereotype": "Information Holder"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The animations for every direction.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.level.Player.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Pinky\", a.k.a. \"Speedy\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\npublic Pinky(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Pinky\", a.k.a. \"Speedy\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes a new Pinky ghost with specified sprite map, move interval, and interval variation.", "returns": "A newly created Pinky ghost instance.", "reason": "Pinky is a Ghost subclass that requires initialization with specific sprite map and movement parameters.", "howToUse": "Create a new Pinky ghost by providing the necessary sprite map and movement settings.", "howItWorks": "The method calls the superclass constructor with the provided sprite map, move interval, and interval variation to initialize the Pinky ghost.", "assertions": {"preConditions": ["spriteMap is not null", "moveInterval is a positive integer", "intervalVariation is a non-negative integer"], "postConditions": ["A new Pinky ghost instance is created with the specified properties."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createGround()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "kind": "method", "sourceText": "/**\r\n * Creates a new square that can be occupied by any unit.\r\n *\r\n * @return A new square that can be occupied by any unit.\r\n */\r\npublic nl.tudelft.jpacman.board.Square createGround() {\r\n    return new nl.tudelft.jpacman.board.BoardFactory.Ground(this.sprites.getGroundSprite());\r\n}", "docComment": "Creates a new square that can be occupied by any unit.\r\n\r\n@return A new square that can be occupied by any unit.\r\n", "metaSrc": "source code", "description": "Creates a new Ground square using the ground sprite loaded from a resource file.", "returns": "A new Square representing the ground.", "reason": "The method provides a way to create a basic game board component, which is essential for the Pacman game logic.", "howToUse": "Call this method on an instance of BoardFactory to obtain a Ground square.", "howItWorks": "The method retrieves the ground sprite from the resource file using getGroundSprite() and creates a new Square object with this sprite.", "assertions": {"preConditions": [], "postConditions": ["A new Square is created with the specified ground sprite."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelLost()", "qualifiedName": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "kind": "method", "sourceText": "/**\r\n * The level has been lost. Typically the level should be stopped when\r\n * this event is received.\r\n */\r\nvoid levelLost();", "docComment": "The level has been lost. Typically the level should be stopped when\r\nthis event is received.\r\n", "metaSrc": "source code", "description": "Notifies observers that the level has been lost.", "returns": "", "reason": "To inform observers about the loss of the game level, which is a significant event in the Pacman game.", "howToUse": "Implement this method to handle the logic when the player loses the current level. This could involve resetting the game state or displaying a game over screen.", "howItWorks": "The method does not take any parameters and returns nothing. It simply notifies all registered observers that the level has been lost, which can be handled by each observer according to its specific implementation.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The width of the square to render."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Create a new single player game for the provided level and player.\r\n *\r\n * @param player\r\n * \t\tThe player.\r\n * @param level\r\n * \t\tThe level.\r\n * @param pointCalculator\r\n * \t\tThe way to calculate points upon collisions.\r\n */\r\nprotected SinglePlayerGame(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Level level, nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super(pointCalculator);\r\n    assert player != null;\r\n    assert level != null;\r\n    this.player = player;\r\n    this.level = level;\r\n    this.level.registerPlayer(player);\r\n}", "docComment": "Create a new single player game for the provided level and player.\r\n\r\n@param player\r\n\t\tThe player.\r\n@param level\r\n\t\tThe level.\r\n@param pointCalculator\r\n\t\tThe way to calculate points upon collisions.\r\n", "metaSrc": "source code", "description": "Initializes a single-player game instance with a player, level, and point calculator.", "returns": "A new instance of SinglePlayerGame.", "reason": "This method initializes a single-player game by setting up the player, level, and point calculator, ensuring that the game is properly configured for play.", "howToUse": "Create an instance of SinglePlayerGame by providing a Player, Level, and PointCalculator. This setup will allow you to start playing the game.", "howItWorks": "The method initializes the superclass with the provided PointCalculator, checks for null inputs, assigns the player and level to instance variables, and registers the player on the level.", "assertions": {"preConditions": ["player is not null", "level is not null"], "postConditions": ["SinglePlayerGame instance is created with the provided parameters", "player is registered on the level"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "labels": ["Variable"], "properties": {"simpleName": "delay", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The delay between frames."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getMostSpecificClass(java.util.Map,java.lang.Class)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "kind": "method", "sourceText": "/**\r\n * Figures out the most specific class that is listed in the map. I.e. if A\r\n * extends B and B is listed while requesting A, then B will be returned.\r\n *\r\n * @param map\r\n * \t\tThe map with the key collection to find a matching class in.\r\n * @param key\r\n * \t\tThe class to search the most suitable key for.\r\n * @return The most specific class from the key collection.\r\n */\r\nprivate java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> getMostSpecificClass(java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, ? extends java.lang.Object> map, java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> key) {\r\n    java.util.List<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>> collideeInheritance = this.getInheritance(key);\r\n    for (java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> pointer : collideeInheritance) {\r\n        if (map.containsKey(pointer)) {\r\n            return pointer;\r\n        }\r\n    }\r\n    return null;\r\n}", "docComment": "Figures out the most specific class that is listed in the map. I.e. if A\r\nextends B and B is listed while requesting A, then B will be returned.\r\n\r\n@param map\r\n\t\tThe map with the key collection to find a matching class in.\r\n@param key\r\n\t\tThe class to search the most suitable key for.\r\n@return The most specific class from the key collection.\r\n", "metaSrc": "source code", "description": "Returns the most specific class in the map that is an ancestor of the given key class.", "returns": "The most specific class in the map that is an ancestor of the given key class, or null if no such class exists.", "reason": "This method helps determine the most specific class that can handle a collision with a given unit based on its inheritance hierarchy.", "howToUse": "Call this method with a map and a key class to find the most specific class in the map that is an ancestor of the key class.", "howItWorks": "The method retrieves the inheritance hierarchy of the key class using the `getInheritance` method. It then iterates through the list of classes in the hierarchy, checking if each class exists as a key in the map. The first class found in the map is returned as the most specific class.", "assertions": {"preConditions": ["The map must contain at least one entry with a class as the key."], "postConditions": ["If a matching class is found, it will be returned. If no matching class is found, null will be returned."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createPellet()", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "kind": "method", "sourceText": "/**\r\n * Creates a new pellet.\r\n *\r\n * @return The new pellet.\r\n */\r\npublic nl.tudelft.jpacman.level.Pellet createPellet() {\r\n    return new nl.tudelft.jpacman.level.Pellet(nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE, this.sprites.getPelletSprite());\r\n}", "docComment": "Creates a new pellet.\r\n\r\n@return The new pellet.\r\n", "metaSrc": "source code", "description": "Creates a new Pellet instance with a specific value and sprite.", "returns": "A new nl.tudelft.jpacman.level.Pellet object.", "reason": "This method is responsible for creating Pellets in the game, which are essential entities that players can collect to score points.", "howToUse": "To use this method, instantiate a LevelFactory and call createPellet() on it. This will return a new Pellet with a specific value and sprite.", "howItWorks": "The method creates a new Pellet object by passing the pellet's value (PECLET_VALUE) and its sprite to the Pellet constructor. The sprite is loaded using the getPelletSprite() method of LevelFactory, which caches it if necessary.", "assertions": {"preConditions": ["A valid instance of LevelFactory exists."], "postConditions": ["A new Pellet object with the specified value and sprite is created."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The y-coordinate of the top-left corner where the sprite should be drawn."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withinBorders(int,int)", "qualifiedName": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "kind": "method", "sourceText": "/**\r\n * Determines whether the given <code>x,y</code> position is on this board.\r\n *\r\n * @param x\r\n * \t\tThe <code>x</code> position (row) to test.\r\n * @param y\r\n * \t\tThe <code>y</code> position (column) to test.\r\n * @return <code>true</code> iff the position is on this board.\r\n */\r\npublic boolean withinBorders(int x, int y) {\r\n    return (((x >= 0) && (x < this.getWidth())) && (y >= 0)) && (y < this.getHeight());\r\n}", "docComment": "Determines whether the given <code>x,y</code> position is on this board.\r\n\r\n@param x\r\n\t\tThe <code>x</code> position (row) to test.\r\n@param y\r\n\t\tThe <code>y</code> position (column) to test.\r\n@return <code>true</code> iff the position is on this board.\r\n", "metaSrc": "source code", "description": "Checks if given coordinates are within the bounds of the board.", "returns": "True if the coordinates are within the board's boundaries, False otherwise.", "reason": "Ensures that game entities do not move outside the playable area of the board.", "howToUse": "Call `withinBorders(x, y)` with the desired x and y coordinates to check their validity.", "howItWorks": "The method checks if both x and y are within the range [0, width) and [0, height), respectively.", "assertions": {"preConditions": ["x >= 0", "y >= 0"], "postConditions": ["return value is a boolean"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * When the ghosts are not patrolling in their home corners (Blinky:\r\n * top-right, Pinky: top-left, Inky: bottom-right, Clyde: bottom-left),\r\n * Blinky will attempt to shorten the distance between Pac-Man and himself.\r\n * If he has to choose between shortening the horizontal or vertical\r\n * distance, he will choose to shorten whichever is greatest. For example,\r\n * if Pac-Man is four grid spaces to the left, and seven grid spaces above\r\n * Blinky, he'll try to move up towards Pac-Man before he moves to the left.\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    // TODO Blinky should patrol his corner every once in a while\r\n    // TODO Implement his actual behaviour instead of simply chasing.\r\n    nl.tudelft.jpacman.board.Unit nearest = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if (nearest == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert nearest.hasSquare();\r\n    nl.tudelft.jpacman.board.Square target = nearest.getSquare();\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), target, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        return java.util.Optional.ofNullable(path.get(0));\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nWhen the ghosts are not patrolling in their home corners (Blinky:\r\ntop-right, Pinky: top-left, Inky: bottom-right, Clyde: bottom-left),\r\nBlinky will attempt to shorten the distance between Pac-Man and himself.\r\nIf he has to choose between shortening the horizontal or vertical\r\ndistance, he will choose to shorten whichever is greatest. For example,\r\nif Pac-Man is four grid spaces to the left, and seven grid spaces above\r\nBlinky, he'll try to move up towards Pac-Man before he moves to the left.\r\n</p>\r\n", "metaSrc": "source code", "description": "Determines the next move for Blinky, the ghost in Pacman, based on finding the nearest player and calculating the shortest path to them.", "returns": "Optional<Direction>", "reason": "The method implements the AI logic for Blinky's movement in Pacman, ensuring it moves towards the nearest player while avoiding obstacles.", "howToUse": "Call nextAiMove() on an instance of Blinky to get the next direction it should move.", "howItWorks": "1. Check if Blinky has a square. 2. Find the nearest player using Navigation.findNearest(). 3. Calculate the shortest path from Blinky's current position to the player's position using Navigation.shortestPath(). 4. Return the first direction in the path or an empty Optional if no path is found.", "assertions": {"preConditions": ["Blinky has a square", "Player exists on the board"], "postConditions": ["Returns an Optional containing the next move or an empty Optional if no valid path can be found"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "method", "sourceText": "/**\r\n * Adds a two-way collision interaction to this collection, i.e. the\r\n * collision handler will be used for both C1 versus C2 and C2 versus C1.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe collider type.\r\n * @param collidee\r\n * \t\tThe collidee type.\r\n * @param handler\r\n * \t\tThe handler that handles the collision.\r\n */\r\npublic <C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void onCollision(java.lang.Class<C1> collider, java.lang.Class<C2> collidee, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2> handler) {\r\n    this.onCollision(collider, collidee, true, handler);\r\n}", "docComment": "Adds a two-way collision interaction to this collection, i.e. the\r\ncollision handler will be used for both C1 versus C2 and C2 versus C1.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe collider type.\r\n@param collidee\r\n\t\tThe collidee type.\r\n@param handler\r\n\t\tThe handler that handles the collision.\r\n", "metaSrc": "source code", "description": "Adds collision handlers for a specific pair of units and their inverse if symetric.", "returns": "Void.", "reason": "This method provides a convenient way to add collision handlers for specific pairs of units and their inverse if symetric, which is useful in game development where different types of units may interact with each other in various ways.", "howToUse": "To use this method, you need to provide the collider type, collidee type, and a handler that handles the collision. The handler should implement the CollisionHandler interface.", "howItWorks": "The method calls another method onCollision(collider, collidee, true, handler) with the third parameter set to true, which adds the collision handler for both C1 against C2 and vice versa.", "assertions": {"preConditions": ["collider and collidee are valid classes that extend nl.tudelft.jpacman.board.Unit", "handler is a valid instance of nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2>"], "postConditions": ["A collision handler for the specified pair of units and their inverse if symetric is added to this collection."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board", "labels": ["Structure"], "properties": {"docComment": "A top-down view of a matrix of {@link Square}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Board", "qualifiedName": "nl.tudelft.jpacman.board.Board", "kind": "class", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The Board class is responsible for managing the game board, including its dimensions, squares, and boundaries. It provides methods to initialize the board, retrieve square information, check bounds, and ensure the integrity of the board's state.", "keywords": ["board", "game", "squares", "dimensions", "bounds", "integrity"], "roleStereotype": "Structurer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher", "labels": ["Structure"], "properties": {"docComment": "Creates and launches the JPacMan UI.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Launcher", "qualifiedName": "nl.tudelft.jpacman.Launcher", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The class is responsible for managing game logic, including parsing level maps, creating and moving players, handling user input, and providing actions to move players towards specified directions.", "keywords": ["game", "logic", "level", "player", "movement", "input"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.game", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.game.Game game;", "visibility": "private", "simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.Launcher.game", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "occupant", "qualifiedName": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit to be added to the square."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Create a new key listener based on a set of keyCode-action pairs.\r\n *\r\n * @param keyMappings\r\n * \t\tThe mappings of keyCode to action.\r\n */\r\nPacKeyListener(java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> keyMappings) {\r\n    super();\r\n    assert keyMappings != null;\r\n    this.mappings = keyMappings;\r\n}", "docComment": "Create a new key listener based on a set of keyCode-action pairs.\r\n\r\n@param keyMappings\r\n\t\tThe mappings of keyCode to action.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getParent()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The parent node, or <code>null</code> if this node is a root\r\nnode.\r\n */\r\nprivate nl.tudelft.jpacman.npc.ghost.Navigation.Node getParent() {\r\n    return this.parent;\r\n}", "docComment": "\r\n@return The parent node, or <code>null</code> if this node is a root\r\nnode.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height) {\r\n    if (this.withinImage(x, y) && this.withinImage((x + width) - 1, (y + height) - 1)) {\r\n        java.awt.image.BufferedImage newImage = this.newImage(width, height);\r\n        newImage.createGraphics().drawImage(this.image, 0, 0, width, height, x, y, x + width, y + height, null);\r\n        return new nl.tudelft.jpacman.sprite.ImageSprite(newImage);\r\n    }\r\n    return new nl.tudelft.jpacman.sprite.EmptySprite();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Splits an ImageSprite into a new ImageSprite containing a sub-image defined by the given coordinates and dimensions.", "returns": "A new ImageSprite containing the specified sub-image.", "reason": "This method provides a way to extract a portion of an existing image, which is useful for creating smaller images or manipulating parts of an image in the game.", "howToUse": "Call this method on an instance of ImageSprite with the desired coordinates and dimensions. The returned object will be a new ImageSprite containing only the specified sub-image.", "howItWorks": "The method first checks if the given coordinates are within the bounds of the original image using the `withinImage` method. If they are, it creates a new BufferedImage with the specified width and height. It then uses the `createGraphics` method to draw the original image onto the new BufferedImage at the specified coordinates. Finally, it returns a new ImageSprite containing the newly created sub-image.", "assertions": {"preConditions": ["The given x-coordinate is within the bounds of the original image.", "The given y-coordinate is within the bounds of the original image.", "The sum of the given x-coordinate and width does not exceed the width of the original image.", "The sum of the given y-coordinate and height does not exceed the height of the original image."], "postConditions": ["A new ImageSprite containing the specified sub-image is returned.", "The returned ImageSprite has the same transparency as the original ImageSprite."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "labels": ["Variable"], "properties": {"simpleName": "clazz", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The type to search for."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "labels": ["Variable"], "properties": {"simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The level on which the game will take place."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The collision handler to be added for the specified pair of units."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The destination x coordinate to start drawing."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The graphics context used for rendering the board."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The class representing the unit that is collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.background;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "kind": "method", "sourceText": "/**\r\n * Creates a game for a single level with one player.\r\n *\r\n * @param level\r\n * \t\tThe level to create a game for.\r\n * @param pointCalculator\r\n * \t\tThe way to calculate points upon collisions.\r\n * @return A new single player game.\r\n */\r\npublic nl.tudelft.jpacman.game.Game createSinglePlayerGame(nl.tudelft.jpacman.level.Level level, nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    return new nl.tudelft.jpacman.game.SinglePlayerGame(this.playerFactory.createPacMan(), level, pointCalculator);\r\n}", "docComment": "Creates a game for a single level with one player.\r\n\r\n@param level\r\n\t\tThe level to create a game for.\r\n@param pointCalculator\r\n\t\tThe way to calculate points upon collisions.\r\n@return A new single player game.\r\n", "metaSrc": "source code", "description": "Creates a new single-player game instance using the specified level and point calculator.", "returns": "A new SinglePlayerGame instance.", "reason": "This method is part of the game factory, which is responsible for creating instances of different types of games based on the provided parameters.", "howToUse": "To use this method, you need to provide a Level object and a PointCalculator object. The method will return a new SinglePlayerGame instance that can be used to play the game.", "howItWorks": "The method creates a new SinglePlayerGame instance by calling the createPacMan() method of the player factory to get a PacMan player, then passing this player along with the provided level and point calculator to the SinglePlayerGame constructor.", "assertions": {"preConditions": ["A Level object must be provided."], "postConditions": ["A new SinglePlayerGame instance is returned."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "labels": ["Variable"], "properties": {"simpleName": "node", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The current node in the navigation path."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * We only need to load images once, so we keep track\r\n * of them in a hash map.\r\n */\r\nprivate final java.util.Map<java.lang.String, nl.tudelft.jpacman.sprite.Sprite> spriteMap;", "visibility": "private", "simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The {@link System#currentTimeMillis()} stamp of the last update.\r\n */\r\nprivate long lastUpdate;", "visibility": "private", "simpleName": "lastUpdate", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "labels": ["Variable"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The background sprite for the wall."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate of the top-left corner of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAnyPlayerAlive()", "qualifiedName": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "kind": "method", "sourceText": "/**\r\n * Returns <code>true</code> iff at least one of the players in this level\r\n * is alive.\r\n *\r\n * @return <code>true</code> if at least one of the registered players is\r\nalive.\r\n */\r\npublic boolean isAnyPlayerAlive() {\r\n    for (nl.tudelft.jpacman.level.Player player : this.players) {\r\n        if (player.isAlive()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}", "docComment": "Returns <code>true</code> iff at least one of the players in this level\r\nis alive.\r\n\r\n@return <code>true</code> if at least one of the registered players is\r\nalive.\r\n", "metaSrc": "source code", "description": "Checks if any player in the level is alive.", "returns": "Boolean indicating whether any player is alive.", "reason": "The method iterates through all players and checks their health status to determine if at least one player is still active.", "howToUse": "Call `isAnyPlayerAlive()` on an instance of `Level` to check for living players.", "howItWorks": "The method uses a simple loop to iterate over each player in the level's list and checks if they are alive using the `isAlive()` method. If any player is found to be alive, it returns true; otherwise, it returns false after checking all players.", "assertions": {"preConditions": ["The method assumes that the `players` list is not null or empty."], "postConditions": ["The method returns a boolean value indicating whether any player is alive."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The class representing the unit that initiates the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "start()", "qualifiedName": "nl.tudelft.jpacman.level.Level.start()", "kind": "method", "sourceText": "/**\r\n * Starts or resumes this level, allowing movement and (re)starting the\r\n * NPCs.\r\n */\r\npublic void start() {\r\n    synchronized(this.startStopLock) {\r\n        if (this.isInProgress()) {\r\n            return;\r\n        }\r\n        this.startNPCs();\r\n        this.inProgress = true;\r\n        this.updateObservers();\r\n    }\r\n}", "docComment": "Starts or resumes this level, allowing movement and (re)starting the\r\nNPCs.\r\n", "metaSrc": "source code", "description": "Starts the game by initializing NPCs, setting progress to true, and updating observers.", "returns": "", "reason": "The method manages the start of a Pacman game level by coordinating NPC movement, setting the game state, and notifying observers about the level's status.", "howToUse": "Call `start()` on an instance of `Level` to begin the game.", "howItWorks": "Synchronizes access to the `startStopLock`, checks if the level is already in progress, starts NPC movement, sets the progress flag to true, and updates observers based on the level's state.", "assertions": {"preConditions": ["The method should not be called if the level is already in progress.", "All necessary resources for NPC movement should be initialized before calling `start()`."], "postConditions": ["The game level should be set to an active state with NPCs moving.", "Observers should be notified of the start of the game."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file containing the sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "labels": ["Variable"], "properties": {"sourceText": "private final nl.tudelft.jpacman.level.CollisionMap collisions = this.defaultCollisions();", "visibility": "private", "simpleName": "collisions", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "labels": ["Variable"], "properties": {"simpleName": "delay", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The delay between each frame in milliseconds."}}}, {"data": {"id": "int", "labels": ["Primitive"], "properties": {"simpleName": "int", "qualifiedName": "int", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "kind": "method", "sourceText": "private nl.tudelft.jpacman.board.Square followPath(java.util.List<nl.tudelft.jpacman.board.Direction> directions, nl.tudelft.jpacman.board.Square start) {\r\n    nl.tudelft.jpacman.board.Square destination = start;\r\n    for (nl.tudelft.jpacman.board.Direction d : directions) {\r\n        destination = destination.getSquareAt(d);\r\n    }\r\n    return destination;\r\n}", "docComment": "", "metaSrc": "source code", "description": "Follows a sequence of directions to find the destination square on the game board.", "returns": "The destination square after following all specified directions.", "reason": "This method provides a straightforward way to navigate through the game board based on a predefined sequence of movements.", "howToUse": "Call this method with a list of directions and the starting square to get the final destination.", "howItWorks": "The method iterates over each direction in the list, updating the current position by moving one step at a time until it reaches the end of the path.", "assertions": {"preConditions": ["directions is not null and contains valid directions", "start is not null"], "postConditions": ["destination is not null and represents the final square after following all directions"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.background;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost", "labels": ["Container"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.npc.ghost", "kind": "package", "metaSrc": "source code", "description": "The package provides classes and utilities for managing navigation, pathfinding, and AI behavior in a Pac-Man game, including navigation paths, ghost movement logic, and targeting bugs.", "title": "Navigation and AI", "keywords": ["navigation", "pathfinding", "ghost", "AI", "targeting"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The height of the sprite to draw."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "kind": "method", "sourceText": "/**\r\n * Adds a key listener to the UI.\r\n *\r\n * @param keyCode\r\n * \t\tThe key code of the key as used by {@link java.awt.event.KeyEvent}.\r\n * @param action\r\n * \t\tThe action to perform when the key is pressed.\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder addKey(java.lang.Integer keyCode, nl.tudelft.jpacman.ui.Action action) {\r\n    assert keyCode != null;\r\n    assert action != null;\r\n    this.keyMappings.put(keyCode, action);\r\n    return this;\r\n}", "docComment": "Adds a key listener to the UI.\r\n\r\n@param keyCode\r\n\t\tThe key code of the key as used by {@link java.awt.event.KeyEvent}.\r\n@param action\r\n\t\tThe action to perform when the key is pressed.\r\n@return The builder.\r\n", "metaSrc": "source code", "description": "Adds a key mapping to the PacMan UI builder.", "returns": "This method returns the current instance of PacManUiBuilder.", "reason": "This method allows for the configuration of key bindings in the PacMan UI, enabling users to interact with the game using keyboard shortcuts.", "howToUse": "To use this method, call it on an instance of PacManUiBuilder and pass the desired key code and action as arguments. This setup will allow the specified action to be triggered when the corresponding key is pressed in the game.", "howItWorks": "The method first checks if the provided key code and action are not null. It then adds a mapping between the key code and the action to a map called keyMappings within the PacManUiBuilder instance. Finally, it returns the current instance of PacManUiBuilder.", "assertions": {"preConditions": ["The key code must be non-null."], "postConditions": ["The keyMappings map in the PacManUiBuilder instance will contain a mapping from the provided key code to the provided action."]}, "stereotype": "Mutator", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "labels": ["Variable"], "properties": {"simpleName": "source", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The input stream containing the text representation of the Pacman game map."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The ghost involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.image", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite of this unit.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite image;", "visibility": "private", "simpleName": "image", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.image", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Links this square to a neighbour in the given direction. Note that this\r\n * is a one-way connection.\r\n *\r\n * @param neighbour\r\n * \t\tThe neighbour to link.\r\n * @param direction\r\n * \t\tThe direction the new neighbour is in, as seen from this cell.\r\n */\r\npublic void link(nl.tudelft.jpacman.board.Square neighbour, nl.tudelft.jpacman.board.Direction direction) {\r\n    this.neighbours.put(direction, neighbour);\r\n    assert this.invariant();\r\n}", "docComment": "Links this square to a neighbour in the given direction. Note that this\r\nis a one-way connection.\r\n\r\n@param neighbour\r\n\t\tThe neighbour to link.\r\n@param direction\r\n\t\tThe direction the new neighbour is in, as seen from this cell.\r\n", "metaSrc": "source code", "description": "Adds a neighbour to the current square in the specified direction.", "returns": "", "reason": "To establish connections between squares on a game board.", "howToUse": "Call this method with a square and its direction to link it to another square.", "howItWorks": "Adds the neighbour to the current square's list of neighbours in the specified direction, then asserts that the invariant is maintained.", "assertions": {"preConditions": ["neighbour is not null", "direction is valid"], "postConditions": ["neighbour is added to the current square's list of neighbours in the specified direction", "invariant is maintained"]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The background for this square.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite background;", "visibility": "private", "simpleName": "background", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.awt.Image)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new sprite from an image.\r\n *\r\n * @param img\r\n * \t\tThe image to create a sprite from.\r\n */\r\npublic ImageSprite(java.awt.Image img) {\r\n    super();\r\n    this.image = img;\r\n}", "docComment": "Creates a new sprite from an image.\r\n\r\n@param img\r\n\t\tThe image to create a sprite from.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.neighbours", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The collection of squares adjacent to this square.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.board.Square> neighbours;", "visibility": "private", "simpleName": "neighbours", "qualifiedName": "nl.tudelft.jpacman.board.Square.neighbours", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "labels": ["Variable"], "properties": {"simpleName": "args", "qualifiedName": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.invariant()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "invariant()", "qualifiedName": "nl.tudelft.jpacman.board.Board.invariant()", "kind": "method", "sourceText": "/**\r\n * Whatever happens, the squares on the board can't be null.\r\n *\r\n * @return false if any square on the board is null.\r\n */\r\nprotected final boolean invariant() {\r\n    for (nl.tudelft.jpacman.board.Square[] row : this.board) {\r\n        for (nl.tudelft.jpacman.board.Square square : row) {\r\n            if (square == null) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}", "docComment": "Whatever happens, the squares on the board can't be null.\r\n\r\n@return false if any square on the board is null.\r\n", "metaSrc": "source code", "description": "Checks if all squares in the board are non-null.", "returns": "True if all squares are non-null, false otherwise.", "reason": "Ensures that the board is properly initialized and contains valid square objects.", "howToUse": "Call this method to verify the integrity of the board's state.", "howItWorks": "Iterates through each row and column of the board, checking if every square is non-null.", "assertions": {"preConditions": ["The board has been initialized with valid square objects."], "postConditions": ["Returns true if all squares are non-null, false otherwise."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "private void ghostColliding(nl.tudelft.jpacman.npc.Ghost ghost, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (collidedOn instanceof nl.tudelft.jpacman.level.Player) {\r\n        this.playerVersusGhost(((nl.tudelft.jpacman.level.Player) (collidedOn)), ghost);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Updates player points based on collision with a ghost and sets the player as dead.", "returns": "", "reason": "This method handles the logic for when a ghost collides with a player, updating the game state accordingly.", "howToUse": "Call this method when a collision between a ghost and a player is detected. It takes two parameters: the ghost object and the collided unit (which should be a player).", "howItWorks": "The method checks if the collided unit is an instance of Player. If so, it calls the playerVersusGhost method to update the game state.", "assertions": {"preConditions": ["A ghost object and a Unit object are provided as arguments."], "postConditions": ["The player's points are updated based on the collision with the ghost.", "The player is marked as dead if they collide with a ghost."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The direction for this node, which is <code>null</code> for the root\r\n * node.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Direction direction;", "visibility": "private", "simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "labels": ["Variable"], "properties": {"simpleName": "keyMappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A map of key codes to corresponding actions."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.board.Square[][])", "qualifiedName": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "kind": "constructor", "sourceText": "/**\r\n * Creates a new board.\r\n *\r\n * @param grid\r\n * \t\tThe grid of squares with grid[x][y] being the square at column\r\n * \t\tx, row y.\r\n */\r\n@java.lang.SuppressWarnings(\"PMD.ArrayIsStoredDirectly\")\r\nBoard(nl.tudelft.jpacman.board.Square[][] grid) {\r\n    super();\r\n    assert grid != null;\r\n    this.board = grid;\r\n    assert this.invariant() : \"Initial grid cannot contain null squares\";\r\n}", "docComment": "Creates a new board.\r\n\r\n@param grid\r\n\t\tThe grid of squares with grid[x][y] being the square at column\r\n\t\tx, row y.\r\n", "metaSrc": "source code", "description": "Initializes the board with a given grid and checks for null squares.", "returns": "None", "reason": "Ensures that the board is properly initialized and contains no null squares.", "howToUse": "Create a new Board instance by passing a valid 2D array of Square objects to the constructor.", "howItWorks": "The method checks if the grid is not null, then assigns it to the board field. It also asserts that all squares in the grid are non-null and throws an exception if any square is null.", "assertions": {"preConditions": ["grid != null"], "postConditions": ["this.board == grid", "all squares in this.board are non-null"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "traveller", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is currently moving."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The width of the sub-image."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.INKY", "labels": ["Variable"], "properties": {"sourceText": "private static final int INKY = 1;", "visibility": "private", "simpleName": "INKY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.INKY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * Inky has the most complicated AI of all. Inky considers two things: Blinky's\r\n * location, and the location two grid spaces ahead of Pac-Man. Inky\r\n * draws a line from Blinky to the spot that is two squares in front of\r\n * Pac-Man and extends that line twice as far. Therefore, if Inky is\r\n * alongside Blinky when they are behind Pac-Man, Inky will usually\r\n * follow Blinky the whole time. But if Inky is in front of Pac-Man when\r\n * Blinky is far behind him, Inky tends to want to move away from Pac-Man\r\n * (in reality, to a point very far ahead of Pac-Man). Inky is affected\r\n * by a similar targeting bug that affects Speedy. When Pac-Man is moving or\r\n * facing up, the spot Inky uses to draw the line is two squares above\r\n * and left of Pac-Man.\r\n * </p>\r\n *\r\n * <p>\r\n * <b>Implementation:</b>\r\n * To actually implement this in jpacman we have the following approximation:\r\n * first determine the square of Blinky (A) and the square 2\r\n * squares away from Pac-Man (B). Then determine the shortest path from A to\r\n * B regardless of terrain and walk that same path from B. This is the\r\n * destination.\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    nl.tudelft.jpacman.board.Unit blinky = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.npc.ghost.Blinky.class, this.getSquare());\r\n    nl.tudelft.jpacman.board.Unit player = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if ((blinky == null) || (player == null)) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert player.hasSquare();\r\n    nl.tudelft.jpacman.board.Square playerDestination = player.squaresAheadOf(nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD);\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> firstHalf = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(blinky.getSquare(), playerDestination, null);\r\n    if (firstHalf == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    nl.tudelft.jpacman.board.Square destination = this.followPath(firstHalf, playerDestination);\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), destination, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        return java.util.Optional.ofNullable(path.get(0));\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nInky has the most complicated AI of all. Inky considers two things: Blinky's\r\nlocation, and the location two grid spaces ahead of Pac-Man. Inky\r\ndraws a line from Blinky to the spot that is two squares in front of\r\nPac-Man and extends that line twice as far. Therefore, if Inky is\r\nalongside Blinky when they are behind Pac-Man, Inky will usually\r\nfollow Blinky the whole time. But if Inky is in front of Pac-Man when\r\nBlinky is far behind him, Inky tends to want to move away from Pac-Man\r\n(in reality, to a point very far ahead of Pac-Man). Inky is affected\r\nby a similar targeting bug that affects Speedy. When Pac-Man is moving or\r\nfacing up, the spot Inky uses to draw the line is two squares above\r\nand left of Pac-Man.\r\n</p>\r\n\r\n<p>\r\n<b>Implementation:</b>\r\nTo actually implement this in jpacman we have the following approximation:\r\nfirst determine the square of Blinky (A) and the square 2\r\nsquares away from Pac-Man (B). Then determine the shortest path from A to\r\nB regardless of terrain and walk that same path from B. This is the\r\ndestination.\r\n</p>\r\n", "metaSrc": "source code", "description": "Calculates the next move for Inky based on the shortest path to Blinky and then to the player, avoiding obstacles.", "returns": "Optional<Direction>", "reason": "Inky's AI strategy involves chasing Blinky while avoiding the player.", "howToUse": "Call this method to get the next move for Inky based on its current position and the game state.", "howItWorks": "1. Find the nearest Blinky and player squares.\n2. Calculate the shortest path from Blinky to the player.\n3. Follow that path to find the destination square.\n4. Calculate the shortest path from Inky's current square to the destination square.\n5. Return the first direction of the calculated path.", "assertions": {"preConditions": ["this.hasSquare()", "blinky != null", "player != null"], "postConditions": ["return value is an Optional containing a Direction or empty if no valid path exists"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Collides the two units and handles the result of the collision, which may\r\n * be nothing at all.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe unit that causes the collision by occupying a square with\r\n * \t\tanother unit already on it.\r\n * @param collidee\r\n * \t\tThe unit that is already on the square that is being invaded.\r\n */\r\n<C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void collide(C1 collider, C2 collidee);", "docComment": "Collides the two units and handles the result of the collision, which may\r\nbe nothing at all.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe unit that causes the collision by occupying a square with\r\n\t\tanother unit already on it.\r\n@param collidee\r\n\t\tThe unit that is already on the square that is being invaded.\r\n", "metaSrc": "source code", "description": "Handles collision detection between two units in the Pacman game.", "returns": "", "reason": "To manage interactions between different units in the game, such as collisions.", "howToUse": "Call this method when a collision occurs between two units to handle any necessary actions or updates.", "howItWorks": "The method is designed to be overridden by subclasses to implement specific collision logic for different types of units.", "assertions": {"preConditions": ["Both collider and collidee are valid instances of Unit."], "postConditions": ["No changes are made to the game state, but any necessary actions or updates are performed based on the collision."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "newImage(int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "kind": "method", "sourceText": "/**\r\n * Creates a new, empty image of the given width and height. Its\r\n * transparency will be a bitmask, so no try ARGB image.\r\n *\r\n * @param width\r\n * \t\tThe width of the new image.\r\n * @param height\r\n * \t\tThe height of the new image.\r\n * @return The new, empty image.\r\n */\r\nprivate java.awt.image.BufferedImage newImage(int width, int height) {\r\n    java.awt.GraphicsConfiguration gc = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();\r\n    return gc.createCompatibleImage(width, height, java.awt.Transparency.BITMASK);\r\n}", "docComment": "Creates a new, empty image of the given width and height. Its\r\ntransparency will be a bitmask, so no try ARGB image.\r\n\r\n@param width\r\n\t\tThe width of the new image.\r\n@param height\r\n\t\tThe height of the new image.\r\n@return The new, empty image.\r\n", "metaSrc": "source code", "description": "Creates a new BufferedImage with the specified width and height using the default screen device's configuration.", "returns": "A BufferedImage object with the specified dimensions and transparency.", "reason": "This method is used to create a new image for use in the Pacman game, which requires an image buffer to represent the game's graphics.", "howToUse": "Call this method with the desired width and height of the image you need. The returned BufferedImage can then be used to draw sprites or other graphical elements in the game.", "howItWorks": "The method uses the default screen device's configuration to create a new BufferedImage object with the specified dimensions and transparency level (BITMASK). This ensures that the image is compatible with the display settings of the user's computer.", "assertions": {"preConditions": ["width > 0", "height > 0"], "postConditions": ["returns an instance of java.awt.image.BufferedImage"]}, "stereotype": "Creational", "layer": "Data"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.Map,javax.swing.JFrame)", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "kind": "constructor", "sourceText": "/**\r\n * Create a new button panel with a button for every action.\r\n *\r\n * @param buttons\r\n * \t\tThe map of caption - action for each button.\r\n * @param parent\r\n * \t\tThe parent frame, used to return window focus.\r\n */\r\nButtonPanel(final java.util.Map<java.lang.String, nl.tudelft.jpacman.ui.Action> buttons, final javax.swing.JFrame parent) {\r\n    super();\r\n    assert buttons != null;\r\n    assert parent != null;\r\n    for (final java.lang.String caption : buttons.keySet()) {\r\n        javax.swing.JButton button = new javax.swing.JButton(caption);\r\n        button.addActionListener((java.awt.event.ActionEvent e) -> {\r\n            buttons.get(caption).doAction();\r\n            parent.requestFocusInWindow();\r\n        });\r\n        this.add(button);\r\n    }\r\n}", "docComment": "Create a new button panel with a button for every action.\r\n\r\n@param buttons\r\n\t\tThe map of caption - action for each button.\r\n@param parent\r\n\t\tThe parent frame, used to return window focus.\r\n", "metaSrc": "source code", "description": "Creates a panel with buttons that, when clicked, perform actions in the Pacman game and focus the parent window.", "returns": "None", "reason": "This method initializes the user interface of the Pacman game by creating buttons and associating them with actions.", "howToUse": "Create an instance of ButtonPanel, passing in a map of button captions to action objects and the parent JFrame.", "howItWorks": "The method iterates over the keys of the buttons map, creates a JButton for each caption, sets up an ActionListener that performs the corresponding action when clicked, and adds the button to the panel. After adding all buttons, it requests focus on the parent JFrame.", "assertions": {"preConditions": ["buttons is not null", "parent is not null"], "postConditions": ["All buttons are added to the panel", "The parent JFrame has focus after a button is clicked"]}, "stereotype": "UI", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The board on which the level will be played."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The panel displaying the game.\r\n */\r\nprivate final nl.tudelft.jpacman.ui.BoardPanel boardPanel;", "visibility": "private", "simpleName": "boardPanel", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stopNPCs()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "stopNPCs()", "qualifiedName": "nl.tudelft.jpacman.level.Level.stopNPCs()", "kind": "method", "sourceText": "/**\r\n * Stops all NPC movement scheduling and interrupts any movements being\r\n * executed.\r\n */\r\nprivate void stopNPCs() {\r\n    for (java.util.Map.Entry<nl.tudelft.jpacman.npc.Ghost, java.util.concurrent.ScheduledExecutorService> entry : this.npcs.entrySet()) {\r\n        java.util.concurrent.ScheduledExecutorService schedule = entry.getValue();\r\n        assert schedule != null;\r\n        schedule.shutdownNow();\r\n    }\r\n}", "docComment": "Stops all NPC movement scheduling and interrupts any movements being\r\nexecuted.\r\n", "metaSrc": "source code", "description": "Stops all scheduled tasks for NPCs in the level.", "returns": "", "reason": "To ensure that no NPC-related tasks are running when the level is stopped, this method shuts down their scheduled executors.", "howToUse": "Call `stopNPCs()` on an instance of `Level` to stop all NPC-related tasks.", "howItWorks": "Iterates over each entry in the NPCs map, retrieves the corresponding ScheduledExecutorService, and calls shutdownNow() to terminate any ongoing tasks.", "assertions": {"preConditions": ["The Level object is initialized with a non-null NPCs map."], "postConditions": ["All scheduled tasks for NPCs have been stopped."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getHeight() {\r\n    assert this.currentSprite() != null;\r\n    return this.currentSprite().getHeight();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the height of the current sprite in the animation sequence.", "returns": "The height of the current sprite as an integer.", "reason": "This method provides a straightforward way to access the height of the current sprite, which is essential for rendering and positioning animations correctly.", "howToUse": "Call this method on an instance of `AnimatedSprite` to retrieve its height.", "howItWorks": "The method first checks if the current sprite is not null. If it's not, it retrieves the height of the current sprite using the `getHeight()` method of the sprite object.", "assertions": {"preConditions": ["this.currentSprite() != null"], "postConditions": ["the height of the current sprite as an integer"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "kind": "method", "sourceText": "/**\r\n * Returns a map of animated ghost sprites for all directions.\r\n *\r\n * @param color\r\n * \t\tThe colour of the ghost.\r\n * @return The Sprite for the ghost.\r\n */\r\npublic java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor color) {\r\n    assert color != null;\r\n    java.lang.String resource = (\"/sprite/ghost_\" + color.name().toLowerCase()) + \".png\";\r\n    return this.directionSprite(resource, nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES);\r\n}", "docComment": "Returns a map of animated ghost sprites for all directions.\r\n\r\n@param color\r\n\t\tThe colour of the ghost.\r\n@return The Sprite for the ghost.\r\n", "metaSrc": "source code", "description": "Returns an animated sprite for each direction based on the specified ghost color.", "returns": "A map from directions to animated sprites.", "reason": "This method provides a convenient way to retrieve animated sprite images for different ghost colors, which is essential for rendering the game's graphical elements.", "howToUse": "Call this method with a GhostColor instance to get an animated sprite for that color. The returned map contains sprites for all four directions (up, down, left, right).", "howItWorks": "The method constructs a resource path based on the ghost color's name and calls the directionSprite method to create animated sprites for each direction. The resulting map is then returned.", "assertions": {"preConditions": ["color must not be null"], "postConditions": ["the returned map contains exactly four entries, one for each direction"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "labels": ["Structure"], "properties": {"docComment": "A task that moves an NPC and reschedules itself after it finished.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "NpcMoveTask", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "Manages NPC movement in a Pacman game by scheduling their moves at regular intervals.", "keywords": ["NPC", "movement", "ScheduledExecutorService", "Ghost"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.isInProgress()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isInProgress()", "qualifiedName": "nl.tudelft.jpacman.game.Game.isInProgress()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return <code>true</code> iff the game is started and in progress.\r\n */\r\npublic boolean isInProgress() {\r\n    return this.inProgress;\r\n}", "docComment": "\r\n@return <code>true</code> iff the game is started and in progress.\r\n", "metaSrc": "source code", "description": "Returns whether the game is currently in progress.", "returns": "Boolean indicating if the game is in progress.", "reason": "The method provides a simple way to check the current state of the game, which is essential for determining what actions can be taken or displayed to the user.", "howToUse": "Call `isInProgress()` on an instance of `Game` to determine if the game is active.", "howItWorks": "The method simply returns a boolean value stored in the `inProgress` field, which is set by other methods within the class.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation UID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new node.\r\n *\r\n * @param direction\r\n * \t\tThe direction, which is <code>null</code> for the root\r\n * \t\tnode.\r\n * @param square\r\n * \t\tThe square.\r\n * @param parent\r\n * \t\tThe parent node, which is <code>null</code> for the root\r\n * \t\tnode.\r\n */\r\nNode(nl.tudelft.jpacman.board.Direction direction, nl.tudelft.jpacman.board.Square square, nl.tudelft.jpacman.npc.ghost.Navigation.Node parent) {\r\n    super();\r\n    this.direction = direction;\r\n    this.square = square;\r\n    this.parent = parent;\r\n}", "docComment": "Creates a new node.\r\n\r\n@param direction\r\n\t\tThe direction, which is <code>null</code> for the root\r\n\t\tnode.\r\n@param square\r\n\t\tThe square.\r\n@param parent\r\n\t\tThe parent node, which is <code>null</code> for the root\r\n\t\tnode.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.lang.String,java.lang.Throwable)", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "kind": "constructor", "sourceText": "/**\r\n * A configuration exception with a root cause and additional explanation.\r\n *\r\n * @param message\r\n * \t\tThe explanation.\r\n * @param cause\r\n * \t\tThe root cause.\r\n */\r\npublic PacmanConfigurationException(java.lang.String message, java.lang.Throwable cause) {\r\n    super(message, cause);\r\n}", "docComment": "A configuration exception with a root cause and additional explanation.\r\n\r\n@param message\r\n\t\tThe explanation.\r\n@param cause\r\n\t\tThe root cause.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "labels": ["Variable"], "properties": {"simpleName": "window", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The dimensions of the window in which to render the board."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A list of starting positions for the player and other entities in the level."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "labels": ["Variable"], "properties": {"sourceText": "private static final int SQUARES_AHEAD = 2;", "visibility": "private", "simpleName": "SQUARES_AHEAD", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "/**\r\n * Method called whenever a player meets a ghost.\r\n * It can be used to update the player's points accordingly.\r\n *\r\n * @param player\r\n * \t\tThe player that will die.\r\n * @param ghost\r\n * \t\tThe ghost causing the player to die.\r\n */\r\nvoid collidedWithAGhost(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.npc.Ghost ghost);", "docComment": "Method called whenever a player meets a ghost.\r\nIt can be used to update the player's points accordingly.\r\n\r\n@param player\r\n\t\tThe player that will die.\r\n@param ghost\r\n\t\tThe ghost causing the player to die.\r\n", "metaSrc": "source code", "description": "Updates player points based on collision with a ghost.", "returns": "", "reason": "To manage game points and provide feedback to the player based on their interactions.", "howToUse": "Call this method when a collision between a player and a ghost occurs in the game.", "howItWorks": "The method updates the player's score by adding a predefined point value. It also triggers any necessary animations or effects related to the collision.", "assertions": {"preConditions": ["A valid Player object is provided.", "A valid Ghost object is provided."], "postConditions": ["The player's points are updated accordingly.", "Any associated animations or effects are triggered."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "labels": ["Variable"], "properties": {"simpleName": "action", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The action to be performed when the key is pressed."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player making the move."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPacManDeathAnimation()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The animation of a dying Pac-Man.\r\n */\r\npublic nl.tudelft.jpacman.sprite.AnimatedSprite getPacManDeathAnimation() {\r\n    java.lang.String resource = \"/sprite/dead.png\";\r\n    nl.tudelft.jpacman.sprite.Sprite baseImage = this.loadSprite(resource);\r\n    nl.tudelft.jpacman.sprite.AnimatedSprite animation = this.createAnimatedSprite(baseImage, nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES, nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY, false);\r\n    animation.setAnimating(false);\r\n    return animation;\r\n}", "docComment": "\r\n@return The animation of a dying Pac-Man.\r\n", "metaSrc": "source code", "description": "Returns an animated sprite representing Pac-Man's death animation.", "returns": "A new AnimatedSprite object representing Pac-Man's death animation.", "reason": "The method creates and returns an animated sprite for Pac-Man's death sequence, which is a visual effect used when Pac-Man dies in the game.", "howToUse": "Call this method to get the animated sprite for Pac-Man's death. This can be used in the game logic to display the animation when Pac-Man loses a life.", "howItWorks": "The method loads the 'dead.png' image, creates an AnimatedSprite object with the base image and specified frames and delay, sets it to not animate, and returns the animated sprite.", "assertions": {"preConditions": [], "postConditions": ["Returns a new AnimatedSprite object representing Pac-Man's death animation."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.collisions", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The table of possible collisions between units.\r\n */\r\nprivate final nl.tudelft.jpacman.level.CollisionMap collisions;", "visibility": "private", "simpleName": "collisions", "qualifiedName": "nl.tudelft.jpacman.level.Level.collisions", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "labels": ["Variable"], "properties": {"simpleName": "img", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The 2D array representing the game board."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "leaveSquare()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "kind": "method", "sourceText": "/**\r\n * Leaves the currently occupying square, thus removing this unit from the board.\r\n */\r\npublic void leaveSquare() {\r\n    if (this.square != null) {\r\n        this.square.remove(this);\r\n        this.square = null;\r\n    }\r\n    assert this.invariant();\r\n}", "docComment": "Leaves the currently occupying square, thus removing this unit from the board.\r\n", "metaSrc": "source code", "description": "Removes the unit from its current square and asserts that the invariant is maintained.", "returns": "", "reason": "Ensures that a unit is properly removed from its square and that the state of the board remains consistent.", "howToUse": "Call `leaveSquare()` on an instance of `Unit` to remove it from its current square.", "howItWorks": "Checks if the unit has a square, removes it from the square's list of occupants, sets the square to null, and asserts that the invariant is true.", "assertions": {"preConditions": ["The unit must be on a square."], "postConditions": ["The unit is not on any square.", "The square no longer contains the unit."]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "kind": "method", "sourceText": "/**\r\n * Method called whenever a player consumes a pellet.\r\n * It can be used to update the player's points accordingly.\r\n *\r\n * @param player\r\n * \t\tThe player consuming a pellet\r\n * @param pellet\r\n * \t\tThe pellet consumed.\r\n */\r\nvoid consumedAPellet(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Pellet pellet);", "docComment": "Method called whenever a player consumes a pellet.\r\nIt can be used to update the player's points accordingly.\r\n\r\n@param player\r\n\t\tThe player consuming a pellet\r\n@param pellet\r\n\t\tThe pellet consumed.\r\n", "metaSrc": "source code", "description": "Calculates points for a player consuming a pellet in the game.", "returns": "void", "reason": "This method is part of the point calculation logic in the game, which determines how many points a player earns for consuming a pellet.", "howToUse": "Call this method when a pellet is consumed by a player. It should be invoked within the game's logic layer to update the player's score.", "howItWorks": "The method retrieves the point value of the pellet and adds it to the player's current score. This is typically done in the game's logic layer where the game state is updated.", "assertions": {"preConditions": ["A valid Player object exists", "A valid Pellet object exists"], "postConditions": ["The player's score has been updated by adding the pellet's point value"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The mappings of keyCode to action.\r\n */\r\nprivate final java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> mappings;", "visibility": "private", "simpleName": "mappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new map parser.\r\n *\r\n * @param levelFactory\r\n * \t\tThe factory providing the NPC objects and the level.\r\n * @param boardFactory\r\n * \t\tThe factory providing the Square objects and the board.\r\n */\r\npublic MapParser(nl.tudelft.jpacman.level.LevelFactory levelFactory, nl.tudelft.jpacman.board.BoardFactory boardFactory) {\r\n    super();\r\n    this.levelCreator = levelFactory;\r\n    this.boardCreator = boardFactory;\r\n}", "docComment": "Creates a new map parser.\r\n\r\n@param levelFactory\r\n\t\tThe factory providing the NPC objects and the level.\r\n@param boardFactory\r\n\t\tThe factory providing the Square objects and the board.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player who consumes the Pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new BoardFactory that will create a board with the provided\r\n * background sprites.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite store providing the sprites for the background.\r\n */\r\npublic BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n}", "docComment": "Creates a new BoardFactory that will create a board with the provided\r\nbackground sprites.\r\n\r\n@param spriteStore\r\n\t\tThe sprite store providing the sprites for the background.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "labels": ["Variable"], "properties": {"simpleName": "clazz", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.isAlive()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAlive()", "qualifiedName": "nl.tudelft.jpacman.level.Player.isAlive()", "kind": "method", "sourceText": "/**\r\n * Returns whether this player is alive or not.\r\n *\r\n * @return <code>true</code> iff the player is alive.\r\n */\r\npublic boolean isAlive() {\r\n    return this.alive;\r\n}", "docComment": "Returns whether this player is alive or not.\r\n\r\n@return <code>true</code> iff the player is alive.\r\n", "metaSrc": "source code", "description": "Returns whether the player is alive.", "returns": "Boolean indicating if the player is alive.", "reason": "The method provides a simple getter for the 'alive' state of the player, which is essential for game logic and user interaction.", "howToUse": "Call `isAlive()` on an instance of `Player` to check if the player is still active in the game.", "howItWorks": "The method simply returns the value stored in the 'alive' field of the `Player` class, which is a boolean indicating whether the player is alive or not.", "preConditions": [], "postConditions": ["The returned value is a boolean that reflects the current state of the player's life."], "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "float", "labels": ["Primitive"], "properties": {"simpleName": "float", "qualifiedName": "float", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "private void playerColliding(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (collidedOn instanceof nl.tudelft.jpacman.npc.Ghost) {\r\n        this.playerVersusGhost(player, ((nl.tudelft.jpacman.npc.Ghost) (collidedOn)));\r\n    }\r\n    if (collidedOn instanceof nl.tudelft.jpacman.level.Pellet) {\r\n        this.playerVersusPellet(player, ((nl.tudelft.jpacman.level.Pellet) (collidedOn)));\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Handles player collisions with pellets or ghosts, updating points and game state accordingly.", "returns": "Void.", "reason": "Manages game logic for collisions between players and game entities.", "howToUse": "Call this method when a collision occurs between a player and another entity on the board.", "howItWorks": "Checks if the collided unit is a pellet or ghost, then calls the appropriate handling method to update points and game state.", "assertions": {"preConditions": ["The player and collidedOn are valid instances of their respective classes."], "postConditions": ["Player points are updated based on collision type.", "Game state is adjusted accordingly (e.g., death for ghosts)."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "kind": "static method", "sourceText": "/**\r\n * Finds the nearest unit of the given type and returns its location. This\r\n * method will perform a breadth first search starting from the given\r\n * square.\r\n *\r\n * @param type\r\n * \t\tThe type of unit to search for.\r\n * @param currentLocation\r\n * \t\tThe starting location for the search.\r\n * @return The nearest unit of the given type, or <code>null</code> if no\r\nsuch unit could be found.\r\n */\r\npublic static nl.tudelft.jpacman.board.Unit findNearest(java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> type, nl.tudelft.jpacman.board.Square currentLocation) {\r\n    java.util.List<nl.tudelft.jpacman.board.Square> toDo = new java.util.ArrayList<nl.tudelft.jpacman.board.Square>();\r\n    java.util.Set<nl.tudelft.jpacman.board.Square> visited = new java.util.HashSet<nl.tudelft.jpacman.board.Square>();\r\n    toDo.add(currentLocation);\r\n    while (!toDo.isEmpty()) {\r\n        nl.tudelft.jpacman.board.Square square = toDo.remove(0);\r\n        nl.tudelft.jpacman.board.Unit unit = nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(type, square);\r\n        if (unit != null) {\r\n            assert unit.hasSquare();\r\n            return unit;\r\n        }\r\n        visited.add(square);\r\n        for (nl.tudelft.jpacman.board.Direction direction : nl.tudelft.jpacman.board.Direction.values()) {\r\n            nl.tudelft.jpacman.board.Square newTarget = square.getSquareAt(direction);\r\n            if ((!visited.contains(newTarget)) && (!toDo.contains(newTarget))) {\r\n                toDo.add(newTarget);\r\n            }\r\n        }\r\n    } \r\n    return null;\r\n}", "docComment": "Finds the nearest unit of the given type and returns its location. This\r\nmethod will perform a breadth first search starting from the given\r\nsquare.\r\n\r\n@param type\r\n\t\tThe type of unit to search for.\r\n@param currentLocation\r\n\t\tThe starting location for the search.\r\n@return The nearest unit of the given type, or <code>null</code> if no\r\nsuch unit could be found.\r\n", "metaSrc": "source code", "description": "Finds the nearest instance of a specified unit class on the board from a given starting square.", "returns": "A nl.tudelft.jpacman.board.Unit instance if found, otherwise null.", "reason": "This method implements a breadth-first search (BFS) algorithm to find the nearest instance of a specified unit class on the board from a given starting square. It is used in the navigation logic for ghosts in the Pacman game.", "howToUse": "Call this method with the desired unit class and the current location of the ghost as arguments. The method will return the nearest instance of that unit class or null if no such unit is found.", "howItWorks": "The method initializes a list to keep track of squares to be visited (toDo) and a set to keep track of visited squares. It adds the current location to the toDo list and enters a loop where it removes the first square from the toDo list, checks if there is an instance of the specified unit class on that square, and returns it if found. If not, it marks the square as visited and explores its adjacent squares in all directions. The process continues until a unit is found or all reachable squares have been checked.", "assertions": {"preConditions": ["The currentLocation must be a valid square on the board."], "postConditions": ["If a unit of the specified type is found, it will be returned. If no such unit is found or an error occurs, null will be returned."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "neighbour", "qualifiedName": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The square to link."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "checkMapFormat(java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "kind": "method", "sourceText": "/**\r\n * Check the correctness of the map lines in the text.\r\n *\r\n * @param text\r\n * \t\tMap to be checked\r\n * @throws PacmanConfigurationException\r\n * \t\tif map is not OK.\r\n */\r\nprivate void checkMapFormat(java.util.List<java.lang.String> text) {\r\n    if (text == null) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text cannot be null.\");\r\n    }\r\n    if (text.isEmpty()) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text must consist of at least 1 row.\");\r\n    }\r\n    int width = text.get(0).length();\r\n    if (width == 0) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text lines cannot be empty.\");\r\n    }\r\n    for (java.lang.String line : text) {\r\n        if (line.length() != width) {\r\n            throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text lines are not of equal width.\");\r\n        }\r\n    }\r\n}", "docComment": "Check the correctness of the map lines in the text.\r\n\r\n@param text\r\n\t\tMap to be checked\r\n@throws PacmanConfigurationException\r\n\t\tif map is not OK.\r\n", "metaSrc": "source code", "description": "Checks if the input text is valid for parsing as a map in the Pacman game.", "returns": "", "reason": "Ensures that the input text is well-formed before parsing it into a map for use in the Pacman game.", "howToUse": "Call this method with a list of strings representing the map, where each string represents a row of the map.", "howItWorks": "The method checks if the input text is null or empty. It then verifies that all lines have the same width and throws exceptions if any of these conditions are not met.", "assertions": {"preConditions": ["text != null", "text.size() > 0"], "postConditions": ["The input text is valid for parsing as a map."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Create a simple player-based collision map, informing the\r\n * point calculator about points to be added.\r\n *\r\n * @param pointCalculator\r\n * \t\tStrategy for calculating points.\r\n */\r\npublic PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.pointCalculator = pointCalculator;\r\n}", "docComment": "Create a simple player-based collision map, informing the\r\npoint calculator about points to be added.\r\n\r\n@param pointCalculator\r\n\t\tStrategy for calculating points.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "X-coordinate to check"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player", "labels": ["Structure"], "properties": {"docComment": "A player operated unit in our game.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Player", "qualifiedName": "nl.tudelft.jpacman.level.Player", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The Player class is responsible for managing the state and behavior of Pac-Man in the game, including its score, health, and interactions with other entities.", "keywords": ["player", "pacman", "score", "health", "interactions"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "/**\r\n * creates a Square with the specified ghost on it\r\n * and appends the placed ghost into the ghost list.\r\n *\r\n * @param ghosts\r\n * \t\tall the ghosts in the level so far, the new ghost will be appended\r\n * @param ghost\r\n * \t\tthe newly created ghost to be placed\r\n * @return a square with the ghost on it.\r\n */\r\nprotected nl.tudelft.jpacman.board.Square makeGhostSquare(java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, nl.tudelft.jpacman.npc.Ghost ghost) {\r\n    nl.tudelft.jpacman.board.Square ghostSquare = this.boardCreator.createGround();\r\n    ghosts.add(ghost);\r\n    ghost.occupy(ghostSquare);\r\n    return ghostSquare;\r\n}", "docComment": "creates a Square with the specified ghost on it\r\nand appends the placed ghost into the ghost list.\r\n\r\n@param ghosts\r\n\t\tall the ghosts in the level so far, the new ghost will be appended\r\n@param ghost\r\n\t\tthe newly created ghost to be placed\r\n@return a square with the ghost on it.\r\n", "metaSrc": "source code", "description": "Creates a new Ground square for a ghost and adds it to the list of ghosts.", "returns": "A new Square representing the ground.", "reason": "This method is responsible for creating a new square for a ghost, adding it to the list of ghosts, and occupying the square with the ghost.", "howToUse": "Call this method with a list of ghosts and a specific ghost object to create a new Ground square for that ghost.", "howItWorks": "The method creates a new Ground square using the `boardCreator.createGround()` method. It then adds the ghost to the list of ghosts and occupies the newly created ground square with the ghost using the `occupy(Square)` method.", "assertions": {"preConditions": ["A valid list of ghosts is provided.", "The ghost object is not null."], "postConditions": ["A new Ground square is created and added to the list of ghosts.", "The ghost is occupied on the newly created ground square."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite", "labels": ["Container"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.sprite", "kind": "package", "metaSrc": "source code", "description": "The nl.tudelft.jpacman.sprite package contains classes and interfaces responsible for managing game sprites in a Pacman implementation, including handling animations, rendering images, and providing access to various game elements.", "title": "Sprite Management", "keywords": ["sprites", "animation", "image", "game element"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.Launcher()", "kind": "constructor", "sourceText": "Launcher() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "type", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The class type of the unit to find."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.inProgress", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> if the game is in progress.\r\n */\r\nprivate boolean inProgress;", "visibility": "private", "simpleName": "inProgress", "qualifiedName": "nl.tudelft.jpacman.game.Game.inProgress", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "withinImage(int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "kind": "method", "sourceText": "private boolean withinImage(int x, int y) {\r\n    return (((x < this.image.getWidth(null)) && (x >= 0)) && (y < this.image.getHeight(null))) && (y >= 0);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Checks if given coordinates are within the bounds of the image.", "returns": "Boolean indicating if the coordinates are within the image bounds", "reason": "Ensures that sprite coordinates do not exceed the image dimensions.", "howToUse": "Call `withinImage(x, y)` with valid integer values for x and y to determine if they are within the image's boundaries.", "howItWorks": "The method checks if both x and y are within the range of the image's width and height. It returns true if both conditions are met; otherwise, it returns false.", "assertions": {"preConditions": ["x is an integer", "y is an integer"], "postConditions": ["Returns true if x and y are within the image's bounds, false otherwise."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The board to search on."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The grid representing the board."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void pacmanMoved(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Direction direction) {\r\n    // no points for moving\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.npcs", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The NPCs of this level and, if they are running, their schedules.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.npc.Ghost, java.util.concurrent.ScheduledExecutorService> npcs;", "visibility": "private", "simpleName": "npcs", "qualifiedName": "nl.tudelft.jpacman.level.Level.npcs", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory", "labels": ["Container", "Structure"], "properties": {"docComment": "Factory that creates levels and units.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "LevelFactory", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The LevelFactory class is responsible for creating and managing game entities such as ghosts, pellets, and levels. It provides methods to initialize these entities based on predefined configurations and data.", "keywords": ["LevelFactory", "PacMan", "Game Entities", "Ghost Factory", "Pellet Creation"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation ID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver", "labels": ["Structure"], "properties": {"docComment": "An observer that will be notified when the level is won or lost.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "LevelObserver", "qualifiedName": "nl.tudelft.jpacman.level.Level$LevelObserver", "kind": "interface", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The Level$LevelObserver interface in the jpacman project is responsible for notifying observers about significant events related to a game level, such as when the level is lost or won. It provides methods to handle these events and can be used by other components to react accordingly.", "keywords": ["level observer", "game event notification", "pacman game"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The point calculator to be used for scoring."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isInProgress()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isInProgress()", "qualifiedName": "nl.tudelft.jpacman.level.Level.isInProgress()", "kind": "method", "sourceText": "/**\r\n * Returns whether this level is in progress, i.e. whether moves can be made\r\n * on the board.\r\n *\r\n * @return <code>true</code> iff this level is in progress.\r\n */\r\npublic boolean isInProgress() {\r\n    return this.inProgress;\r\n}", "docComment": "Returns whether this level is in progress, i.e. whether moves can be made\r\non the board.\r\n\r\n@return <code>true</code> iff this level is in progress.\r\n", "metaSrc": "source code", "description": "Returns whether the level is currently in progress.", "returns": "Boolean indicating if the level is in progress.", "reason": "The method provides a simple getter for the 'inProgress' state of the level, which is essential for determining the game's progression and user interaction.", "howToUse": "Call `isInProgress()` to check if the level is active.", "howItWorks": "The method simply returns the value stored in the 'inProgress' field.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory", "labels": ["Container", "Structure"], "properties": {"docComment": "A factory that creates {@link Board} objects from 2-dimensional arrays of\r\n{@link Square}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "BoardFactory", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The BoardFactory class is responsible for creating and managing game boards in the Pacman game. It initializes a board by connecting squares, provides methods to create different types of squares (ground and wall), and handles resource loading for sprites.", "keywords": ["BoardFactory", "Pacman", "Game Board", "Square Creation", "Resource Management"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The ghost to be added to the list and placed on a new Ground square."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "kind": "method", "sourceText": "/**\r\n * Let the score panel use a dedicated score formatter.\r\n *\r\n * @param scoreFormatter\r\n * \t\tScore formatter to be used.\r\n */\r\npublic void setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter) {\r\n    assert scoreFormatter != null;\r\n    this.scoreFormatter = scoreFormatter;\r\n}", "docComment": "Let the score panel use a dedicated score formatter.\r\n\r\n@param scoreFormatter\r\n\t\tScore formatter to be used.\r\n", "metaSrc": "source code", "description": "Sets the score formatter for displaying scores in the game.", "returns": "", "reason": "This method allows the game's score display to be customized.", "howToUse": "Call this method with an instance of ScoreFormatter to change how scores are displayed in the game.", "howItWorks": "The method checks if the provided score formatter is not null and then sets it as the current score formatter for the ScorePanel.", "assertions": {"preConditions": ["scoreFormatter != null"], "postConditions": ["this.scoreFormatter == scoreFormatter"]}, "stereotype": "Mutator", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "loadPointCalculator()", "qualifiedName": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "kind": "method", "sourceText": "private nl.tudelft.jpacman.points.PointCalculator loadPointCalculator() {\r\n    return new nl.tudelft.jpacman.points.PointCalculatorLoader().load();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Loads a point calculator dynamically from a specified file or uses a default if not found.", "returns": "The loaded PointCalculator instance.", "reason": "This method provides a flexible way to load a point calculator, allowing for dynamic configuration and easy integration of different scoring systems.", "howToUse": "Call the `loadPointCalculator()` method to obtain an instance of the PointCalculator. This is typically used in the initialization phase of the game to set up the scoring system.", "howItWorks": "The method uses a `PointCalculatorLoader` to dynamically load a point calculator class from a specified file or defaults to a predefined implementation if no file is found.", "assertions": {"preConditions": [], "postConditions": ["The returned PointCalculator instance is not null."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "labels": ["Variable"], "properties": {"simpleName": "event", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.EAST", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * East, or right.\r\n */\r\nEAST(1, 0)", "visibility": "public", "simpleName": "EAST", "qualifiedName": "nl.tudelft.jpacman.board.Direction.EAST", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The parent node, which is <code>null</code> for the root node.\r\n */\r\nprivate final nl.tudelft.jpacman.npc.ghost.Navigation.Node parent;", "visibility": "private", "simpleName": "parent", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite", "labels": ["Structure"], "properties": {"docComment": "Animated sprite, renders the frame depending on the time of requesting the\r\ndraw.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "AnimatedSprite", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite", "kind": "class", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The class is responsible for managing and updating animated sprites, including handling their animation loops, frame updates, and splitting into smaller parts.", "keywords": ["animation", "sprite management", "update loop", "frame delay", "splitting"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "labels": ["Structure"], "properties": {"docComment": "Provide means to format the score for a given player.\r\n", "simpleName": "ScoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "kind": "interface", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The ScoreFormatter interface is responsible for formatting and displaying scores in the Pacman game. It provides a method to format the score of a given player, which is essential for updating the user interface with accurate score information.", "keywords": ["Score", "Formatting", "Pacman", "User Interface"], "roleStereotype": "User Interfacer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites()", "kind": "constructor", "sourceText": "PacManSprites() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Initializes a new instance of PacManSprites by calling the superclass constructor.", "returns": "A newly created instance of PacManSprites with an empty HashMap for storing sprite mappings.", "reason": "The method initializes a new instance of SpriteStore, which is a superclass of PacManSprites. This setup ensures that any necessary resources or configurations are properly initialized before the specific functionality of PacManSprites can be used.", "howToUse": "To use this method, simply instantiate a new PacManSprites object.", "howItWorks": "The method calls the superclass constructor using `super()`, which initializes an empty HashMap to store sprite mappings. This setup is crucial for managing and accessing sprites in the PacMan game.", "assertions": {"preConditions": [], "postConditions": ["A new instance of PacManSprites with an empty HashMap is created."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of frames in the pacman animation.\r\n */\r\nprivate static final int PACMAN_ANIMATION_FRAMES = 4;", "visibility": "private", "simpleName": "PACMAN_ANIMATION_FRAMES", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createWall()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "kind": "method", "sourceText": "/**\r\n * Creates a new square that cannot be occupied by any unit.\r\n *\r\n * @return A new square that cannot be occupied by any unit.\r\n */\r\npublic nl.tudelft.jpacman.board.Square createWall() {\r\n    return new nl.tudelft.jpacman.board.BoardFactory.Wall(this.sprites.getWallSprite());\r\n}", "docComment": "Creates a new square that cannot be occupied by any unit.\r\n\r\n@return A new square that cannot be occupied by any unit.\r\n", "metaSrc": "source code", "description": "Creates a new Wall square using the specified wall sprite.", "returns": "A new Square representing a wall on the board.", "reason": "The method provides a way to create a physical representation of walls in the game, which is essential for defining the boundaries and obstacles within the game world.", "howToUse": "Call this method with no arguments to obtain a Wall square object. This object can then be added to the board using the BoardFactory's addSquare() method.", "howItWorks": "The method retrieves the wall sprite from the resource file using the getWallSprite() method and creates a new Wall instance, passing the retrieved sprite as an argument to its constructor.", "assertions": {"preConditions": [], "postConditions": ["A new Square object representing a wall is returned."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.getBoard()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getBoard()", "qualifiedName": "nl.tudelft.jpacman.level.Level.getBoard()", "kind": "method", "sourceText": "/**\r\n * Returns the board of this level.\r\n *\r\n * @return The board of this level.\r\n */\r\npublic nl.tudelft.jpacman.board.Board getBoard() {\r\n    return this.board;\r\n}", "docComment": "Returns the board of this level.\r\n\r\n@return The board of this level.\r\n", "metaSrc": "source code", "description": "Returns the board instance associated with the level.", "returns": "The Board object representing the game board.", "reason": "This method provides access to the internal state of the level, allowing for manipulation or inspection of the game board.", "howToUse": "To use this method, simply call it on an instance of Level. This will return the current state of the game board.", "howItWorks": "The method returns a reference to the private field 'board' which holds the Board object representing the game board.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "labels": ["Variable"], "properties": {"simpleName": "deathAnimation", "qualifiedName": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The animated sprite used when the player dies."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate to check."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.sprites.get(this.getDirection());\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the sprite corresponding to the current direction of the ghost.", "returns": "The Sprite representing the ghost's current direction.", "reason": "This method provides a way to dynamically change the visual representation of the ghost based on its movement direction, enhancing the game's visual feedback and interactivity.", "howToUse": "Call this method to get the sprite that should be displayed for the ghost in its current state.", "howItWorks": "The method retrieves the sprite from a list of sprites associated with each direction. It uses the `getDirection()` method to determine which sprite to return.", "assertions": {"preConditions": ["The Ghost object has been initialized and is not null."], "postConditions": ["The returned Sprite is not null."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Shadow.\r\n</p>\r\n<p>\r\nNickname: Blinky. As his name implies, Shadow is usually a constant shadow on\r\nPac-Man's tail. When he's not patrolling the top-right corner of the maze,\r\nShadow tries to find the quickest route to Pac-Man's position. Despite the\r\nfact that Pinky's real name is Speedy, Shadow is actually the fastest of the\r\nghosts because of when there are only a few pellets left, Blinky drastically\r\nspeeds up, which can make him quite deadly. In the original Japanese version,\r\nhis name is Oikake/Akabei.\r\n</p>\r\n<p>\r\n<b>AI:</b> When the ghosts are not patrolling in their home corners (Blinky:\r\ntop-right, Pinky: top-left, Inky: bottom-right, Clyde: bottom-left), Blinky\r\nwill attempt to shorten the distance between Pac-Man and himself. If he has\r\nto choose between shortening the horizontal or vertical distance, he will\r\nchoose to shorten whichever is greatest. For example, if Pac-Man is four grid\r\nspaces to the left, and seven grid spaces above Blinky, he'll try to move up\r\ntowards Pac-Man before he moves to the left.\r\n</p>\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Blinky", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The Blinky class is responsible for managing the AI logic and movement of the Blinky ghost in the Pacman game. It initializes the ghost with specific properties, determines the next move based on finding the nearest player, and handles the logic for avoiding obstacles.", "keywords": ["Blinky", "Ghost", "Pacman", "AI", "Movement", "Pathfinding"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.boardCreator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory that creates the squares and board.\r\n */\r\nprivate final nl.tudelft.jpacman.board.BoardFactory boardCreator;", "visibility": "private", "simpleName": "boardCreator", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.boardCreator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that was collided with, which must be a player."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "labels": ["Variable"], "properties": {"simpleName": "event", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The KeyEvent object containing information about the pressed key."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "mover", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that causes the collision by occupying a square with another unit already on it."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The default way in which the score is shown.\r\n */\r\npublic static final nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter DEFAULT_SCORE_FORMATTER = (nl.tudelft.jpacman.level.Player player) -> java.lang.String.format(\"Score: %3d\", player.getScore());", "visibility": "public", "simpleName": "DEFAULT_SCORE_FORMATTER", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelMap()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getLevelMap()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getLevelMap()", "kind": "method", "sourceText": "/**\r\n * The map file used to populate the level.\r\n *\r\n * @return The name of the map file.\r\n */\r\nprotected java.lang.String getLevelMap() {\r\n    return this.levelMap;\r\n}", "docComment": "The map file used to populate the level.\r\n\r\n@return The name of the map file.\r\n", "metaSrc": "source code", "description": "Returns the level map for the Pacman game.", "returns": "The level map as a string.", "reason": "This method provides access to the level data used in the Pacman game, allowing other parts of the application to interact with and display the game's levels.", "howToUse": "Call `getLevelMap()` on an instance of `nl.tudelft.jpacman.Launcher` to retrieve the current level map.", "howItWorks": "The method simply returns the value stored in the `levelMap` field, which is assumed to be initialized elsewhere in the class.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of cells Clyde wants to stay away from Pac Man.\r\n */\r\nprivate static final int SHYNESS = 8;", "visibility": "private", "simpleName": "SHYNESS", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The collection of collision handlers.\r\n */\r\nprivate final java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>>> handlers;", "visibility": "private", "simpleName": "handlers", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "kind": "method", "sourceText": "/**\r\n * Adds a button to the UI.\r\n *\r\n * @param caption\r\n * \t\tThe caption of the button.\r\n * @param action\r\n * \t\tThe action to execute when the button is clicked.\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder addButton(java.lang.String caption, nl.tudelft.jpacman.ui.Action action) {\r\n    assert caption != null;\r\n    assert !caption.isEmpty();\r\n    assert action != null;\r\n    this.buttons.put(caption, action);\r\n    return this;\r\n}", "docComment": "Adds a button to the UI.\r\n\r\n@param caption\r\n\t\tThe caption of the button.\r\n@param action\r\n\t\tThe action to execute when the button is clicked.\r\n@return The builder.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The width of the target sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 250;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getPath()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "kind": "method", "sourceText": "/**\r\n * Returns the list of values from the root of the tree to this node.\r\n *\r\n * @return The list of values from the root of the tree to this node.\r\n */\r\nprivate java.util.List<nl.tudelft.jpacman.board.Direction> getPath() {\r\n    if (this.parent == null) {\r\n        return new java.util.ArrayList<nl.tudelft.jpacman.board.Direction>();\r\n    }\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = this.parent.getPath();\r\n    path.add(this.getDirection());\r\n    return path;\r\n}", "docComment": "Returns the list of values from the root of the tree to this node.\r\n\r\n@return The list of values from the root of the tree to this node.\r\n", "metaSrc": "source code", "description": "Returns the list of directions from the root node to the current node in the navigation tree.", "returns": "A list of Direction objects representing the path from the root to the current node.", "reason": "The method provides a way to trace back the path taken by a ghost in the game, which is essential for navigation and collision detection.", "howToUse": "Call this method on an instance of Navigation$Node to get the path it represents.", "howItWorks": "If the node has no parent (i.e., it's the root), it returns an empty list. Otherwise, it recursively retrieves the path from its parent and adds the current direction to the end.", "assertions": {"preConditions": ["The method is called on a valid instance of Navigation$Node."], "postConditions": ["The returned list contains all directions from the root node to the current node."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "labels": ["Variable"], "properties": {"simpleName": "g", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file containing the sprite images."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction of the move."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelWon()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelWon()", "qualifiedName": "nl.tudelft.jpacman.game.Game.levelWon()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void levelWon() {\r\n    this.stop();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Stops the game by pausing it and setting the inProgress flag to false.", "returns": "", "reason": "The method is designed to stop the game when a level is won, which involves pausing the game and resetting its state.", "howToUse": "Call this method after a level has been completed successfully.", "howItWorks": "Sets the inProgress flag to false and calls the stop() method to pause the game.", "assertions": {"preConditions": ["The game is currently in progress."], "postConditions": ["The game is paused, and the inProgress flag is set to false."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "load()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "kind": "method", "sourceText": "/**\r\n * Load a points calculator and return it.\r\n *\r\n * @return The (dynamically loaded) points calculator.\r\n */\r\npublic nl.tudelft.jpacman.points.PointCalculator load() {\r\n    try {\r\n        if (nl.tudelft.jpacman.points.PointCalculatorLoader.clazz == null) {\r\n            nl.tudelft.jpacman.points.PointCalculatorLoader.clazz = this.loadClassFromFile();\r\n        }\r\n        return ((nl.tudelft.jpacman.points.PointCalculator) (nl.tudelft.jpacman.points.PointCalculatorLoader.clazz.newInstance()));\r\n    } catch (java.lang.Exception e) {\r\n        throw new java.lang.RuntimeException(\"Could not dynamically load the points calculator.\", e);\r\n    }\r\n}", "docComment": "Load a points calculator and return it.\r\n\r\n@return The (dynamically loaded) points calculator.\r\n", "metaSrc": "source code", "description": "Loads a point calculator class dynamically from a specified file or uses a default if not found.", "returns": "The loaded PointCalculator instance.", "reason": "This method provides dynamic loading of a point calculator, allowing for flexibility in choosing different implementations based on configuration or runtime conditions.", "howToUse": "Call the load() method to obtain an instance of the PointCalculator. This is typically used when configuring game settings or dynamically selecting a scoring system.", "howItWorks": "The method first checks if the class has already been loaded. If not, it loads the class from a specified file using loadClassFromFile(). It then creates a new instance of the loaded class and returns it.", "assertions": {"preConditions": ["The PointCalculatorLoader class is initialized.", "The loadClassFromFile() method can be called without errors."], "postConditions": ["A valid PointCalculator instance is returned."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory providing the player objects.\r\n */\r\nprivate final nl.tudelft.jpacman.level.PlayerFactory playerFactory;", "visibility": "private", "simpleName": "playerFactory", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(char[][])", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "kind": "method", "sourceText": "/**\r\n * Parses the text representation of the board into an actual level.\r\n *\r\n * <ul>\r\n * <li>Supported characters:\r\n * <li>' ' (space) an empty square.\r\n * <li>'#' (bracket) a wall.\r\n * <li>'.' (period) a square with a pellet.\r\n * <li>'P' (capital P) a starting square for players.\r\n * <li>'G' (capital G) a square with a ghost.\r\n * </ul>\r\n *\r\n * @param map\r\n * \t\tThe text representation of the board, with map[x][y]\r\n * \t\trepresenting the square at position x,y.\r\n * @return The level as represented by this text.\r\n */\r\npublic nl.tudelft.jpacman.level.Level parseMap(char[][] map) {\r\n    int width = map.length;\r\n    int height = map[0].length;\r\n    nl.tudelft.jpacman.board.Square[][] grid = new nl.tudelft.jpacman.board.Square[width][height];\r\n    java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts = new java.util.ArrayList<nl.tudelft.jpacman.npc.Ghost>();\r\n    java.util.List<nl.tudelft.jpacman.board.Square> startPositions = new java.util.ArrayList<nl.tudelft.jpacman.board.Square>();\r\n    this.makeGrid(map, width, height, grid, ghosts, startPositions);\r\n    nl.tudelft.jpacman.board.Board board = this.boardCreator.createBoard(grid);\r\n    return this.levelCreator.createLevel(board, ghosts, startPositions);\r\n}", "docComment": "Parses the text representation of the board into an actual level.\r\n\r\n<ul>\r\n<li>Supported characters:\r\n<li>' ' (space) an empty square.\r\n<li>'#' (bracket) a wall.\r\n<li>'.' (period) a square with a pellet.\r\n<li>'P' (capital P) a starting square for players.\r\n<li>'G' (capital G) a square with a ghost.\r\n</ul>\r\n\r\n@param map\r\n\t\tThe text representation of the board, with map[x][y]\r\n\t\trepresenting the square at position x,y.\r\n@return The level as represented by this text.\r\n", "metaSrc": "source code", "description": "Parses a character map into a Pacman game level by creating a grid of squares, linking them, and initializing ghosts and start positions.", "returns": "An instance of nl.tudelft.jpacman.level.Level.", "reason": "The method is responsible for parsing a map into a playable level, which involves creating a grid of squares, linking them to form a connected board, and initializing ghosts and start positions.", "howToUse": "Call the parseMap method with a character array representing the game board layout.", "howItWorks": "The method first determines the width and height of the map. It then creates a grid of squares and initializes lists for ghosts and start positions. The makeGrid method parses the map, creating appropriate entities like walls, pellets, and ghosts based on the characters in the map. After parsing, it creates a board from the grid and uses the level creator to create a new level.", "assertions": {"preConditions": ["The input map is a valid 2D array of characters."], "postConditions": ["A new Level instance is returned with the parsed game board, ghosts, and start positions."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getLevel()", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.level.Level getLevel() {\r\n    return this.level;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getHeight() {\r\n    return this.image.getHeight(null);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new game.\r\n *\r\n * @param pointCalculator\r\n * \t\tThe way to calculate points upon collisions.\r\n */\r\nprotected Game(nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.pointCalculator = pointCalculator;\r\n    this.inProgress = false;\r\n}", "docComment": "Creates a new game.\r\n\r\n@param pointCalculator\r\n\t\tThe way to calculate points upon collisions.\r\n", "metaSrc": "source code", "description": "Initializes a new game instance with a specified point calculator.", "returns": "A new instance of Game with the specified point calculator.", "reason": "This method is a constructor that initializes a new game object, setting up its core components including the point calculator and initializing other necessary fields.", "howToUse": "To use this method, create a new instance of Game by passing an implementation of PointCalculator to it. This setup allows for scoring in the game based on various actions performed by players.", "howItWorks": "The constructor initializes the superclass with no arguments, sets the point calculator field, and marks the game as not in progress. It also prepares any other necessary fields or configurations for the game.", "assertions": {"preConditions": ["A valid PointCalculator instance is provided."], "postConditions": ["The Game object is created with the specified point calculator.", "The game is initialized as not in progress."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.deathSprite", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The animation that is to be played when Pac-Man dies.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.AnimatedSprite deathSprite;", "visibility": "private", "simpleName": "deathSprite", "qualifiedName": "nl.tudelft.jpacman.level.Player.deathSprite", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The square to render."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void collidedWithAGhost(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.npc.Ghost ghost) {\r\n    // no points for colliding with a ghost\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that the mover collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.List)", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new score panel with a column for each player.\r\n *\r\n * @param players\r\n * \t\tThe players to display the scores of.\r\n */\r\npublic ScorePanel(java.util.List<nl.tudelft.jpacman.level.Player> players) {\r\n    super();\r\n    assert players != null;\r\n    this.setLayout(new java.awt.GridLayout(2, players.size()));\r\n    for (int i = 1; i <= players.size(); i++) {\r\n        this.add(new javax.swing.JLabel(\"Player \" + i, javax.swing.JLabel.CENTER));\r\n    }\r\n    this.scoreLabels = new java.util.LinkedHashMap<nl.tudelft.jpacman.level.Player, javax.swing.JLabel>();\r\n    for (nl.tudelft.jpacman.level.Player player : players) {\r\n        javax.swing.JLabel scoreLabel = new javax.swing.JLabel(\"0\", javax.swing.JLabel.CENTER);\r\n        this.scoreLabels.put(player, scoreLabel);\r\n        this.add(scoreLabel);\r\n    }\r\n}", "docComment": "Creates a new score panel with a column for each player.\r\n\r\n@param players\r\n\t\tThe players to display the scores of.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "message", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "paint(java.awt.Graphics)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void paint(java.awt.Graphics g) {\r\n    assert g != null;\r\n    this.render(this.game.getLevel().getBoard(), g, this.getSize());\r\n}", "docComment": "", "metaSrc": "source code", "description": "Renders the game board by drawing each square and its occupants on the screen.", "returns": "Void", "reason": "The method is responsible for updating the visual representation of the game board in response to changes in the game state.", "howToUse": "Call this method whenever the game board needs to be redrawn, typically after a level change or when an entity moves on the board.", "howItWorks": "The method retrieves the current level and its board, then calls the `render` method of the `BoardPanel` class to draw each square and its occupants on the screen using the provided graphics context.", "assertions": {"preConditions": ["g is not null"], "postConditions": ["the game board is rendered on the screen"]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "labels": ["Variable"], "properties": {"simpleName": "delay", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "Delay between each frame in milliseconds."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "refresh()", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "kind": "method", "sourceText": "/**\r\n * Refreshes the scores of the players.\r\n */\r\nprotected void refresh() {\r\n    for (java.util.Map.Entry<nl.tudelft.jpacman.level.Player, javax.swing.JLabel> entry : this.scoreLabels.entrySet()) {\r\n        nl.tudelft.jpacman.level.Player player = entry.getKey();\r\n        java.lang.String score = \"\";\r\n        if (!player.isAlive()) {\r\n            score = \"You died. \";\r\n        }\r\n        score += this.scoreFormatter.format(player);\r\n        entry.getValue().setText(score);\r\n    }\r\n}", "docComment": "Refreshes the scores of the players.\r\n", "metaSrc": "source code", "description": "Updates the score panel to reflect the current state of players in the Pacman game, including their lives and scores.", "returns": "void", "reason": "The method updates the UI elements based on the game's logic, ensuring that the user interface accurately reflects the game's state.", "howToUse": "Call this method whenever a player's state changes (e.g., death or score update) to refresh the display.", "howItWorks": "Iterates over each player in the game, checks if they are alive, and formats their score. It then updates the corresponding label in the UI with the formatted score.", "assertions": {"preConditions": ["The method is called when necessary to update the UI based on game state changes."], "postConditions": ["All player labels in the UI are updated to reflect their current state and scores."]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "updateObservers()", "qualifiedName": "nl.tudelft.jpacman.level.Level.updateObservers()", "kind": "method", "sourceText": "/**\r\n * Updates the observers about the state of this level.\r\n */\r\nprivate void updateObservers() {\r\n    java.lang.Iterable<nl.tudelft.jpacman.level.Level.LevelObserver> observers = new java.util.ArrayList<nl.tudelft.jpacman.level.Level.LevelObserver>(this.observers);\r\n    if (!this.isAnyPlayerAlive()) {\r\n        for (nl.tudelft.jpacman.level.Level.LevelObserver observer : observers) {\r\n            observer.levelLost();\r\n        }\r\n    }\r\n    if (this.remainingPellets() == 0) {\r\n        for (nl.tudelft.jpacman.level.Level.LevelObserver observer : observers) {\r\n            observer.levelWon();\r\n        }\r\n    }\r\n}", "docComment": "Updates the observers about the state of this level.\r\n", "metaSrc": "source code", "description": "Notifies observers when the level is lost or won based on player health and remaining pellets.", "returns": "", "reason": "The method updates observers about the game's state, notifying them of level loss or win conditions.", "howToUse": "Call `updateObservers()` to check for level completion conditions and notify observers accordingly.", "howItWorks": "Iterates over observers and calls their respective methods (`levelLost` or `levelWon`) based on the level's state.", "assertions": {"preConditions": ["The method is called when the game state changes (e.g., player death, all pellets collected)."], "postConditions": ["Observers are notified of the level's completion status."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addPoints(int)", "qualifiedName": "nl.tudelft.jpacman.level.Player.addPoints(int)", "kind": "method", "sourceText": "/**\r\n * Adds points to the score of this player.\r\n *\r\n * @param points\r\n * \t\tThe amount of points to add to the points this player already\r\n * \t\thas.\r\n */\r\npublic void addPoints(int points) {\r\n    this.score += points;\r\n}", "docComment": "Adds points to the score of this player.\r\n\r\n@param points\r\n\t\tThe amount of points to add to the points this player already\r\n\t\thas.\r\n", "metaSrc": "source code", "description": "Adds points to the player's score.", "returns": "", "reason": "This method is part of the game logic, updating the player's score based on actions taken.", "howToUse": "Call `addPoints(int)` with the desired number of points to increase the player's score.", "howItWorks": "The method increments the `score` field by the specified amount.", "assertions": {"preConditions": ["points >= 0"], "postConditions": ["this.score == this.score + points"]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setDirection(nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Sets this unit to face the new direction.\r\n *\r\n * @param newDirection\r\n * \t\tThe new direction this unit is facing.\r\n */\r\npublic void setDirection(nl.tudelft.jpacman.board.Direction newDirection) {\r\n    this.direction = newDirection;\r\n}", "docComment": "Sets this unit to face the new direction.\r\n\r\n@param newDirection\r\n\t\tThe new direction this unit is facing.\r\n", "metaSrc": "source code", "description": "Sets the direction for a unit in the game board.", "returns": "", "reason": "This method allows units in the game board to change their movement direction.", "howToUse": "Call this method with a valid Direction object to update the unit's movement direction.", "howItWorks": "The method assigns the newDirection parameter to the instance variable 'direction', which represents the current movement direction of the unit.", "assertions": {"preConditions": ["newDirection is not null"], "postConditions": ["this.direction == newDirection"]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "kind": "method", "sourceText": "/**\r\n * Actual case of player consuming a pellet.\r\n *\r\n * @param player\r\n * \t\tThe player involved in the collision.\r\n * @param pellet\r\n * \t\tThe pellet involved in the collision.\r\n */\r\npublic void playerVersusPellet(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Pellet pellet) {\r\n    this.pointCalculator.consumedAPellet(player, pellet);\r\n    pellet.leaveSquare();\r\n}", "docComment": "Actual case of player consuming a pellet.\r\n\r\n@param player\r\n\t\tThe player involved in the collision.\r\n@param pellet\r\n\t\tThe pellet involved in the collision.\r\n", "metaSrc": "source code", "description": "Updates player points for consuming a pellet and removes the pellet from its square.", "returns": "Void.", "reason": "This method handles the logic for consuming a pellet in the game, updating player points and removing the pellet from its square.", "howToUse": "Call this method with a Player object and a Pellet object to update the game state when a pellet is consumed by a player.", "howItWorks": "The method calls `consumedAPellet` on the point calculator to update the player's points. It then calls `leaveSquare` on the pellet to remove it from its square.", "assertions": {"preConditions": ["A Player object and a Pellet object are provided."], "postConditions": ["The player's points are updated, and the pellet is removed from its square."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft", "labels": ["Container"], "properties": {"simpleName": "tudelft", "qualifiedName": "nl.tudelft", "kind": "package", "metaSrc": "source code", "description": "Manages game logic, including parsing level maps, creating and moving players, handling user input, and providing actions to move players towards specified directions.", "title": "Game Logic Manager", "keywords": ["game", "logic", "management", "level", "maps", "players", "input", "directions"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite", "labels": ["Structure"], "properties": {"docComment": "Visual representation of some object.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Sprite", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite", "kind": "interface", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The Sprite interface in jpacman is responsible for managing and rendering game sprites, providing access to their dimensions, and splitting them into smaller parts.", "keywords": ["game", "sprite", "rendering", "dimensions", "splitting"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Moves the unit into the given direction if possible and handles all\r\n * collisions.\r\n *\r\n * @param unit\r\n * \t\tThe unit to move.\r\n * @param direction\r\n * \t\tThe direction to move the unit in.\r\n */\r\npublic void move(nl.tudelft.jpacman.board.Unit unit, nl.tudelft.jpacman.board.Direction direction) {\r\n    assert unit != null;\r\n    assert direction != null;\r\n    assert unit.hasSquare();\r\n    if (!this.isInProgress()) {\r\n        return;\r\n    }\r\n    synchronized(this.moveLock) {\r\n        unit.setDirection(direction);\r\n        nl.tudelft.jpacman.board.Square location = unit.getSquare();\r\n        nl.tudelft.jpacman.board.Square destination = location.getSquareAt(direction);\r\n        if (destination.isAccessibleTo(unit)) {\r\n            java.util.List<nl.tudelft.jpacman.board.Unit> occupants = destination.getOccupants();\r\n            unit.occupy(destination);\r\n            for (nl.tudelft.jpacman.board.Unit occupant : occupants) {\r\n                this.collisions.collide(unit, occupant);\r\n            }\r\n        }\r\n        this.updateObservers();\r\n    }\r\n}", "docComment": "Moves the unit into the given direction if possible and handles all\r\ncollisions.\r\n\r\n@param unit\r\n\t\tThe unit to move.\r\n@param direction\r\n\t\tThe direction to move the unit in.\r\n", "metaSrc": "source code", "description": "Moves a unit in the game board based on its direction and checks for collisions.", "returns": "", "reason": "This method handles the movement of a Pacman-like game unit on a board, including collision detection and updating observers.", "howToUse": "Call this method with a Unit object and a Direction to move the unit in that direction. Ensure the level is in progress before calling.", "howItWorks": "The method first checks if the unit has a square and if the level is in progress. It then sets the unit's direction, calculates the destination square, and checks if it is accessible. If so, it occupies the destination square, handles collisions with other units, and updates observers.", "assertions": {"preConditions": ["unit != null", "direction != null", "unit.hasSquare()", "this.isInProgress()"], "postConditions": ["The unit has moved to the destination square if it is accessible."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.Action", "labels": ["Structure"], "properties": {"docComment": "An action that can be executed.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Action", "qualifiedName": "nl.tudelft.jpacman.ui.Action", "kind": "interface", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The Action interface in the Pacman game is responsible for handling user actions and updating the game state accordingly. It acts as a controller, directing the flow of actions within the game's UI.", "keywords": ["Action", "Pacman", "Game", "User Interface", "Controller"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "qualifiedName": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "kind": "method", "sourceText": "/**\r\n * Adds key events UP, DOWN, LEFT and RIGHT to a game.\r\n *\r\n * @param builder\r\n * \t\tThe {@link PacManUiBuilder} that will provide the UI.\r\n */\r\nprotected void addSinglePlayerKeys(final nl.tudelft.jpacman.ui.PacManUiBuilder builder) {\r\n    builder.addKey(java.awt.event.KeyEvent.VK_UP, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.NORTH)).addKey(java.awt.event.KeyEvent.VK_DOWN, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.SOUTH)).addKey(java.awt.event.KeyEvent.VK_LEFT, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.WEST)).addKey(java.awt.event.KeyEvent.VK_RIGHT, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.EAST));\r\n}", "docComment": "Adds key events UP, DOWN, LEFT and RIGHT to a game.\r\n\r\n@param builder\r\n\t\tThe {@link PacManUiBuilder} that will provide the UI.\r\n", "metaSrc": "source code", "description": "Adds key bindings for moving a single player in the game board using predefined directions.", "returns": "This method returns the current instance of PacManUiBuilder.", "reason": "The method provides a convenient way to configure key bindings for moving a single player in the game board, allowing users to control the character using arrow keys.", "howToUse": "Call this method with an instance of PacManUiBuilder to add key mappings for moving the player in all four cardinal directions (north, south, west, east).", "howItWorks": "The method uses the `addKey` method of the builder object to map each arrow key to a lambda expression that represents an action to move the player towards the corresponding direction.", "assertions": {"preConditions": ["A valid instance of PacManUiBuilder is provided."], "postConditions": ["The builder object has been updated with key mappings for moving the player in all four cardinal directions."]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The suggested delay between moves.\r\n */\r\nprivate static final long DELAY = 175L;", "visibility": "private", "simpleName": "DELAY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void consumedAPellet(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Pellet pellet) {\r\n    player.addPoints(pellet.getValue());\r\n}", "docComment": "", "metaSrc": "source code", "description": "Adds the point value of a Pellet to the player's score.", "returns": "", "reason": "This method provides a simple and direct way to update the player's score based on the value of the Pellet they have just consumed.", "howToUse": "Call this method with a Player object and a Pellet object as arguments. The Pellet's value will be added to the player's total score.", "howItWorks": "The method retrieves the point value of the Pellet using its `getValue()` method and adds it to the player's current score using the `addPoints(int)` method.", "assertions": {"preConditions": ["A valid Player object is provided.", "A valid Pellet object is provided."], "postConditions": ["The player's score has been updated by adding the Pellet's value."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void collide(nl.tudelft.jpacman.board.Unit mover, nl.tudelft.jpacman.board.Unit movedInto) {\r\n    this.collisions.collide(mover, movedInto);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Handles collision detection between two units in the Pacman game.", "returns": "", "reason": "This method provides a basic collision detection mechanism for the Pacman game, which is essential for handling interactions between different units in the game.", "howToUse": "To use this method, simply call it with two Unit objects as arguments. The first argument represents the unit that is moving into another square, and the second argument represents the unit that is already on that square.", "howItWorks": "The method calls the collide method of the collisions object, which handles the actual collision logic based on the types of units involved.", "assertions": {"preConditions": ["Both mover and movedInto are valid Unit objects."], "postConditions": ["The collision is handled according to the rules defined in the collide method of the collisions object."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getWidth() {\r\n    assert this.currentSprite() != null;\r\n    return this.currentSprite().getWidth();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the width of the current sprite in the animation sequence.", "returns": "The width of the current sprite as an integer.", "reason": "This method provides a straightforward way to access the width of the current sprite, which is essential for rendering and layout purposes in the Pacman game.", "howToUse": "Call this method on an instance of `AnimatedSprite` to get its width.", "howItWorks": "The method first checks if the current sprite is not null. If it's not, it retrieves the width of the current sprite using the `getWidth()` method of the sprite object.", "assertions": {"preConditions": ["this.currentSprite() != null"], "postConditions": ["the returned value is an integer representing the width of the current sprite"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPelletSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The sprite for the\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite getPelletSprite() {\r\n    return this.loadSprite(\"/sprite/pellet.png\");\r\n}", "docComment": "\r\n@return The sprite for the\r\n", "metaSrc": "source code", "description": "Loads a pellet sprite from a resource file, caching it if it doesn't exist in the cache.", "returns": "A new ImageSprite object representing the loaded or cached sprite.", "reason": "The method provides a convenient way to load and manage sprites used in the Pacman game, ensuring that each sprite is only loaded once and reused when needed.", "howToUse": "Call `getPelletSprite()` to retrieve the pellet sprite. This method does not require any setup or configuration.", "howItWorks": "The method calls `loadSprite` with the path to the pellet image file, which loads the image into an ImageSprite object and caches it for future use.", "assertions": {"preConditions": [], "postConditions": ["A new ImageSprite object is returned representing the loaded or cached pellet sprite."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * When the ghosts are not patrolling their home corners, Pinky wants to go\r\n * to the place that is four grid spaces ahead of Pac-Man in the direction\r\n * that Pac-Man is facing. If Pac-Man is facing down, Pinky wants to go to\r\n * the location exactly four spaces below Pac-Man. Moving towards this place\r\n * uses the same logic that Blinky uses to find Pac-Man's exact location.\r\n * Pinky is affected by a targeting bug if Pac-Man is facing up - when he\r\n * moves or faces up, Pinky tries moving towards a point up, and left, four\r\n * spaces.\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    nl.tudelft.jpacman.board.Unit player = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if (player == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert player.hasSquare();\r\n    nl.tudelft.jpacman.board.Square destination = player.squaresAheadOf(nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD);\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), destination, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        return java.util.Optional.ofNullable(path.get(0));\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nWhen the ghosts are not patrolling their home corners, Pinky wants to go\r\nto the place that is four grid spaces ahead of Pac-Man in the direction\r\nthat Pac-Man is facing. If Pac-Man is facing down, Pinky wants to go to\r\nthe location exactly four spaces below Pac-Man. Moving towards this place\r\nuses the same logic that Blinky uses to find Pac-Man's exact location.\r\nPinky is affected by a targeting bug if Pac-Man is facing up - when he\r\nmoves or faces up, Pinky tries moving towards a point up, and left, four\r\nspaces.\r\n</p>\r\n", "metaSrc": "source code", "description": "Calculates the next move for Pinky based on the nearest player's position and finds the shortest path to that player.", "returns": "Optional<Direction>", "reason": "Pinky is a ghost AI in Pacman, and this method determines its next move by finding the nearest player and calculating the shortest path to them.", "howToUse": "Call this method on an instance of Pinky to get the next direction it should move.", "howItWorks": "1. Find the nearest player using Navigation.findNearest().\n2. Calculate the destination square by moving ahead a certain number of squares from the player.\n3. Use Navigation.shortestPath() to find the shortest path from Pinky's current position to the destination.\n4. Return the first direction in the path if it exists.", "assertions": {"preConditions": ["this.hasSquare()", "player != null", "player.hasSquare()"], "postConditions": ["returns an Optional<Direction>"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The image size in pixels.\r\n */\r\nprivate static final int SPRITE_SIZE = 16;", "visibility": "private", "simpleName": "SPRITE_SIZE", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.SOUTH", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * South, or down.\r\n */\r\nSOUTH(0, 1)", "visibility": "public", "simpleName": "SOUTH", "qualifiedName": "nl.tudelft.jpacman.board.Direction.SOUTH", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store containing the ghost sprites.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "Array of sprite frames for the animation."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.moveLock", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The lock that ensures moves are executed sequential.\r\n */\r\nprivate final java.lang.Object moveLock = new java.lang.Object();", "visibility": "private", "simpleName": "moveLock", "qualifiedName": "nl.tudelft.jpacman.level.Level.moveLock", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The graphics context to draw."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "qualifiedName": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "kind": "method", "sourceText": "/**\r\n * Adds an observer that will be notified when the level is won or lost.\r\n *\r\n * @param observer\r\n * \t\tThe observer that will be notified.\r\n */\r\npublic void addObserver(nl.tudelft.jpacman.level.Level.LevelObserver observer) {\r\n    this.observers.add(observer);\r\n}", "docComment": "Adds an observer that will be notified when the level is won or lost.\r\n\r\n@param observer\r\n\t\tThe observer that will be notified.\r\n", "metaSrc": "source code", "description": "Adds an observer to the list of observers for level updates.", "returns": "", "reason": "To allow other parts of the application to be notified when level changes occur.", "howToUse": "Call this method with an instance of LevelObserver to register it for level updates.", "howItWorks": "The observer is added to a list of observers, which are then notified whenever the level changes.", "assertions": {"preConditions": ["observer is not null"], "postConditions": ["observer is in the list of observers"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The desired frame rate interval for the graphics in milliseconds, 40\r\n * being 25 fps.\r\n */\r\nprivate static final int FRAME_INTERVAL = 40;", "visibility": "private", "simpleName": "FRAME_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "nextFrame()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "kind": "method", "sourceText": "/**\r\n * Draws the next frame, i.e. refreshes the scores and game.\r\n */\r\nprivate void nextFrame() {\r\n    this.boardPanel.repaint();\r\n    this.scorePanel.refresh();\r\n}", "docComment": "Draws the next frame, i.e. refreshes the scores and game.\r\n", "metaSrc": "source code", "description": "Updates the score panel to reflect the current state of players in the Pacman game.", "returns": "Void", "reason": "The method is responsible for updating the display of scores and lives in the Pacman game, which is a UI-related task.", "howToUse": "Call this method to refresh the score panel after any changes to player states occur.", "howItWorks": "The method calls `this.boardPanel.repaint()` to update the board's visual representation and `this.scorePanel.refresh()` to update the scores displayed in the score panel.", "assertions": {"preConditions": ["The game is running and the score panel and board panel are properly initialized."], "postConditions": ["The score panel reflects the updated state of players, including their lives and scores."]}, "stereotype": "UI", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit", "labels": ["Structure"], "properties": {"docComment": "A unit that can be placed on a {@link Square}.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Unit", "qualifiedName": "nl.tudelft.jpacman.board.Unit", "kind": "abstract class", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The abstract class is responsible for managing the movement and direction of units in a game board, providing utility methods for determining future positions based on current direction and distance, and handling requests to set directions.", "keywords": ["unit", "movement", "direction", "utility method", "future position"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.image", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Internal image.\r\n */\r\nprivate final java.awt.Image image;", "visibility": "private", "simpleName": "image", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.image", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file containing the sprite image."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "labels": ["Variable"], "properties": {"sourceText": "private static java.lang.Class clazz = null;", "visibility": "private", "simpleName": "clazz", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "start()", "qualifiedName": "nl.tudelft.jpacman.game.Game.start()", "kind": "method", "sourceText": "/**\r\n * Starts or resumes the game.\r\n */\r\npublic void start() {\r\n    synchronized(this.progressLock) {\r\n        if (this.isInProgress()) {\r\n            return;\r\n        }\r\n        if (this.getLevel().isAnyPlayerAlive() && (this.getLevel().remainingPellets() > 0)) {\r\n            this.inProgress = true;\r\n            this.getLevel().addObserver(this);\r\n            this.getLevel().start();\r\n        }\r\n    }\r\n}", "docComment": "Starts or resumes the game.\r\n", "metaSrc": "source code", "description": "Starts the game if it's not already in progress and there are remaining pellets and players alive.", "returns": "", "reason": "Ensures the game starts only when conditions are met, preventing multiple starts.", "howToUse": "Call `start()` on an instance of `Game` to begin the game if it's not already in progress.", "howItWorks": "Checks if the game is in progress and if there are remaining pellets and players alive. If so, sets the game as in progress, adds the current level as an observer, and starts the level.", "assertions": {"preConditions": ["Game is not already in progress", "Level has remaining pellets", "At least one player is alive"], "postConditions": ["Game is set to in progress", "Level is added as an observer", "Level is started"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new collision handler.\r\n *\r\n * @param handler\r\n * \t\tThe symmetric handler for this collision.\r\n */\r\nInverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C2, C1> handler) {\r\n    super();\r\n    this.handler = handler;\r\n}", "docComment": "Creates a new collision handler.\r\n\r\n@param handler\r\n\t\tThe symmetric handler for this collision.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)", "labels": ["Constructor"], "properties": {"visibility": "private", "simpleName": "<init>(int,int)", "qualifiedName": "nl.tudelft.jpacman.board.Direction(int,int)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new Direction with the given parameters.\r\n *\r\n * @param deltaX\r\n * \t\tThe delta x (width difference) to an element in the direction\r\n * \t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n * @param deltaY\r\n * \t\tThe delta y (height difference) to an element in the direction\r\n * \t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n */\r\nDirection(int deltaX, int deltaY) {\r\n    super();\r\n    this.deltaX = deltaX;\r\n    this.deltaY = deltaY;\r\n}", "docComment": "Creates a new Direction with the given parameters.\r\n\r\n@param deltaX\r\n\t\tThe delta x (width difference) to an element in the direction\r\n\t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n@param deltaY\r\n\t\tThe delta y (height difference) to an element in the direction\r\n\t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Create a simple player-based collision map, informing the\r\n * point calculator about points to be added.\r\n *\r\n * @param pointCalculator\r\n * \t\tStrategy for calculating points.\r\n */\r\npublic DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.pointCalculator = pointCalculator;\r\n}", "docComment": "Create a simple player-based collision map, informing the\r\npoint calculator about points to be added.\r\n\r\n@param pointCalculator\r\n\t\tStrategy for calculating points.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getSpriteStore()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The default {@link PacManSprites}.\r\n */\r\nprotected nl.tudelft.jpacman.sprite.PacManSprites getSpriteStore() {\r\n    return nl.tudelft.jpacman.Launcher.SPRITE_STORE;\r\n}", "docComment": "\r\n@return The default {@link PacManSprites}.\r\n", "metaSrc": "source code", "description": "Returns the singleton instance of PacManSprites class.", "returns": "nl.tudelft.jpacman.sprite.PacManSprites", "reason": "The method provides a way to access the shared resource of PacMan sprites used in the game.", "howToUse": "Call this method to get the instance of PacManSprites which can be used for rendering PacMan and other game elements.", "howItWorks": "The method returns the static field SPRITE_STORE, which is a singleton instance of PacManSprites. This ensures that only one instance of PacManSprites is created throughout the application.", "assertions": {"preConditions": [], "postConditions": ["The returned object is an instance of nl.tudelft.jpacman.sprite.PacManSprites."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game", "labels": ["Structure"], "properties": {"docComment": "A basic implementation of a Pac-Man game.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Game", "qualifiedName": "nl.tudelft.jpacman.game.Game", "kind": "abstract class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The abstract class is responsible for managing the game's state, including its progress and observers. It also handles the logic for starting, stopping, and moving players in the game.", "keywords": ["game management", "state management", "observer pattern", "logic handling"], "roleStereotype": "Coordinator"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void collide(nl.tudelft.jpacman.board.Unit mover, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (mover instanceof nl.tudelft.jpacman.level.Player) {\r\n        this.playerColliding(((nl.tudelft.jpacman.level.Player) (mover)), collidedOn);\r\n    } else if (mover instanceof nl.tudelft.jpacman.npc.Ghost) {\r\n        this.ghostColliding(((nl.tudelft.jpacman.npc.Ghost) (mover)), collidedOn);\r\n    } else if (mover instanceof nl.tudelft.jpacman.level.Pellet) {\r\n        this.pelletColliding(((nl.tudelft.jpacman.level.Pellet) (mover)), collidedOn);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Handles collisions between player units (Pellets, Ghosts) and updates game state accordingly.", "returns": "Void.", "reason": "This method manages the interactions between different types of units in the game, updating player points and game state based on collisions.", "howToUse": "Call this method when a collision occurs between a player unit and another unit (Pellet or Ghost) to handle the appropriate actions.", "howItWorks": "The method checks the type of the mover and calls the corresponding collision handling method (`pelletColliding`, `ghostColliding`, or `playerColliding`).", "assertions": {"preConditions": ["mover is an instance of Player, Ghost, or Pellet.", "collidedOn is an instance of Unit."], "postConditions": ["Player points are updated based on the collision type.", "Game state is updated accordingly (e.g., player death for ghosts)."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The collidee (unit that was moved into) type."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base move interval of the ghost.\r\n */\r\nprivate final int moveInterval;", "visibility": "private", "simpleName": "moveInterval", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "deltaY", "qualifiedName": "nl.tudelft.jpacman.board.Direction(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.game", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The game to display.\r\n */\r\nprivate final nl.tudelft.jpacman.game.Game game;", "visibility": "private", "simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.game", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store providing the sprites for the background.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "movedInto", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is already on the square that is being invaded."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The default value of a pellet.\r\n */\r\nprivate static final int PELLET_VALUE = 10;", "visibility": "private", "simpleName": "PELLET_VALUE", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "text", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of strings representing the lines of the map."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.observers", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The objects observing this level.\r\n */\r\nprivate final java.util.Set<nl.tudelft.jpacman.level.Level.LevelObserver> observers;", "visibility": "private", "simpleName": "observers", "qualifiedName": "nl.tudelft.jpacman.level.Level.observers", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator", "labels": ["Structure"], "properties": {"docComment": "The responsibility of the point calculator is to update the points\r\nof the player when certain activities happen.\r\nDifferent calculation strategies can be employed,\r\ngiving rise to different types of games, for example at different levels.\r\n", "simpleName": "PointCalculator", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator", "kind": "interface", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The PointCalculator interface is responsible for managing game points in a Pacman game. It provides methods to update player scores based on collisions with ghosts, consumption of pellets, and successful movements.", "keywords": ["point calculation", "game logic", "player interaction"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "labels": ["Variable"], "properties": {"simpleName": "ghostFactory", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.direction", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The direction this unit is facing.\r\n */\r\nprivate nl.tudelft.jpacman.board.Direction direction;", "visibility": "private", "simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.board.Unit.direction", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "makeGame()", "qualifiedName": "nl.tudelft.jpacman.Launcher.makeGame()", "kind": "method", "sourceText": "/**\r\n * Creates a new game using the level from {@link #makeLevel()}.\r\n *\r\n * @return a new Game.\r\n */\r\npublic nl.tudelft.jpacman.game.Game makeGame() {\r\n    nl.tudelft.jpacman.game.GameFactory gf = this.getGameFactory();\r\n    nl.tudelft.jpacman.level.Level level = this.makeLevel();\r\n    this.game = gf.createSinglePlayerGame(level, this.loadPointCalculator());\r\n    return this.game;\r\n}", "docComment": "Creates a new game using the level from {@link #makeLevel()}.\r\n\r\n@return a new Game.\r\n", "metaSrc": "source code", "description": "Creates a new single-player game instance for a specified level and point calculator.", "returns": "A new SinglePlayerGame instance representing the created game.", "reason": "This method is responsible for initializing and returning a single-player game, which is a fundamental part of the game logic in Pacman.", "howToUse": "To use this method, create an instance of Launcher and call makeGame() on it. This will return a new SinglePlayerGame object that can be used to start playing the game.", "howItWorks": "The method first retrieves a GameFactory using getGameFactory(). It then creates a level using makeLevel(), which parses a text representation of the game map into an actual level. Finally, it uses the GameFactory to create a single-player game instance with the specified level and point calculator, and returns this instance.", "assertions": {"preConditions": ["The Launcher object must be properly initialized."], "postConditions": ["A new SinglePlayerGame instance should be returned."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The size (in pixels) of a square on the board. The initial size of this\r\n * panel will scale to fit a board with square of this size.\r\n */\r\nprivate static final int SQUARE_SIZE = 16;", "visibility": "private", "simpleName": "SQUARE_SIZE", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.levelMap", "labels": ["Variable"], "properties": {"sourceText": "private java.lang.String levelMap = nl.tudelft.jpacman.Launcher.DEFAULT_MAP;", "visibility": "private", "simpleName": "levelMap", "qualifiedName": "nl.tudelft.jpacman.Launcher.levelMap", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(java.util.Map,int,int)", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new ghost.\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for every direction.\r\n * @param moveInterval\r\n * \t\tThe base interval of movement.\r\n * @param intervalVariation\r\n * \t\tThe variation of the interval.\r\n */\r\nprotected Ghost(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap, int moveInterval, int intervalVariation) {\r\n    super();\r\n    this.sprites = spriteMap;\r\n    this.intervalVariation = intervalVariation;\r\n    this.moveInterval = moveInterval;\r\n}", "docComment": "Creates a new ghost.\r\n\r\n@param spriteMap\r\n\t\tThe sprites for every direction.\r\n@param moveInterval\r\n\t\tThe base interval of movement.\r\n@param intervalVariation\r\n\t\tThe variation of the interval.\r\n", "metaSrc": "source code", "description": "Initializes a new Ghost instance with specified sprite map, move interval, and interval variation.", "returns": "A newly created Ghost instance.", "reason": "This method initializes a new Ghost object with its necessary properties, allowing it to be used within the game logic.", "howToUse": "Create a new Ghost instance by providing a sprite map and move interval. Optionally, specify an interval variation for more dynamic movement.", "howItWorks": "The constructor sets up the ghost's initial state by initializing its sprites, move interval, and interval variation based on the provided parameters.", "assertions": {"preConditions": ["spriteMap is not null", "moveInterval is a positive integer", "intervalVariation is a non-negative integer"], "postConditions": ["Ghost instance is created with specified properties", "Ghost's move interval and variation are set correctly"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "build(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "/**\r\n * Creates a new Pac-Man UI with the set keys and buttons.\r\n *\r\n * @param game\r\n * \t\tThe game to build the UI for.\r\n * @return A new Pac-Man UI with the set keys and buttons.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUI build(final nl.tudelft.jpacman.game.Game game) {\r\n    assert game != null;\r\n    if (this.defaultButtons) {\r\n        this.addStartButton(game);\r\n        this.addStopButton(game);\r\n    }\r\n    return new nl.tudelft.jpacman.ui.PacManUI(game, this.buttons, this.keyMappings, this.scoreFormatter);\r\n}", "docComment": "Creates a new Pac-Man UI with the set keys and buttons.\r\n\r\n@param game\r\n\t\tThe game to build the UI for.\r\n@return A new Pac-Man UI with the set keys and buttons.\r\n", "metaSrc": "source code", "description": "Builds a PacMan UI for a given game, adding start and stop buttons if configured.", "returns": "A new instance of nl.tudelft.jpacman.ui.PacManUI.", "reason": "This method is responsible for creating and configuring the user interface for a PacMan game, including adding start and stop buttons if specified.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.game.Game to get a fully configured PacMan UI.", "howItWorks": "The method first checks if the input game is not null. If so, it adds start and stop buttons to the game's user interface based on the `defaultButtons` flag. It then returns a new instance of PacManUI initialized with the provided game, buttons, key mappings, and score formatter.", "assertions": {"preConditions": ["game is not null"], "postConditions": ["a new instance of nl.tudelft.jpacman.ui.PacManUI is returned", "start and stop buttons are added to the game's UI if configured"]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman", "labels": ["Container"], "properties": {"simpleName": "jpacman", "qualifiedName": "nl.tudelft.jpacman", "kind": "package", "metaSrc": "source code", "description": "Manages game logic, including parsing level maps, creating and moving players, handling user input, and providing actions to move players towards specified directions.", "title": "Controller", "keywords": ["game", "logic", "controller"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height) {\r\n    return new nl.tudelft.jpacman.sprite.EmptySprite();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level", "labels": ["Container"], "properties": {"simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.level", "kind": "package", "metaSrc": "source code", "description": "The nl.tudelft.jpacman.level package contains classes and interfaces that manage game levels, player interactions, collision detection, and entity management in a Pac-Man game.", "title": "Game Level Management", "keywords": ["game", "level", "management", "collision", "interaction", "entity"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "loadClassFromFile()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "kind": "method", "sourceText": "private java.lang.Class loadClassFromFile() throws java.io.IOException, java.lang.ClassNotFoundException {\r\n    java.lang.String strategyToLoad = this.getCalculatorClassName();\r\n    if (\"DefaultPointCalculator\".equals(strategyToLoad)) {\r\n        return nl.tudelft.jpacman.points.DefaultPointCalculator.class;\r\n    }\r\n    java.net.URL[] urls = new java.net.URL[]{ this.getClass().getClassLoader().getResource(\"scoreplugins/\") };\r\n    try (java.net.URLClassLoader classLoader = new java.net.URLClassLoader(urls, this.getClass().getClassLoader())) {\r\n        return classLoader.loadClass(strategyToLoad);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Loads a point calculator class from a specified file path or uses a default if not found.", "returns": "The loaded Class object for the point calculator.", "reason": "This method provides flexibility in loading different point calculation strategies by allowing them to be defined in separate files, enhancing modularity and extensibility of the Pacman game.", "howToUse": "Call this method from a class that needs to use a specific point calculator. It will load the class based on the configuration or default strategy.", "howItWorks": "The method first checks if a specific class name is provided in a properties file. If not, it defaults to using 'DefaultPointCalculator'. It then creates a URLClassLoader with the specified resource path and loads the class from there.", "assertions": {"preConditions": ["A valid ClassLoader instance is available.", "The method has access to the necessary resources for loading classes."], "postConditions": ["The returned Class object is correctly loaded and can be used by other parts of the application."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.board", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The grid of squares with board[x][y] being the square at column x, row y.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Square[][] board;", "visibility": "private", "simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.board.Board.board", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game board to render."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "qualifiedName": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "kind": "method", "sourceText": "/**\r\n * Removes an observer if it was listed.\r\n *\r\n * @param observer\r\n * \t\tThe observer to be removed.\r\n */\r\npublic void removeObserver(nl.tudelft.jpacman.level.Level.LevelObserver observer) {\r\n    this.observers.remove(observer);\r\n}", "docComment": "Removes an observer if it was listed.\r\n\r\n@param observer\r\n\t\tThe observer to be removed.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "loadSpriteFromResource(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Loads a sprite from a resource on the class path.\r\n *\r\n * @param resource\r\n * \t\tThe resource path.\r\n * @return A new sprite for the resource.\r\n * @throws IOException\r\n * \t\tWhen the resource could not be loaded.\r\n */\r\n@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\", justification = \"false positive in java 11\")\r\nprivate nl.tudelft.jpacman.sprite.Sprite loadSpriteFromResource(java.lang.String resource) throws java.io.IOException {\r\n    try (java.io.InputStream input = nl.tudelft.jpacman.sprite.SpriteStore.class.getResourceAsStream(resource)) {\r\n        if (input == null) {\r\n            throw new java.io.IOException((\"Unable to load \" + resource) + \", resource does not exist.\");\r\n        }\r\n        java.awt.image.BufferedImage image = javax.imageio.ImageIO.read(input);\r\n        return new nl.tudelft.jpacman.sprite.ImageSprite(image);\r\n    }\r\n}", "docComment": "Loads a sprite from a resource on the class path.\r\n\r\n@param resource\r\n\t\tThe resource path.\r\n@return A new sprite for the resource.\r\n@throws IOException\r\n\t\tWhen the resource could not be loaded.\r\n", "metaSrc": "source code", "description": "Loads a sprite from a resource file and returns an ImageSprite.", "returns": "A new ImageSprite object representing the loaded sprite.", "reason": "This method provides a utility for loading and displaying sprites in the game, which is part of the logic layer where application-specific functionality is implemented.", "howToUse": "Call this method with the path to the resource file containing the sprite image. The method will return an ImageSprite object that can be used to display the sprite in the game.", "howItWorks": "The method uses Java's `getResourceAsStream` to load the sprite image from a specified resource file. It then reads the image using `ImageIO.read`, and finally creates and returns a new `ImageSprite` object with the loaded image.", "assertions": {"preConditions": ["The input string is not null."], "postConditions": ["If the resource exists, an ImageSprite object is returned. If the resource does not exist, an IOException is thrown."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "labels": ["Variable"], "properties": {"sourceText": "private static final int GHOSTS = 4;", "visibility": "private", "simpleName": "GHOSTS", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Used to cycle through the various ghost types.\r\n */\r\nprivate int ghostIndex;", "visibility": "private", "simpleName": "ghostIndex", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "labels": ["Variable"], "properties": {"simpleName": "collisionMap", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getLevel()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getLevel()", "qualifiedName": "nl.tudelft.jpacman.game.Game.getLevel()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The level currently being played.\r\n */\r\npublic abstract nl.tudelft.jpacman.level.Level getLevel();", "docComment": "\r\n@return The level currently being played.\r\n", "metaSrc": "source code", "description": "Returns the current level in the game.", "returns": "The current Level object representing the current state of the game.", "reason": "This method provides access to the current level, which is essential for gameplay and progression through the game.", "howToUse": "To use this method, simply call it on an instance of a Game class. It will return the current level object.", "howItWorks": "The method retrieves the current level from the game's internal state, which is typically managed by the LevelManager or similar component.", "assertions": {"preConditions": [], "postConditions": ["The returned Level object represents the current state of the game."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is colliding."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction in which the player moved."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "labels": ["Variable"], "properties": {"simpleName": "boardFactory", "qualifiedName": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x start coordinate."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "deltaX", "qualifiedName": "nl.tudelft.jpacman.board.Direction(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "kind": "parameter", "parameterPosition": 5, "metaSrc": "source code", "description": "A list of start positions for the game."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "default", "simpleName": "put(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Adds a new occupant to this square.\r\n *\r\n * @param occupant\r\n * \t\tThe unit to occupy this square.\r\n */\r\nvoid put(nl.tudelft.jpacman.board.Unit occupant) {\r\n    assert occupant != null;\r\n    assert !this.occupants.contains(occupant);\r\n    this.occupants.add(occupant);\r\n}", "docComment": "Adds a new occupant to this square.\r\n\r\n@param occupant\r\n\t\tThe unit to occupy this square.\r\n", "metaSrc": "source code", "description": "Adds an occupant to the square, asserting that the occupant is not null and not already present.", "returns": "", "reason": "Ensures that only valid units are placed on squares, maintaining the integrity of the game state.", "howToUse": "Call `put(Unit occupant)` with a non-null Unit object to add it to a Square instance.", "howItWorks": "The method first checks if the occupant is not null and not already in the square's occupants list. It then adds the occupant to the list.", "assertions": {"preConditions": ["occupant != null", "!this.occupants.contains(occupant)"], "postConditions": ["this.occupants.contains(occupant)"]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createBlinky()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "kind": "method", "sourceText": "/**\r\n * Creates a new Blinky / Shadow, the red Ghost.\r\n *\r\n * @see Blinky\r\n * @return A new Blinky.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createBlinky() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Blinky(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.RED));\r\n}", "docComment": "Creates a new Blinky / Shadow, the red Ghost.\r\n\r\n@see Blinky\r\n@return A new Blinky.\r\n", "metaSrc": "source code", "description": "Creates an instance of Blinky, a red ghost in the Pacman game.", "returns": "A new instance of Blinky, a red ghost.", "reason": "The method creates an instance of Blinky by using the provided sprite for the red ghost color.", "howToUse": "Call this method with an array of sprites to create a red Blinky ghost.", "howItWorks": "The method retrieves the animated sprite for the red ghost color from the `sprites` array and uses it to instantiate a new Blinky object.", "assertions": {"preConditions": ["The `sprites` array must not be null or empty."], "postConditions": ["A new instance of Blinky should be returned."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of ghosts."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The 2D array of Square objects representing the game board."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "labels": ["Variable"], "properties": {"simpleName": "loop", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "Whether the animation should loop or not."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory", "labels": ["Structure"], "properties": {"docComment": "Factory that creates Players.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PlayerFactory", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The PlayerFactory class is responsible for creating and managing PacMan players in the game, providing both their visual representation and death animations.", "keywords": ["PlayerFactory", "PacMan", "SpriteFactory", "GameLogic"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getCalculatorClassName()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "kind": "method", "sourceText": "private java.lang.String getCalculatorClassName() throws java.io.IOException {\r\n    java.util.Properties properties = new java.util.Properties();\r\n    properties.load(this.getClass().getClassLoader().getResourceAsStream(\"scorecalc.properties\"));\r\n    return properties.getProperty(\"scorecalculator.name\");\r\n}", "docComment": "", "metaSrc": "source code", "description": "Loads the class name for a point calculator from a properties file.", "returns": "The class name of the point calculator as a string.", "reason": "This method is responsible for loading configuration settings related to scoring in the Pacman game, which falls under the logic layer.", "howToUse": "Call this method to retrieve the class name of the point calculator from the 'scorecalc.properties' file.", "howItWorks": "The method reads a properties file using the class loader and retrieves the value associated with the key 'scorecalculator.name'.", "assertions": {"preConditions": ["The 'scorecalc.properties' file exists in the classpath.", "The file is accessible to the application."], "postConditions": ["The method returns a non-null string representing the class name of the point calculator."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The height of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "labels": ["Variable"], "properties": {"simpleName": "symetric", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "Indicates whether to add an inverse collision handler."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite", "labels": ["Structure"], "properties": {"docComment": "Basic implementation of a Sprite, it merely consists of a static image.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "ImageSprite", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite", "kind": "class", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The class is responsible for managing and rendering images used in the Pacman game, including creating new images, drawing them on a graphics context, splitting images into sub-images, checking if coordinates are within image bounds, and providing information about the image's dimensions.", "keywords": ["Image management", "Pacman game", "image rendering", "sub-image creation", "coordinate validation"], "roleStereotype": "Structurer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "default", "simpleName": "remove(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Removes the unit from this square if it was present.\r\n *\r\n * @param occupant\r\n * \t\tThe unit to be removed from this square.\r\n */\r\nvoid remove(nl.tudelft.jpacman.board.Unit occupant) {\r\n    assert occupant != null;\r\n    this.occupants.remove(occupant);\r\n}", "docComment": "Removes the unit from this square if it was present.\r\n\r\n@param occupant\r\n\t\tThe unit to be removed from this square.\r\n", "metaSrc": "source code", "description": "Removes an occupant from the square's list of occupants.", "returns": "", "reason": "This method provides a way to remove an occupant from a square, which is essential for managing the game state in Pacman.", "howToUse": "Call this method with the unit you want to remove as an argument. For example: `square.remove(unit);`", "howItWorks": "The method first checks if the occupant is not null, then removes it from the square's list of occupants using the `remove` method of the `occupants` collection.", "assertions": {"preConditions": ["occupant != null"], "postConditions": ["occupant is no longer in the square's list of occupants"]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction in which the neighbour is linked."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser", "labels": ["Structure"], "properties": {"docComment": "Creates new {@link Level}s from text representations.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "MapParser", "qualifiedName": "nl.tudelft.jpacman.level.MapParser", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The class is responsible for parsing and representing game maps in various formats, including text files, lists of strings, and character arrays. It handles different methods to convert these inputs into a level object that can be used by other parts of the game.", "keywords": ["parse", "map", "representation", "game", "levels"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "method", "sourceText": "/**\r\n * Adds a collision interaction to this collection.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe collider type.\r\n * @param collidee\r\n * \t\tThe collidee type.\r\n * @param symetric\r\n * \t\t<code>true</code> if this collision is used for both\r\n * \t\tC1 against C2 and vice versa;\r\n * \t\t<code>false</code> if only for C1 against C2.\r\n * @param handler\r\n * \t\tThe handler that handles the collision.\r\n */\r\npublic <C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void onCollision(java.lang.Class<C1> collider, java.lang.Class<C2> collidee, boolean symetric, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2> handler) {\r\n    this.addHandler(collider, collidee, handler);\r\n    if (symetric) {\r\n        this.addHandler(collidee, collider, new nl.tudelft.jpacman.level.CollisionInteractionMap.InverseCollisionHandler<C2, C1>(handler));\r\n    }\r\n}", "docComment": "Adds a collision interaction to this collection.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe collider type.\r\n@param collidee\r\n\t\tThe collidee type.\r\n@param symetric\r\n\t\t<code>true</code> if this collision is used for both\r\n\t\tC1 against C2 and vice versa;\r\n\t\t<code>false</code> if only for C1 against C2.\r\n@param handler\r\n\t\tThe handler that handles the collision.\r\n", "metaSrc": "source code", "description": "Adds collision handlers for a specific pair of units and their inverse if symetric.", "returns": "Void.", "reason": "This method manages collision interactions between units in a game by adding handlers for both direct and inverse collisions based on the symetric flag.", "howToUse": "Call this method with the appropriate unit types, a handler, and whether to add an inverse handler.", "howItWorks": "The method adds a direct collision handler using the provided collider and collidee classes. If symetric is true, it also adds an inverse collision handler that uses the same handler but swaps the collider and collidee types.", "assertions": {"preConditions": ["collider and collidee are valid unit classes", "handler is a valid CollisionHandler instance"], "postConditions": ["collision handlers are added to the collision interaction map"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.getSprite()", "kind": "method", "sourceText": "/**\r\n * Returns the sprite of this unit.\r\n *\r\n * @return The sprite of this unit.\r\n */\r\npublic abstract nl.tudelft.jpacman.sprite.Sprite getSprite();", "docComment": "Returns the sprite of this unit.\r\n\r\n@return The sprite of this unit.\r\n", "metaSrc": "source code", "description": "Returns the sprite representation of the unit.", "returns": "A Sprite object representing the visual appearance of the unit.", "reason": "The method provides a way to access the graphical representation of an abstract unit in the game, which is essential for rendering and displaying units on the game board.", "howToUse": "Call this method on any instance of Unit to retrieve its sprite.", "howItWorks": "The method returns the sprite object associated with the unit. This object contains information about how the unit should be drawn on the screen, such as its image file and position.", "assertions": {"preConditions": [], "postConditions": ["The returned Sprite object is not null."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "labels": ["Variable"], "properties": {"sourceText": "private static final int CLYDE = 3;", "visibility": "private", "simpleName": "CLYDE", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The pellet involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    return java.util.Optional.empty();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "A list of ghosts to be added to the map."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "labels": ["Variable"], "properties": {"simpleName": "key", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The key class to find the most specific ancestor in the map."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Speedy, a.k.a. Pinky.\r\n */\r\nPINK()", "visibility": "public", "simpleName": "PINK", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The graphics context for rendering."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "labels": ["Variable"], "properties": {"simpleName": "points", "qualifiedName": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The number of points awarded for consuming this pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "labels": ["Structure"], "properties": {"docComment": "Handles the collision between two colliding parties.\r\n\r\n@author Michael de Jong\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee type.\r\n", "simpleName": "CollisionHandler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "kind": "interface", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "Handles collisions between units in the Pacman game, managing interactions between game entities.", "keywords": ["collision", "handler", "units", "Pacman", "game"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of frames in the ghost animation.\r\n */\r\nprivate static final int GHOST_ANIMATION_FRAMES = 2;", "visibility": "private", "simpleName": "GHOST_ANIMATION_FRAMES", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getBoardCreator()", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return the BoardCreator\r\n */\r\nprotected nl.tudelft.jpacman.board.BoardFactory getBoardCreator() {\r\n    return this.boardCreator;\r\n}", "docComment": "\r\n@return the BoardCreator\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.score", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of points accumulated by this player.\r\n */\r\nprivate int score;", "visibility": "private", "simpleName": "score", "qualifiedName": "nl.tudelft.jpacman.level.Player.score", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game", "labels": ["Container"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.game", "kind": "package", "metaSrc": "source code", "description": "The package manages the game's state and logic, including player movement and level progression.", "title": "Game Management", "keywords": ["game", "state", "logic", "player", "level"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The desired width of the image."}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.level.PlayerFactory)", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new game factory.\r\n *\r\n * @param playerFactory\r\n * \t\tThe factory providing the player objects.\r\n */\r\npublic GameFactory(nl.tudelft.jpacman.level.PlayerFactory playerFactory) {\r\n    super();\r\n    this.playerFactory = playerFactory;\r\n}", "docComment": "Creates a new game factory.\r\n\r\n@param playerFactory\r\n\t\tThe factory providing the player objects.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "/**\r\n * Actual case of player bumping into ghost or vice versa.\r\n *\r\n * @param player\r\n * \t\tThe player involved in the collision.\r\n * @param ghost\r\n * \t\tThe ghost involved in the collision.\r\n */\r\npublic void playerVersusGhost(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.npc.Ghost ghost) {\r\n    this.pointCalculator.collidedWithAGhost(player, ghost);\r\n    player.setAlive(false);\r\n    player.setKiller(ghost);\r\n}", "docComment": "Actual case of player bumping into ghost or vice versa.\r\n\r\n@param player\r\n\t\tThe player involved in the collision.\r\n@param ghost\r\n\t\tThe ghost involved in the collision.\r\n", "metaSrc": "source code", "description": "Updates player points based on collision with a ghost and sets the player as dead.", "returns": "", "reason": "This method handles the logic for when a player collides with a ghost, updating their points and setting them as dead.", "howToUse": "Call this method when a collision between a player and a ghost occurs.", "howItWorks": "The method first calls `pointCalculator.collidedWithAGhost(player, ghost)` to update the player's points. It then sets the player's alive status to false using `player.setAlive(false)`, which updates their death sprite. Finally, it sets the killer of the player to the ghost using `player.setKiller(ghost).", "assertions": {"preConditions": ["The player and ghost objects are valid."], "postConditions": ["The player's alive status is set to false.", "The player's killer is set to the ghost.", "The player's points are updated based on the collision with the ghost."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "/**\r\n * Renders a single square on the given graphics context on the specified\r\n * rectangle.\r\n *\r\n * @param square\r\n * \t\tThe square to render.\r\n * @param graphics\r\n * \t\tThe graphics context to draw on.\r\n * @param x\r\n * \t\tThe x position to start drawing.\r\n * @param y\r\n * \t\tThe y position to start drawing.\r\n * @param width\r\n * \t\tThe width of this square (in pixels.)\r\n * @param height\r\n * \t\tThe height of this square (in pixels.)\r\n */\r\nprivate void render(nl.tudelft.jpacman.board.Square square, java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    square.getSprite().draw(graphics, x, y, width, height);\r\n    for (nl.tudelft.jpacman.board.Unit unit : square.getOccupants()) {\r\n        unit.getSprite().draw(graphics, x, y, width, height);\r\n    }\r\n}", "docComment": "Renders a single square on the given graphics context on the specified\r\nrectangle.\r\n\r\n@param square\r\n\t\tThe square to render.\r\n@param graphics\r\n\t\tThe graphics context to draw on.\r\n@param x\r\n\t\tThe x position to start drawing.\r\n@param y\r\n\t\tThe y position to start drawing.\r\n@param width\r\n\t\tThe width of this square (in pixels.)\r\n@param height\r\n\t\tThe height of this square (in pixels.)\r\n", "metaSrc": "source code", "description": "Renders the visual representation of a square and its occupants on the game board.", "returns": "Void", "reason": "This method is responsible for rendering the visual representation of a square and its occupants on the game board.", "howToUse": "Call this method with the appropriate parameters to render a specific square and its occupants on the game board.", "howItWorks": "The method first renders the sprite of the square using the `draw` method of the `Sprite` object returned by `getSprite()`. Then, it iterates over the list of units occupying the square using the `getOccupants` method and renders each unit's sprite at the same position on the board.", "assertions": {"preConditions": ["The provided square is not null.", "The provided graphics context is not null.", "The provided x, y, width, and height values are valid."], "postConditions": ["The square's sprite is rendered on the board at the specified position with the given dimensions.", "Each unit occupying the square is also rendered on the board at the same position with the given dimensions."]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Determines whether the unit is allowed to occupy this square.\r\n *\r\n * @param unit\r\n * \t\tThe unit to grant or deny access.\r\n * @return <code>true</code> iff the unit is allowed to occupy this square.\r\n */\r\npublic abstract boolean isAccessibleTo(nl.tudelft.jpacman.board.Unit unit);", "docComment": "Determines whether the unit is allowed to occupy this square.\r\n\r\n@param unit\r\n\t\tThe unit to grant or deny access.\r\n@return <code>true</code> iff the unit is allowed to occupy this square.\r\n", "metaSrc": "source code", "description": "Determines if a given unit can access the square.", "returns": "Boolean indicating whether the unit is accessible to the square.", "reason": "This method provides a way to check accessibility of a square for a specific unit, which is crucial for game logic in Pacman.", "howToUse": "Call this method with an instance of Unit to determine if it can access the current square.", "howItWorks": "The method checks if the unit has any restrictions or conditions that prevent it from accessing the square. This could involve checking for obstacles, power-ups, or other game-specific rules.", "assertions": {"preConditions": ["A valid Unit instance is provided"], "postConditions": ["Returns true if the unit can access the square, false otherwise"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Way to format the score.\r\n */\r\nprivate nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter = null;", "visibility": "private", "simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getPlayers()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPlayers()", "qualifiedName": "nl.tudelft.jpacman.game.Game.getPlayers()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return An immutable list of the participants of this game.\r\n */\r\npublic abstract java.util.List<nl.tudelft.jpacman.level.Player> getPlayers();", "docComment": "\r\n@return An immutable list of the participants of this game.\r\n", "metaSrc": "source code", "description": "Returns a list of players currently playing in the game.", "returns": "A List of Player objects representing the current players in the game.", "reason": "The method provides access to the current players in the game, which is essential for managing and interacting with them during gameplay.", "howToUse": "To use this method, simply call it on an instance of a subclass of Game. It will return a list of Player objects that are currently active in the game.", "howItWorks": "The method retrieves the players from the game's internal state and returns them as a List. This is typically done by accessing a private field or property that holds the list of players.", "assertions": {"preConditions": [], "postConditions": ["The returned list contains all active Player objects in the game."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Clyde\", a.k.a. \"Pokey\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\npublic Clyde(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Clyde\", a.k.a. \"Pokey\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes a new Clyde ghost instance with specified sprite map, move interval, and interval variation.", "returns": "A newly created Clyde ghost instance.", "reason": "This method initializes a new Ghost instance with specific properties required for the Clyde ghost's behavior in the Pacman game.", "howToUse": "To use this method, create an instance of Clyde by passing a sprite map to it. The sprite map should contain sprites for each direction (up, down, left, right) that the Clyde ghost will use.", "howItWorks": "The method calls the superclass constructor with the provided sprite map and sets specific move interval and interval variation values for the Clyde ghost.", "assertions": {"preConditions": ["A valid Map<Direction, Sprite> is provided."], "postConditions": ["A new Clyde ghost instance is created with the specified properties."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "private void pelletColliding(nl.tudelft.jpacman.level.Pellet pellet, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (collidedOn instanceof nl.tudelft.jpacman.level.Player) {\r\n        this.playerVersusPellet(((nl.tudelft.jpacman.level.Player) (collidedOn)), pellet);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Updates player points for consuming a pellet and removes the pellet from its square.", "returns": "Void.", "reason": "This method handles the logic for what happens when a player collides with a pellet, updating the player's score and removing the pellet from the game board.", "howToUse": "Call this method with a Pellet object and a Unit object that represents the player. The method will update the player's score and remove the pellet from its square.", "howItWorks": "The method checks if the collidedOn unit is an instance of Player. If it is, it calls the playerVersusPellet method to handle the specific logic for what happens when a player consumes a pellet.", "assertions": {"preConditions": ["A Pellet object and a Unit object representing the player are provided."], "postConditions": ["The player's score is updated, and the pellet is removed from its square."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y start coordinate."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation ID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "labels": ["Variable"], "properties": {"simpleName": "buttons", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A map of button labels to corresponding actions."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The panel displaying the player scores.\r\n */\r\nprivate final nl.tudelft.jpacman.ui.ScorePanel scorePanel;", "visibility": "private", "simpleName": "scorePanel", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getOccupants()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getOccupants()", "qualifiedName": "nl.tudelft.jpacman.board.Square.getOccupants()", "kind": "method", "sourceText": "/**\r\n * Returns an immutable list of units occupying this square, in the order in\r\n * which they occupied this square (i.e. oldest first.)\r\n *\r\n * @return An immutable list of units occupying this square, in the order in\r\nwhich they occupied this square (i.e. oldest first.)\r\n */\r\npublic java.util.List<nl.tudelft.jpacman.board.Unit> getOccupants() {\r\n    return com.google.common.collect.ImmutableList.copyOf(this.occupants);\r\n}", "docComment": "Returns an immutable list of units occupying this square, in the order in\r\nwhich they occupied this square (i.e. oldest first.)\r\n\r\n@return An immutable list of units occupying this square, in the order in\r\nwhich they occupied this square (i.e. oldest first.)\r\n", "metaSrc": "source code", "description": "Returns an immutable list of units occupying the square.", "returns": "An ImmutableList containing all units on the square.", "reason": "The method provides a read-only view of the occupants, ensuring that the internal state cannot be modified directly.", "howToUse": "Call `getOccupants()` to retrieve a list of units currently occupying the square.", "howItWorks": "The method uses Guava's ImmutableList.copyOf() to create an immutable copy of the private List<nl.tudelft.jpacman.board.Unit> occupants, ensuring that any modifications to this list are not reflected in the returned list.", "preConditions": ["The square has been initialized with units."], "postConditions": ["The returned list is immutable and contains all units currently occupying the square."], "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "labels": ["Variable"], "properties": {"sourceText": "public static final java.lang.String DEFAULT_MAP = \"/board.txt\";", "visibility": "public", "simpleName": "DEFAULT_MAP", "qualifiedName": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "labels": ["Variable"], "properties": {"simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "An optional score formatter for displaying scores."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "labels": ["Variable"], "properties": {"sourceText": "private static final nl.tudelft.jpacman.sprite.PacManSprites SPRITE_STORE = new nl.tudelft.jpacman.sprite.PacManSprites();", "visibility": "private", "simpleName": "SPRITE_STORE", "qualifiedName": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory providing ghosts.\r\n */\r\nprivate final nl.tudelft.jpacman.npc.ghost.GhostFactory ghostFact;", "visibility": "private", "simpleName": "ghostFact", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getSinglePlayer(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "private nl.tudelft.jpacman.level.Player getSinglePlayer(final nl.tudelft.jpacman.game.Game game) {\r\n    java.util.List<nl.tudelft.jpacman.level.Player> players = game.getPlayers();\r\n    if (players.isEmpty()) {\r\n        throw new java.lang.IllegalArgumentException(\"Game has 0 players.\");\r\n    }\r\n    return players.get(0);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the single player from the game if there is exactly one, otherwise throws an IllegalArgumentException.", "returns": "A Player object representing the single player in the game.", "reason": "The method provides a simple way to access the single player in a single-player game, ensuring that only one player is present and handling the case where no players are found.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.game.Game to retrieve the single player.", "howItWorks": "The method retrieves all players from the game using getPlayers() and checks if the list is empty. If it is, an IllegalArgumentException is thrown. Otherwise, it returns the first (and only) player in the list.", "assertions": {"preConditions": ["game is not null"], "postConditions": ["returns a Player object if game has exactly one player"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getKiller()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getKiller()", "qualifiedName": "nl.tudelft.jpacman.level.Player.getKiller()", "kind": "method", "sourceText": "/**\r\n * Returns the unit that caused the death of Pac-Man.\r\n *\r\n * @return <code>Unit</code> iff the player died by collision, otherwise <code>null</code>.\r\n */\r\npublic nl.tudelft.jpacman.board.Unit getKiller() {\r\n    return this.killer;\r\n}", "docComment": "Returns the unit that caused the death of Pac-Man.\r\n\r\n@return <code>Unit</code> iff the player died by collision, otherwise <code>null</code>.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "labels": ["Variable"], "properties": {"simpleName": "observer", "qualifiedName": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The observer to be added."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The height of the sub-image."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The player of this game.\r\n */\r\nprivate final nl.tudelft.jpacman.level.Player player;", "visibility": "private", "simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The width of the grid."}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "kind": "constructor", "sourceText": "/**\r\n * A configuration exception with a direct message.\r\n *\r\n * @param message\r\n * \t\tThe exception message.\r\n */\r\npublic PacmanConfigurationException(java.lang.String message) {\r\n    super(message);\r\n}", "docComment": "A configuration exception with a direct message.\r\n\r\n@param message\r\n\t\tThe exception message.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new ghost factory.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite provider.\r\n */\r\npublic GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n}", "docComment": "Creates a new ghost factory.\r\n\r\n@param spriteStore\r\n\t\tThe sprite provider.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions", "labels": ["Structure"], "properties": {"docComment": "A simple implementation of a collision map for the JPacman player.\r\n<p>\r\nIt uses a number of instanceof checks to implement the multiple dispatch for the \r\ncollisionmap. For more realistic collision maps, this approach will not scale,\r\nand the recommended approach is to use a {@link CollisionInteractionMap}.\r\n\r\n@author Arie van Deursen, 2014\r\n", "simpleName": "PlayerCollisions", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The class is responsible for handling game interactions, specifically managing collisions between players and ghosts, as well as pellets. It updates player points based on these interactions and manages the state of the players.", "keywords": ["game", "interactions", "collisions", "points", "player", "ghost", "pellet"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "kind": "method", "sourceText": "/**\r\n * Adds a square to the grid based on a given character. These\r\n * character come from the map files and describe the type\r\n * of square.\r\n *\r\n * @param grid\r\n * \t\tThe grid of squares with board[x][y] being the\r\n * \t\tsquare at column x, row y.\r\n * @param ghosts\r\n * \t\tList of all ghosts that were added to the map.\r\n * @param startPositions\r\n * \t\tList of all start positions that were added\r\n * \t\tto the map.\r\n * @param x\r\n * \t\tx coordinate of the square.\r\n * @param y\r\n * \t\ty coordinate of the square.\r\n * @param c\r\n * \t\tCharacter describing the square type.\r\n */\r\nprotected void addSquare(nl.tudelft.jpacman.board.Square[][] grid, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions, int x, int y, char c) {\r\n    switch (c) {\r\n        case ' ' :\r\n            grid[x][y] = this.boardCreator.createGround();\r\n            break;\r\n        case '#' :\r\n            grid[x][y] = this.boardCreator.createWall();\r\n            break;\r\n        case '.' :\r\n            nl.tudelft.jpacman.board.Square pelletSquare = this.boardCreator.createGround();\r\n            grid[x][y] = pelletSquare;\r\n            this.levelCreator.createPellet().occupy(pelletSquare);\r\n            break;\r\n        case 'G' :\r\n            nl.tudelft.jpacman.board.Square ghostSquare = this.makeGhostSquare(ghosts, this.levelCreator.createGhost());\r\n            grid[x][y] = ghostSquare;\r\n            break;\r\n        case 'P' :\r\n            nl.tudelft.jpacman.board.Square playerSquare = this.boardCreator.createGround();\r\n            grid[x][y] = playerSquare;\r\n            startPositions.add(playerSquare);\r\n            break;\r\n        default :\r\n            throw new nl.tudelft.jpacman.PacmanConfigurationException(((((\"Invalid character at \" + x) + \",\") + y) + \": \") + c);\r\n    }\r\n}", "docComment": "Adds a square to the grid based on a given character. These\r\ncharacter come from the map files and describe the type\r\nof square.\r\n\r\n@param grid\r\n\t\tThe grid of squares with board[x][y] being the\r\n\t\tsquare at column x, row y.\r\n@param ghosts\r\n\t\tList of all ghosts that were added to the map.\r\n@param startPositions\r\n\t\tList of all start positions that were added\r\n\t\tto the map.\r\n@param x\r\n\t\tx coordinate of the square.\r\n@param y\r\n\t\ty coordinate of the square.\r\n@param c\r\n\t\tCharacter describing the square type.\r\n", "metaSrc": "source code", "description": "Parses a character map into a grid of squares, creating appropriate entities like walls, pellets, and ghosts based on the characters in the map.", "returns": "void", "reason": "This method is responsible for parsing a text-based representation of a game map into a graphical representation using Java objects.", "howToUse": "Call this method with appropriate parameters to populate a game board based on a textual description.", "howItWorks": "The method uses a switch statement to determine the type of square represented by each character in the input string. It creates and places the corresponding object (wall, pellet, ghost, or player) at the specified position in the grid.", "assertions": {"preConditions": ["The grid array must be properly initialized before calling this method."], "postConditions": ["The grid array should contain the correct objects representing the game board based on the input string."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "labels": ["Variable"], "properties": {"simpleName": "event", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "type", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The class type of the unit to find."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "currentLocation", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The starting square from which to search for the nearest unit."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Inky.\r\n</p>\r\n<b>AI:</b> Inky has the most complicated AI of all. Inky considers two things: Blinky's\r\nlocation, and the location two grid spaces ahead of Pac-Man. Inky draws a\r\nline from Blinky to the spot that is two squares in front of Pac-Man and\r\nextends that line twice as far. Therefore, if Inky is alongside Blinky\r\nwhen they are behind Pac-Man, Inky will usually follow Blinky the whole\r\ntime. But if Inky is in front of Pac-Man when Blinky is far behind him,\r\nInky tends to want to move away from Pac-Man (in reality, to a point very\r\nfar ahead of Pac-Man). Inky is affected by a similar targeting bug that\r\naffects Speedy. When Pac-Man is moving or facing up, the spot Inky uses to\r\ndraw the line is two squares above and left of Pac-Man.\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Inky", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The class is responsible for implementing the AI behavior of an Inky ghost in the Pacman game, including initializing its properties, following a path, and calculating the next move based on Blinky's location and the player's position.", "keywords": ["AI", "Pacman", "Ghost", "Pathfinding", "Decision Making"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The level to be used in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.ui", "labels": ["Container"], "properties": {"simpleName": "ui", "qualifiedName": "nl.tudelft.jpacman.ui", "kind": "package", "metaSrc": "source code", "description": "The nl.tudelft.jpacman.ui package contains classes and interfaces that handle user interface components for a Pac-Man game, including panels for displaying the board, score, and buttons, as well as key listeners for handling user input.", "title": "User Interface Components", "keywords": ["user", "interface", "panels", "buttons", "key", "listeners"], "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getScore()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getScore()", "qualifiedName": "nl.tudelft.jpacman.level.Player.getScore()", "kind": "method", "sourceText": "/**\r\n * Returns the amount of points accumulated by this player.\r\n *\r\n * @return The amount of points accumulated by this player.\r\n */\r\npublic int getScore() {\r\n    return this.score;\r\n}", "docComment": "Returns the amount of points accumulated by this player.\r\n\r\n@return The amount of points accumulated by this player.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Shadow, a.k.a. Blinky.\r\n */\r\nRED()", "visibility": "public", "simpleName": "RED", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The width of the destination draw area."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delay between frames.\r\n */\r\nprivate static final int ANIMATION_DELAY = 200;", "visibility": "private", "simpleName": "ANIMATION_DELAY", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The width of the sprite to draw."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "kind": "constructor", "sourceText": "/**\r\n * Creates a new Pac-Man UI builder without any mapped keys or buttons.\r\n */\r\npublic PacManUiBuilder() {\r\n    super();\r\n    this.defaultButtons = false;\r\n    this.buttons = new java.util.LinkedHashMap<java.lang.String, nl.tudelft.jpacman.ui.Action>();\r\n    this.keyMappings = new java.util.HashMap<java.lang.Integer, nl.tudelft.jpacman.ui.Action>();\r\n}", "docComment": "Creates a new Pac-Man UI builder without any mapped keys or buttons.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The pellet consumed by the player."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelLost()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelLost()", "qualifiedName": "nl.tudelft.jpacman.game.Game.levelLost()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void levelLost() {\r\n    this.stop();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Stops the game by pausing it and setting the inProgress flag to false.", "returns": "", "reason": "The method is part of the Game class, which handles the logic of a Pacman game. It stops the game when a level is lost.", "howToUse": "Call `levelLost()` when a level is lost in the game to pause it and stop the current level.", "howItWorks": "The method calls the `stop()` method, which sets the inProgress flag to false and pauses the game.", "assertions": {"preConditions": ["Game is in progress"], "postConditions": ["Game is paused", "InProgress flag is set to false"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The Pellet that is consumed by the player."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The way to calculate points upon collisions in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap", "labels": ["Container", "Structure"], "properties": {"docComment": "A map of possible collisions and their handlers.\r\n\r\n@author Michael de Jong\r\n@author Jeroen Roosen\r\n", "simpleName": "CollisionInteractionMap", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap", "kind": "class", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The class is responsible for managing collision interactions between different types of units in a game. It provides methods to add collision handlers, which are used to define how different unit types interact with each other.", "keywords": ["collision", "interaction", "unit", "handler"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getDirection()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getDirection()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.getDirection()", "kind": "method", "sourceText": "/**\r\n * Returns the current direction this unit is facing.\r\n *\r\n * @return The current direction this unit is facing.\r\n */\r\npublic nl.tudelft.jpacman.board.Direction getDirection() {\r\n    return this.direction;\r\n}", "docComment": "Returns the current direction this unit is facing.\r\n\r\n@return The current direction this unit is facing.\r\n", "metaSrc": "source code", "description": "Returns the current direction of the unit.", "returns": "The current direction of the unit as an instance of nl.tudelft.jpacman.board.Direction.", "reason": "This method provides a simple getter for the direction attribute, which is essential for determining the movement of the unit in the game.", "howToUse": "To use this method, simply call it on an instance of Unit. It will return the current direction of the unit.", "howItWorks": "The method returns the value stored in the 'direction' attribute of the Unit object. This attribute is typically set by other methods that handle user input or game logic.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites", "labels": ["Structure"], "properties": {"docComment": "Sprite Store containing the classic Pac-Man sprites.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacManSprites", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites", "kind": "class", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The class is responsible for managing and providing access to various game sprites, such as walls, walls, and other game elements. It handles loading and caching these sprites efficiently.", "keywords": ["game", "sprites", "loading", "caching"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "service", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Bashful, a.k.a. Inky.\r\n */\r\nCYAN()", "visibility": "public", "simpleName": "CYAN", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getDeltaY()", "qualifiedName": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The delta y (height difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n */\r\npublic int getDeltaY() {\r\n    return this.deltaY;\r\n}", "docComment": "\r\n@return The delta y (height difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n", "metaSrc": "source code", "description": "Returns the y-coordinate change for a given direction.", "returns": "The integer value representing the y-coordinate change.", "reason": "This method provides a way to determine how much the Pacman character should move vertically based on its current direction.", "howToUse": "Call `getDeltaY()` with an instance of `Direction` to get the corresponding y-coordinate change.", "howItWorks": "The method returns the value stored in the `deltaY` field, which is initialized during the creation of each `Direction` enum constant.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new level factory.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite store providing the sprites for units.\r\n * @param ghostFactory\r\n * \t\tThe factory providing ghosts.\r\n * @param pointCalculator\r\n * \t\tThe algorithm to calculate the points.\r\n */\r\npublic LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore, nl.tudelft.jpacman.npc.ghost.GhostFactory ghostFactory, nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n    this.ghostIndex = -1;\r\n    this.ghostFact = ghostFactory;\r\n    this.pointCalculator = pointCalculator;\r\n}", "docComment": "Creates a new level factory.\r\n\r\n@param spriteStore\r\n\t\tThe sprite store providing the sprites for units.\r\n@param ghostFactory\r\n\t\tThe factory providing ghosts.\r\n@param pointCalculator\r\n\t\tThe algorithm to calculate the points.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withMapFile(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Set the name of the file containing this level's map.\r\n *\r\n * @param fileName\r\n * \t\tMap to be used.\r\n * @return Level corresponding to the given map.\r\n */\r\npublic nl.tudelft.jpacman.Launcher withMapFile(java.lang.String fileName) {\r\n    this.levelMap = fileName;\r\n    return this;\r\n}", "docComment": "Set the name of the file containing this level's map.\r\n\r\n@param fileName\r\n\t\tMap to be used.\r\n@return Level corresponding to the given map.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void draw(java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    // nothing to draw.\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "labels": ["Constructor"], "properties": {"visibility": "private", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "kind": "constructor", "sourceText": "GhostColor() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store that provides sprites for units.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The frames of this animation."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.square", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The square this unit is currently occupying.\r\n */\r\nprivate nl.tudelft.jpacman.board.Square square;", "visibility": "private", "simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.board.Unit.square", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A list of ghosts to be placed in the level."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The map of players and the labels their scores are on.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.level.Player, javax.swing.JLabel> scoreLabels;", "visibility": "private", "simpleName": "scoreLabels", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit()", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.board.Unit()", "kind": "constructor", "sourceText": "/**\r\n * Creates a unit that is facing east.\r\n */\r\nprotected Unit() {\r\n    super();\r\n    this.direction = nl.tudelft.jpacman.board.Direction.EAST;\r\n}", "docComment": "Creates a unit that is facing east.\r\n", "metaSrc": "source code", "description": "Initializes a new Unit instance with an east-facing direction.", "returns": "A newly created Unit instance.", "reason": "The method initializes a new Unit object with a default direction of east, which is a common starting point for Pacman-like games.", "howToUse": "Call the constructor to create a new Unit instance.", "howItWorks": "The constructor calls the superclass constructor and sets the initial direction to east.", "assertions": {"preConditions": [], "postConditions": ["A new Unit object is created with an east-facing direction."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "mapName", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The name of the resource containing the map text."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "kind": "method", "sourceText": "private void makeGrid(char[][] map, int width, int height, nl.tudelft.jpacman.board.Square[][] grid, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions) {\r\n    for (int x = 0; x < width; x++) {\r\n        for (int y = 0; y < height; y++) {\r\n            char c = map[x][y];\r\n            this.addSquare(grid, ghosts, startPositions, x, y, c);\r\n        }\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Parses a character map into a grid of squares, creating appropriate entities like walls, pellets, and ghosts based on the characters in the map.", "returns": "Void.", "reason": "The method is responsible for parsing a character map into a grid of squares, creating appropriate entities like walls, pellets, and ghosts based on the characters in the map.", "howToUse": "Call this method with the appropriate parameters to parse a character map into a game board.", "howItWorks": "Iterates over each cell in the map, calls the addSquare method for each cell, and adds the resulting square to the grid.", "assertions": {"preConditions": ["The map array is not null or empty.", "The width and height are positive integers.", "The grid array has dimensions width x height.", "The ghosts list is not null.", "The startPositions list is not null."], "postConditions": ["All squares in the grid have been added based on the characters in the map.", "All ghosts and start positions have been added to their respective lists."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore()", "kind": "constructor", "sourceText": "/**\r\n * Create a new sprite store.\r\n */\r\npublic SpriteStore() {\r\n    super();\r\n    this.spriteMap = new java.util.HashMap<java.lang.String, nl.tudelft.jpacman.sprite.Sprite>();\r\n}", "docComment": "Create a new sprite store.\r\n", "metaSrc": "source code", "description": "Initializes a new instance of SpriteStore by setting up an empty HashMap to store sprite mappings.", "returns": "A newly created instance of SpriteStore with an empty HashMap for storing sprite mappings.", "reason": "The method initializes the SpriteStore class, which is responsible for managing and retrieving sprites used in a Pacman game. It sets up a HashMap to efficiently store and retrieve sprite objects based on their names.", "howToUse": "Create a new instance of SpriteStore by calling its constructor without any parameters.", "howItWorks": "The constructor initializes the superclass (which is likely an abstract class or interface) and creates a new HashMap named 'spriteMap' to store sprite objects. This setup allows for quick access to sprites based on their names.", "assertions": {"preConditions": [], "postConditions": ["A new instance of SpriteStore is created with an empty HashMap."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite()", "kind": "constructor", "sourceText": "EmptySprite() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is colliding."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is colliding with another unit."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation", "labels": ["Container", "Structure"], "properties": {"docComment": "Navigation provides utility to navigate on {@link Square}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Navigation", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The class is responsible for managing pathfinding and movement on a Pacman board, providing methods to calculate shortest paths and determine valid moves.", "keywords": ["pathfinding", "movement", "Pacman", "shortest path", "BFS"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.levelCreator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory that creates the levels.\r\n */\r\nprivate final nl.tudelft.jpacman.level.LevelFactory levelCreator;", "visibility": "private", "simpleName": "levelCreator", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.levelCreator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Clyde.\r\n</p>\r\n<p>\r\nPokey needs a new nickname because out of all the ghosts,\r\nClyde is the least likely to \"C'lyde\" with Pac-Man. Clyde is always the last\r\nghost out of the regenerator, and the loner of the gang, usually off doing\r\nhis own thing when not patrolling the bottom-left corner of the maze. His\r\nbehavior is very random, so while he's not likely to be following you in hot\r\npursuit with the other ghosts, he is a little less predictable, and still a\r\ndanger.\r\n</p>\r\n<p>\r\n<b>AI:</b> Clyde has two basic AIs, one for when he's far from Pac-Man, and\r\none for when he is near to Pac-Man. \r\nWhen Clyde is far away from Pac-Man (beyond eight grid spaces),\r\nClyde behaves very much like Blinky, trying to move to Pac-Man's exact\r\nlocation. However, when Clyde gets within eight grid spaces of Pac-Man, he\r\nautomatically changes his behavior and runs away.\r\n</p>\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Clyde", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The Clyde class is responsible for implementing the AI behavior of the Clyde ghost in the Pacman game, including determining its next move based on the nearest player and managing its shyness level.", "keywords": ["Clyde", "Ghost", "AI", "Pacman", "Shyness", "Move Interval"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "labels": ["Variable"], "properties": {"sourceText": "private static final int BLINKY = 0;", "visibility": "private", "simpleName": "BLINKY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points", "labels": ["Container"], "properties": {"simpleName": "points", "qualifiedName": "nl.tudelft.jpacman.points", "kind": "package", "metaSrc": "source code", "description": "The nl.tudelft.jpacman.points package is responsible for managing game points in a Pacman game, providing various point calculation strategies and loaders.", "title": "Game Point Management", "keywords": ["point", "calculator", "loader", "game", "pacman"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level", "labels": ["Container", "Structure"], "properties": {"docComment": "A level of Pac-Man. A level consists of the board with the players and the\r\nAIs on it.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Level", "qualifiedName": "nl.tudelft.jpacman.level.Level", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The class manages the state and behavior of a game level, including player health, pellets remaining, and notifying observers when the level is lost or won.", "keywords": ["game", "level", "state", "health", "pellets", "observers"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getMapParser()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getMapParser()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new map parser object using the factories from\r\n{@link #getLevelFactory()} and {@link #getBoardFactory()}.\r\n */\r\nprotected nl.tudelft.jpacman.level.MapParser getMapParser() {\r\n    return new nl.tudelft.jpacman.level.MapParser(this.getLevelFactory(), this.getBoardFactory());\r\n}", "docComment": "\r\n@return A new map parser object using the factories from\r\n{@link #getLevelFactory()} and {@link #getBoardFactory()}.\r\n", "metaSrc": "source code", "description": "Returns a MapParser instance initialized with the current LevelFactory and BoardFactory.", "returns": "nl.tudelft.jpacman.level.MapParser", "reason": "The method is responsible for creating a MapParser object that uses the current level factory and board factory to parse map data.", "howToUse": "Call this method from within another class or method that requires a MapParser instance.", "howItWorks": "The method creates a new MapParser object by passing the current LevelFactory and BoardFactory instances as arguments to its constructor.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getDeltaX()", "qualifiedName": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The delta x (width difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n */\r\npublic int getDeltaX() {\r\n    return this.deltaX;\r\n}", "docComment": "\r\n@return The delta x (width difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n", "metaSrc": "source code", "description": "Returns the horizontal delta value associated with the direction.", "returns": "The integer representing the horizontal change in position for the given direction.", "reason": "This method provides a straightforward way to access the horizontal component of a direction, which is essential for movement logic in games like Pacman.", "howToUse": "To use this method, simply call it on an instance of `Direction` enum. For example: `Direction.UP.getDeltaX()` will return -1.", "howItWorks": "The method returns the value stored in the `deltaX` field of the enum constant. This value is typically set during the initialization of each direction enum constant to represent its horizontal change.", "assertions": {"preConditions": [], "postConditions": ["The returned value is an integer representing the horizontal change for the given direction."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The handler of this collision.\r\n */\r\nprivate final nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C2, C1> handler;", "visibility": "private", "simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player to be added to the game."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "this", "qualifiedName": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "labels": ["Variable"], "properties": {"simpleName": "loop", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "Whether the animation should loop continuously."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "main(java.lang.String[])", "qualifiedName": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "kind": "static method", "sourceText": "/**\r\n * Main execution method for the Launcher.\r\n *\r\n * @param args\r\n * \t\tThe command line arguments - which are ignored.\r\n * @throws IOException\r\n * \t\tWhen a resource could not be read.\r\n */\r\npublic static void main(java.lang.String[] args) throws java.io.IOException {\r\n    new nl.tudelft.jpacman.Launcher().launch();\r\n}", "docComment": "Main execution method for the Launcher.\r\n\r\n@param args\r\n\t\tThe command line arguments - which are ignored.\r\n@throws IOException\r\n\t\tWhen a resource could not be read.\r\n", "metaSrc": "source code", "description": "Launches a single-player PacMan game by creating, configuring, and starting the UI.", "returns": "A new instance of nl.tudelft.jpacman.ui.PacManUI", "reason": "The method is responsible for initiating the game's execution, setting up the user interface, and managing the game loop.", "howToUse": "Call the main method with no arguments to start a single-player PacMan game.", "howItWorks": "The method creates an instance of Launcher, which then calls its launch() method. This method sets up the UI components, initializes the game state, and starts the game loop.", "assertions": {"preConditions": [], "postConditions": ["A new instance of nl.tudelft.jpacman.ui.PacManUI is returned."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.progressLock", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Object that locks the start and stop methods.\r\n */\r\nprivate final java.lang.Object progressLock = new java.lang.Object();", "visibility": "private", "simpleName": "progressLock", "qualifiedName": "nl.tudelft.jpacman.game.Game.progressLock", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.inProgress", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> iff this level is currently in progress, i.e. players\r\n * and NPCs can move.\r\n */\r\nprivate boolean inProgress;", "visibility": "private", "simpleName": "inProgress", "qualifiedName": "nl.tudelft.jpacman.level.Level.inProgress", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation()", "labels": ["Constructor"], "properties": {"visibility": "private", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation()", "kind": "constructor", "sourceText": "private Navigation() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.players", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The players on this level.\r\n */\r\nprivate final java.util.List<nl.tudelft.jpacman.level.Player> players;", "visibility": "private", "simpleName": "players", "qualifiedName": "nl.tudelft.jpacman.level.Level.players", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Handles the collision between two colliding parties.\r\n *\r\n * @param collider\r\n * \t\tThe collider.\r\n * @param collidee\r\n * \t\tThe collidee.\r\n */\r\nvoid handleCollision(C1 collider, C2 collidee);", "docComment": "Handles the collision between two colliding parties.\r\n\r\n@param collider\r\n\t\tThe collider.\r\n@param collidee\r\n\t\tThe collidee.\r\n", "metaSrc": "source code", "description": "Handles collisions between units in the Pacman game.", "returns": "", "reason": "To manage interactions between game entities in the Pacman game.", "howToUse": "Call this method when a collision occurs between two units in the game board.", "howItWorks": "Checks if the collider and collidee are valid units, then performs any necessary actions based on their types or properties.", "assertions": {"preConditions": ["collider and collidee must be valid units", "game state is consistent"], "postConditions": ["units may change states or positions due to collision"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.invariant()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "invariant()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.invariant()", "kind": "method", "sourceText": "/**\r\n * Tests whether the square this unit is occupying has this unit listed as\r\n * one of its occupiers.\r\n *\r\n * @return <code>true</code> if the square this unit is occupying has this\r\nunit listed as one of its occupiers, or if this unit is currently\r\nnot occupying any square.\r\n */\r\nprotected boolean invariant() {\r\n    return (this.square == null) || this.square.getOccupants().contains(this);\r\n}", "docComment": "Tests whether the square this unit is occupying has this unit listed as\r\none of its occupiers.\r\n\r\n@return <code>true</code> if the square this unit is occupying has this\r\nunit listed as one of its occupiers, or if this unit is currently\r\nnot occupying any square.\r\n", "metaSrc": "source code", "description": "Checks if the unit is on a square and if that square contains the unit.", "returns": "Boolean indicating whether the unit's square contains the unit.", "reason": "Ensures the integrity of the unit's position on the board.", "howToUse": "Call `invariant()` to verify the state of a unit.", "howItWorks": "Compares the unit's square with its list of occupants and returns true if they match.", "assertions": {"preConditions": ["Unit is not null"], "postConditions": ["Returns true if the unit's square contains the unit, false otherwise."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelWon()", "qualifiedName": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "kind": "method", "sourceText": "/**\r\n * The level has been won. Typically the level should be stopped when\r\n * this event is received.\r\n */\r\nvoid levelWon();", "docComment": "The level has been won. Typically the level should be stopped when\r\nthis event is received.\r\n", "metaSrc": "source code", "description": "Notifies when the level is won in the Pacman game.", "returns": "", "reason": "The method provides an event notification for when a player completes a level in the Pacman game, allowing other components to react accordingly.", "howToUse": "Implement this method in a class that implements `Level$LevelObserver` and register it with the level using the `addLevelObserver(LevelObserver observer)` method.", "howItWorks": "The method is called when the level's conditions for winning are met, typically after all ghosts have been defeated or the player has collected all pellets. It triggers an event that can be handled by other components to update the game state or perform additional actions.", "assertions": {"preConditions": ["The level must be in a state where it is possible to win (all ghosts are defeated, all pellets are collected)."], "postConditions": ["The method should notify any registered observers that the level has been won."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "keyReleased(java.awt.event.KeyEvent)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void keyReleased(java.awt.event.KeyEvent event) {\r\n    // do nothing\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getPlayerFactory()", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "kind": "method", "sourceText": "/**\r\n * Returns the player factory associated with this game factory.\r\n *\r\n * @return The player factory associated with this game factory.\r\n */\r\nprotected nl.tudelft.jpacman.level.PlayerFactory getPlayerFactory() {\r\n    return this.playerFactory;\r\n}", "docComment": "Returns the player factory associated with this game factory.\r\n\r\n@return The player factory associated with this game factory.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "kind": "static method", "sourceText": "private static void addNewTargets(nl.tudelft.jpacman.board.Unit traveller, java.util.List<nl.tudelft.jpacman.npc.ghost.Navigation.Node> targets, java.util.Set<nl.tudelft.jpacman.board.Square> visited, nl.tudelft.jpacman.npc.ghost.Navigation.Node node, nl.tudelft.jpacman.board.Square square) {\r\n    for (nl.tudelft.jpacman.board.Direction direction : nl.tudelft.jpacman.board.Direction.values()) {\r\n        nl.tudelft.jpacman.board.Square target = square.getSquareAt(direction);\r\n        if ((!visited.contains(target)) && ((traveller == null) || target.isAccessibleTo(traveller))) {\r\n            targets.add(new nl.tudelft.jpacman.npc.ghost.Navigation.Node(direction, target, node));\r\n        }\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Adds new targets to the list based on accessible squares in all directions from the given square.", "returns": "void", "reason": "This method is responsible for expanding the navigation path by adding new target squares that are accessible and not visited.", "howToUse": "Call this method with a unit, a list of targets, a set of visited squares, the current node, and the starting square to populate the list of targets.", "howItWorks": "The method iterates over all possible directions from the given square. For each direction, it checks if the resulting square is accessible to the unit (if applicable) and not already visited. If both conditions are met, a new Navigation.Node is created and added to the targets list.", "assertions": {"preConditions": ["traveller should be non-null or null if no specific unit is required for accessibility checks", "targets should be a valid list to store navigation nodes", "visited should be a set to track visited squares", "node should represent the current position in the navigation path", "square should be a valid square object"], "postConditions": ["targets should contain new Navigation.Node objects for accessible, unvisited squares in all directions from the given square"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Static empty sprite to serve as the end of a non-looping sprite.\r\n */\r\nprivate static final nl.tudelft.jpacman.sprite.Sprite END_OF_LOOP = new nl.tudelft.jpacman.sprite.EmptySprite();", "visibility": "private", "simpleName": "END_OF_LOOP", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "labels": ["Variable"], "properties": {"simpleName": "isAnimating", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The new state of animation."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delay between frames.\r\n */\r\nprivate final int animationDelay;", "visibility": "private", "simpleName": "animationDelay", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Handles the collision between two colliding parties, if a suitable\r\n * collision handler is listed.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe collider.\r\n * @param collidee\r\n * \t\tThe collidee.\r\n */\r\n@java.lang.SuppressWarnings(\"unchecked\")\r\n@java.lang.Override\r\npublic <C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void collide(C1 collider, C2 collidee) {\r\n    java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> colliderKey = this.getMostSpecificClass(this.handlers, collider.getClass());\r\n    if (colliderKey == null) {\r\n        return;\r\n    }\r\n    java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>> map = this.handlers.get(colliderKey);\r\n    java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> collideeKey = this.getMostSpecificClass(map, collidee.getClass());\r\n    if (collideeKey == null) {\r\n        return;\r\n    }\r\n    nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2> collisionHandler = ((nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2>) (map.get(collideeKey)));\r\n    if (collisionHandler == null) {\r\n        return;\r\n    }\r\n    collisionHandler.handleCollision(collider, collidee);\r\n}", "docComment": "Handles the collision between two colliding parties, if a suitable\r\ncollision handler is listed.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe collider.\r\n@param collidee\r\n\t\tThe collidee.\r\n", "metaSrc": "source code", "description": "Handles collisions between units in the Pacman game by finding and executing collision handlers based on their specific classes.", "returns": "void", "reason": "This method provides a flexible and extensible way to handle collisions in the Pacman game by allowing different collision handlers for different types of units.", "howToUse": "To use this method, you need to provide two instances of Unit that are colliding. The method will automatically find the appropriate collision handler based on their specific classes.", "howItWorks": "The method first determines the most specific class for each unit in the collision handlers map. It then retrieves the corresponding collision handler from the map and calls its handleCollision method with the two units as arguments.", "assertions": {"preConditions": ["collider and collidee are instances of Unit", "collisionHandlers is a non-null Map"], "postConditions": ["if no suitable collision handler is found, nothing happens"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Parses the provided input stream as a character stream and passes it\r\n * result to {@link #parseMap(List)}.\r\n *\r\n * @param mapName\r\n * \t\tName of a resource that will be read.\r\n * @return The parsed level as represented by the text on the input stream.\r\n * @throws IOException\r\n * \t\twhen the resource could not be read.\r\n */\r\n@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = { \"OBL_UNSATISFIED_OBLIGATION\", \"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\" }, justification = \"try with resources always cleans up / false positive in java 11\")\r\npublic nl.tudelft.jpacman.level.Level parseMap(java.lang.String mapName) throws java.io.IOException {\r\n    try (java.io.InputStream boardStream = nl.tudelft.jpacman.level.MapParser.class.getResourceAsStream(mapName)) {\r\n        if (boardStream == null) {\r\n            throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Could not get resource for: \" + mapName);\r\n        }\r\n        return this.parseMap(boardStream);\r\n    }\r\n}", "docComment": "Parses the provided input stream as a character stream and passes it\r\nresult to {@link #parseMap(List)}.\r\n\r\n@param mapName\r\n\t\tName of a resource that will be read.\r\n@return The parsed level as represented by the text on the input stream.\r\n@throws IOException\r\n\t\twhen the resource could not be read.\r\n", "metaSrc": "source code", "description": "Parses a text representation of a Pacman game map into an actual level by reading lines from an input stream and converting them to a list of strings.", "returns": "An instance of nl.tudelft.jpacman.level.Level representing the parsed level.", "reason": "This method is responsible for loading and parsing a game map from a specified resource, which is a fundamental part of the game's logic layer.", "howToUse": "Call this method with the name of the map file as an argument to load and parse the map. The returned Level object can then be used by other parts of the game to represent the game board.", "howItWorks": "The method uses a try-with-resources statement to open an input stream from the specified resource. If the stream is null, it throws a PacmanConfigurationException indicating that the resource could not be found. Otherwise, it calls the parseMap method with the input stream as an argument and returns the resulting Level object.", "assertions": {"preConditions": ["The mapName parameter must be a valid string representing the name of a resource containing the game map text."], "postConditions": ["The returned Level object should represent the parsed game map correctly."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "intervalVariation", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The variation in milliseconds for the ghost's movement interval."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSquare()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSquare()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.getSquare()", "kind": "method", "sourceText": "/**\r\n * Returns the square this unit is currently occupying.\r\n * Precondition: <code>hasSquare()</code>.\r\n *\r\n * @return The square this unit is currently occupying.\r\n */\r\npublic nl.tudelft.jpacman.board.Square getSquare() {\r\n    assert this.invariant();\r\n    assert this.square != null;\r\n    return this.square;\r\n}", "docComment": "Returns the square this unit is currently occupying.\r\nPrecondition: <code>hasSquare()</code>.\r\n\r\n@return The square this unit is currently occupying.\r\n", "metaSrc": "source code", "description": "Returns the square on which the unit is currently located.", "returns": "The Square object representing the current location of the Unit.", "reason": "This method provides a straightforward way to access the current position of a Pacman-like game unit, ensuring that the unit's state is consistent and valid before returning its square.", "howToUse": "Call this method on an instance of a Unit subclass to retrieve its current location.", "howItWorks": "The method first checks if the unit's invariant holds (i.e., it is on a square and that square contains the unit) using the `invariant()` method. It then returns the `square` field, which stores the current position of the unit.", "assertions": {"preConditions": ["this.invariant() must return true", "this.square must not be null"], "postConditions": ["the returned Square object is valid and represents the current location of the Unit"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addStopButton(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "/**\r\n * Adds a button with the caption {@value #STOP_CAPTION} that stops the\r\n * game.\r\n *\r\n * @param game\r\n * \t\tThe game to stop.\r\n */\r\nprivate void addStopButton(final nl.tudelft.jpacman.game.Game game) {\r\n    assert game != null;\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION, game::stop);\r\n}", "docComment": "Adds a button with the caption {@value #STOP_CAPTION} that stops the\r\ngame.\r\n\r\n@param game\r\n\t\tThe game to stop.\r\n", "metaSrc": "source code", "description": "Adds a stop button to the game UI that stops the game when clicked.", "returns": "", "reason": "This method provides a user interface element for stopping the game, enhancing the usability of the PacMan game.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.game.Game to add a stop button to the UI.", "howItWorks": "The method adds a button to the UI that, when clicked, calls the stop() method on the provided game instance.", "assertions": {"preConditions": ["game is not null"], "postConditions": []}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel", "labels": ["Structure"], "properties": {"docComment": "Panel displaying a game.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "BoardPanel", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The BoardPanel class is responsible for rendering and managing the game board in the Pacman game. It initializes the panel with the game, updates the display when the game state changes, and renders each square and its occupants on the screen.", "keywords": ["render", "game board", "Pacman", "board panel"], "roleStereotype": "User Interfacer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "update()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "kind": "method", "sourceText": "/**\r\n * Updates the current frame index depending on the current system time.\r\n */\r\nprivate void update() {\r\n    long now = java.lang.System.currentTimeMillis();\r\n    if (this.animating) {\r\n        while (this.lastUpdate < now) {\r\n            this.lastUpdate += this.animationDelay;\r\n            this.current++;\r\n            if (this.looping) {\r\n                this.current %= this.animationFrames.length;\r\n            } else if (this.current == this.animationFrames.length) {\r\n                this.animating = false;\r\n            }\r\n        } \r\n    } else {\r\n        this.lastUpdate = now;\r\n    }\r\n}", "docComment": "Updates the current frame index depending on the current system time.\r\n", "metaSrc": "source code", "description": "Updates the animation state of an animated sprite by advancing to the next frame if the current time exceeds the last update time plus the animation delay.", "returns": "", "reason": "The method manages the animation loop for an animated sprite, ensuring that it updates its appearance at regular intervals based on the animation delay.", "howToUse": "Call this method to update the animation of an animated sprite. It should be called periodically in a game loop.", "howItWorks": "The method checks if the sprite is animating and then enters a loop where it increments the current frame index by the animation delay until the current time exceeds the last update time. If the sprite loops, it wraps around to the first frame; otherwise, it stops animating when all frames are shown.", "assertions": {"preConditions": ["The method is called with an instance of AnimatedSprite.", "The animationDelay and animationFrames fields are initialized correctly."], "postConditions": ["The current frame index of the sprite is updated to the next frame if the time condition is met.", "If the sprite loops, it wraps around to the first frame; otherwise, it stops animating."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "labels": ["Variable"], "properties": {"simpleName": "parent", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with by the collider."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The level of this game.\r\n */\r\nprivate final nl.tudelft.jpacman.level.Level level;", "visibility": "private", "simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.killer", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * {@link Unit} iff this player died by collision, <code>null</code> otherwise.\r\n */\r\nprivate nl.tudelft.jpacman.board.Unit killer;", "visibility": "private", "simpleName": "killer", "qualifiedName": "nl.tudelft.jpacman.level.Player.killer", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The 2D array representing the game board."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The random variation added to the {@link #moveInterval}.\r\n */\r\nprivate final int intervalVariation;", "visibility": "private", "simpleName": "intervalVariation", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Inky\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\npublic Inky(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Inky\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes an Inky ghost with a specified sprite map, move interval, and interval variation.", "returns": "A newly created Inky ghost instance.", "reason": "This method initializes a new Ghost instance with the specified parameters, which is essential for creating and configuring an Inky ghost in the Pacman game.", "howToUse": "To use this method, you need to provide a sprite map that defines the sprites for each direction of movement. This setup is crucial for rendering the Inky ghost correctly on the game board.", "howItWorks": "The method calls the superclass constructor with the provided sprite map and sets the move interval and interval variation for the Inky ghost. This ensures that the ghost's behavior, such as its speed and pathfinding, is properly configured.", "assertions": {"preConditions": ["A valid sprite map must be provided."], "postConditions": ["An Inky ghost instance is created with the specified properties."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "fileName", "qualifiedName": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startNPCs()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "startNPCs()", "qualifiedName": "nl.tudelft.jpacman.level.Level.startNPCs()", "kind": "method", "sourceText": "/**\r\n * Starts all NPC movement scheduling.\r\n */\r\nprivate void startNPCs() {\r\n    for (final nl.tudelft.jpacman.npc.Ghost npc : this.npcs.keySet()) {\r\n        java.util.concurrent.ScheduledExecutorService service = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\r\n        service.schedule(new nl.tudelft.jpacman.level.Level.NpcMoveTask(service, npc), npc.getInterval() / 2, java.util.concurrent.TimeUnit.MILLISECONDS);\r\n        this.npcs.put(npc, service);\r\n    }\r\n}", "docComment": "Starts all NPC movement scheduling.\r\n", "metaSrc": "source code", "description": "Starts scheduled tasks for ghost movement in the game level.", "returns": "None", "reason": "The method initializes and schedules tasks to move ghosts at regular intervals, enhancing the game's dynamic behavior.", "howToUse": "Call this method after initializing the level to start ghost movement.", "howItWorks": "For each ghost in the level, a single-threaded scheduled executor service is created. A task is scheduled to run every half of the ghost's interval, which includes its moveInterval and a random variation. The task moves the ghost and schedules itself again after the interval. This setup ensures that ghosts move continuously without blocking the main game loop.", "assertions": {"preConditions": ["The level has been initialized with at least one ghost."], "postConditions": ["All scheduled tasks for ghost movement are active."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "occupant", "qualifiedName": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit to be removed from the square."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "loadSprite(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Overloads the default sprite loading, ignoring the exception. This class\r\n * assumes all sprites are provided, hence the exception will be thrown as a\r\n * {@link RuntimeException}.\r\n *\r\n * {@inheritDoc }\r\n */\r\n@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite loadSprite(java.lang.String resource) {\r\n    try {\r\n        return super.loadSprite(resource);\r\n    } catch (java.io.IOException e) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Unable to load sprite: \" + resource, e);\r\n    }\r\n}", "docComment": "Overloads the default sprite loading, ignoring the exception. This class\r\nassumes all sprites are provided, hence the exception will be thrown as a\r\n{@link RuntimeException}.\r\n\r\n{@inheritDoc }\r\n", "metaSrc": "source code", "description": "Loads a sprite from a resource file, caching it if it doesn't exist in the cache.", "returns": "A new ImageSprite object representing the loaded or cached sprite.", "reason": "This method provides a robust way to load and cache sprites, ensuring that each sprite is only loaded once and efficiently retrieved in subsequent requests.", "howToUse": "Call this method with the path to the resource file containing the sprite you want to load. The method will return an ImageSprite object representing the loaded or cached sprite.", "howItWorks": "The method attempts to load the sprite using the `super.loadSprite(resource)` call. If the sprite is not found in the cache, it throws a `PacmanConfigurationException` with a descriptive error message and the original exception as the cause.", "assertions": {"preConditions": ["The resource path provided must be valid and accessible."], "postConditions": ["If the sprite is successfully loaded or retrieved from the cache, it will be returned as an ImageSprite object. If the sprite cannot be loaded, a `PacmanConfigurationException` will be thrown with a descriptive error message."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "launch()", "qualifiedName": "nl.tudelft.jpacman.Launcher.launch()", "kind": "method", "sourceText": "/**\r\n * Creates and starts a JPac-Man game.\r\n */\r\npublic void launch() {\r\n    this.makeGame();\r\n    nl.tudelft.jpacman.ui.PacManUiBuilder builder = new nl.tudelft.jpacman.ui.PacManUiBuilder().withDefaultButtons();\r\n    this.addSinglePlayerKeys(builder);\r\n    this.pacManUI = builder.build(this.getGame());\r\n    this.pacManUI.start();\r\n}", "docComment": "Creates and starts a JPac-Man game.\r\n", "metaSrc": "source code", "description": "Launches a single-player PacMan game by creating, configuring, and starting the UI.", "returns": "A new instance of nl.tudelft.jpacman.ui.PacManUI", "reason": "The method orchestrates the entire process of launching a PacMan game, from setting up the game to initializing and starting the user interface.", "howToUse": "Call `launch()` on an instance of `nl.tudelft.jpacman.Launcher` to start the game.", "howItWorks": "The method creates a new single-player game using `makeGame()`, configures the UI with default buttons and key bindings, builds the UI using `build()`, and starts the game by setting visibility and scheduling frame updates.", "assertions": {"preConditions": ["An instance of nl.tudelft.jpacman.Launcher is created"], "postConditions": ["A new instance of nl.tudelft.jpacman.ui.PacManUI is returned"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "text", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of strings representing the rows of the map."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.board.Board.getHeight()", "kind": "method", "sourceText": "/**\r\n * Returns the number of rows.\r\n *\r\n * @return The height of this board.\r\n */\r\npublic int getHeight() {\r\n    return this.board[0].length;\r\n}", "docComment": "Returns the number of rows.\r\n\r\n@return The height of this board.\r\n", "metaSrc": "source code", "description": "Returns the height of the board, which is the number of rows in the board array.", "returns": "The height of the board as an integer.", "reason": "This method provides a simple way to access the height of the game board, which is essential for determining the layout and boundaries of the game entities.", "howToUse": "To use this method, simply call it on an instance of the Board class. It will return the number of rows in the board array.", "howItWorks": "The method accesses the first row of the board array (this.board[0]) and returns its length, which represents the height of the board.", "assertions": {"preConditions": [], "postConditions": ["The returned value is an integer representing the number of rows in the board."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "makeLevel()", "qualifiedName": "nl.tudelft.jpacman.Launcher.makeLevel()", "kind": "method", "sourceText": "/**\r\n * Creates a new level. By default this method will use the map parser to\r\n * parse the default board stored in the <code>board.txt</code> resource.\r\n *\r\n * @return A new level.\r\n */\r\npublic nl.tudelft.jpacman.level.Level makeLevel() {\r\n    try {\r\n        return this.getMapParser().parseMap(this.getLevelMap());\r\n    } catch (java.io.IOException e) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Unable to create level, name = \" + this.getLevelMap(), e);\r\n    }\r\n}", "docComment": "Creates a new level. By default this method will use the map parser to\r\nparse the default board stored in the <code>board.txt</code> resource.\r\n\r\n@return A new level.\r\n", "metaSrc": "source code", "description": "Parses a text representation of a Pacman game map into an actual level.", "returns": "An instance of nl.tudelft.jpacman.level.Level representing the parsed level.", "reason": "The method is responsible for creating and initializing the game level based on a textual description provided in the level map file.", "howToUse": "Call this method to load and parse the level from the specified file. Ensure that the level map file exists and is accessible.", "howItWorks": "The method uses the `MapParser` to read the level map from the file, parses it into a list of strings representing each row of the level, and then creates an instance of `Level` using these parsed data.", "assertions": {"preConditions": ["The level map file exists and is accessible.", "The MapParser is properly initialized with the necessary factories."], "postConditions": ["A valid Level object is returned representing the parsed game level."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "double", "labels": ["Primitive"], "properties": {"simpleName": "double", "qualifiedName": "double", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Pokey, a.k.a. Clyde.\r\n */\r\nORANGE()", "visibility": "public", "simpleName": "ORANGE", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.Square.getSprite()", "kind": "method", "sourceText": "/**\r\n * Returns the sprite of this square.\r\n *\r\n * @return The sprite of this square.\r\n */\r\npublic abstract nl.tudelft.jpacman.sprite.Sprite getSprite();", "docComment": "Returns the sprite of this square.\r\n\r\n@return The sprite of this square.\r\n", "metaSrc": "source code", "description": "Returns the sprite associated with the square.", "returns": "A Sprite object representing the visual representation of the square.", "reason": "The method provides a way to access and retrieve the graphical representation of each square in the game board, which is essential for rendering the game's visual elements.", "howToUse": "To use this method, simply call it on an instance of Square. It will return the corresponding Sprite object that can be used to draw the square on the game board.", "howItWorks": "The method returns a Sprite object by calling a private helper method called getSpriteImpl(). This helper method is responsible for creating and returning the appropriate sprite based on the current state of the square, such as whether it contains an entity or not.", "assertions": {"preConditions": [], "postConditions": ["The returned Sprite object should be non-null."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "target", "qualifiedName": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The square to which the unit will occupy."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquares", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The squares from which players can start this game.\r\n */\r\nprivate final java.util.List<nl.tudelft.jpacman.board.Square> startSquares;", "visibility": "private", "simpleName": "startSquares", "qualifiedName": "nl.tudelft.jpacman.level.Level.startSquares", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getWidth() {\r\n    return 0;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player object to be registered."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new wall square.\r\n *\r\n * @param sprite\r\n * \t\tThe background for the square.\r\n */\r\nWall(nl.tudelft.jpacman.sprite.Sprite sprite) {\r\n    super();\r\n    this.background = sprite;\r\n}", "docComment": "Creates a new wall square.\r\n\r\n@param sprite\r\n\t\tThe background for the square.\r\n", "metaSrc": "source code", "description": "Initializes a new Wall object by setting its background sprite.", "returns": "A newly created instance of Wall with the specified background sprite.", "reason": "This method is part of the logic layer as it initializes a new object and sets its properties based on input parameters.", "howToUse": "Create a new Wall object by passing a Sprite to the constructor.", "howItWorks": "The constructor calls the superclass constructor, then sets the background sprite for the wall.", "assertions": {"preConditions": ["A valid Sprite object is provided as input."], "postConditions": ["A new Wall object with the specified background sprite is created."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The height of the grid."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The collider type."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "kind": "method", "sourceText": "/**\r\n * Returns the width of this sprite.\r\n *\r\n * @return The width in pixels.\r\n */\r\nint getWidth();", "docComment": "Returns the width of this sprite.\r\n\r\n@return The width in pixels.\r\n", "metaSrc": "source code", "description": "Returns the width of the sprite in pixels.", "returns": "The width of the sprite as an integer.", "reason": "Provides a way to access the visual dimensions of the sprite, which is essential for rendering and layout purposes.", "howToUse": "Call getWidth() on any instance of Sprite to retrieve its width in pixels.", "howItWorks": "The method returns the value stored in the sprite's internal state, typically set during initialization or when the sprite's dimensions are updated.", "assertions": {"preConditions": [], "postConditions": ["The returned value is an integer representing the width of the sprite."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The Graphics object to draw the sprite onto."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The width of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "kind": "method", "sourceText": "/**\r\n * Creates a new {@link AnimatedSprite} from a base image.\r\n *\r\n * @param baseImage\r\n * \t\tThe base image to convert into an animation.\r\n * @param frames\r\n * \t\tThe amount of frames of the animation.\r\n * @param delay\r\n * \t\tThe delay between frames.\r\n * @param loop\r\n * \t\tWhether this sprite is a looping animation or not.\r\n * @return The animated sprite.\r\n */\r\npublic nl.tudelft.jpacman.sprite.AnimatedSprite createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite baseImage, int frames, int delay, boolean loop) {\r\n    assert baseImage != null;\r\n    assert frames > 0;\r\n    int frameWidth = baseImage.getWidth() / frames;\r\n    nl.tudelft.jpacman.sprite.Sprite[] animation = new nl.tudelft.jpacman.sprite.Sprite[frames];\r\n    for (int i = 0; i < frames; i++) {\r\n        animation[i] = baseImage.split(i * frameWidth, 0, frameWidth, baseImage.getHeight());\r\n    }\r\n    return new nl.tudelft.jpacman.sprite.AnimatedSprite(animation, delay, loop);\r\n}", "docComment": "Creates a new {@link AnimatedSprite} from a base image.\r\n\r\n@param baseImage\r\n\t\tThe base image to convert into an animation.\r\n@param frames\r\n\t\tThe amount of frames of the animation.\r\n@param delay\r\n\t\tThe delay between frames.\r\n@param loop\r\n\t\tWhether this sprite is a looping animation or not.\r\n@return The animated sprite.\r\n", "metaSrc": "source code", "description": "Creates an animated sprite by splitting the base image into multiple frames and returning an AnimatedSprite object.", "returns": "A new AnimatedSprite object.", "reason": "This method provides a way to create an animated sprite by splitting a base image into multiple frames and returning an AnimatedSprite object, which is used in the game logic for animations.", "howToUse": "Call this method with the base image, number of frames, delay, and loop flag to create an animated sprite.", "howItWorks": "The method first checks if the base image is not null and if the number of frames is greater than zero. It then calculates the width of each frame by dividing the base image's width by the number of frames. The method splits the base image into multiple smaller sprites based on these dimensions and returns an AnimatedSprite object with the animation, delay, and loop flag.", "assertions": {"preConditions": ["baseImage != null", "frames > 0"], "postConditions": ["returns a new AnimatedSprite object"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The x-coordinate of the current position in the map."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.dispose()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "dispose()", "qualifiedName": "nl.tudelft.jpacman.Launcher.dispose()", "kind": "method", "sourceText": "/**\r\n * Disposes of the UI. For more information see\r\n * {@link javax.swing.JFrame#dispose()}.\r\n *\r\n * Precondition: The game was launched first.\r\n */\r\npublic void dispose() {\r\n    assert this.pacManUI != null;\r\n    this.pacManUI.dispose();\r\n}", "docComment": "Disposes of the UI. For more information see\r\n{@link javax.swing.JFrame#dispose()}.\r\n\r\nPrecondition: The game was launched first.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "labels": ["Variable"], "properties": {"simpleName": "amountToLookAhead", "qualifiedName": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The number of squares to look ahead."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "kind": "constructor", "sourceText": "DefaultPointCalculator() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "labels": ["Variable"], "properties": {"simpleName": "points", "qualifiedName": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The number of points to add."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "stop()", "qualifiedName": "nl.tudelft.jpacman.game.Game.stop()", "kind": "method", "sourceText": "/**\r\n * Pauses the game.\r\n */\r\npublic void stop() {\r\n    synchronized(this.progressLock) {\r\n        if (!this.isInProgress()) {\r\n            return;\r\n        }\r\n        this.inProgress = false;\r\n        this.getLevel().stop();\r\n    }\r\n}", "docComment": "Pauses the game.\r\n", "metaSrc": "source code", "description": "Stops the game by setting the inProgress flag to false and stopping the current level.", "returns": "", "reason": "The method is responsible for stopping the game, which involves pausing all NPCs and resetting the level's progress.", "howToUse": "Call the stop() method on an instance of Game to stop the game.", "howItWorks": "The method synchronizes access to the progressLock to ensure thread safety. It checks if the game is in progress, sets the inProgress flag to false, and calls the stop() method on the current level.", "assertions": {"preConditions": ["Game is currently in progress"], "postConditions": ["Game is no longer in progress", "Level's progress is set to false"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "labels": ["Variable"], "properties": {"simpleName": "playerFactory", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc", "labels": ["Container"], "properties": {"simpleName": "npc", "qualifiedName": "nl.tudelft.jpacman.npc", "kind": "package", "metaSrc": "source code", "description": "The package manages navigation, pathfinding, and AI behavior for ghosts in a Pac-Man game.", "title": "Ghost Navigation", "keywords": ["ghost", "navigation", "pathfinding", "AI"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A list to store starting positions for players."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The ghost object that collided with the player."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The x-coordinate of the top-left corner of the square on the board."}}}, {"data": {"id": "nl.tudelft.jpacman.board", "labels": ["Container"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.board", "kind": "package", "metaSrc": "source code", "description": "The nl.tudelft.jpacman.board package is responsible for managing the game board, including its dimensions, squares, and boundaries. It provides methods to initialize the board, retrieve square information, check bounds, and ensure the integrity of the board's state.", "title": "Game Board Management", "keywords": ["game", "board", "management", "squares", "directions"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The number of frames for each animation."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new level for the board.\r\n *\r\n * @param board\r\n * \t\tThe board for the level.\r\n * @param ghosts\r\n * \t\tThe ghosts on the board.\r\n * @param startPositions\r\n * \t\tThe squares on which players start on this board.\r\n * @param collisionMap\r\n * \t\tThe collection of collisions that should be handled.\r\n */\r\npublic Level(nl.tudelft.jpacman.board.Board board, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions, nl.tudelft.jpacman.level.CollisionMap collisionMap) {\r\n    super();\r\n    assert board != null;\r\n    assert ghosts != null;\r\n    assert startPositions != null;\r\n    this.board = board;\r\n    this.inProgress = false;\r\n    this.npcs = new java.util.HashMap<nl.tudelft.jpacman.npc.Ghost, java.util.concurrent.ScheduledExecutorService>();\r\n    for (nl.tudelft.jpacman.npc.Ghost ghost : ghosts) {\r\n        this.npcs.put(ghost, null);\r\n    }\r\n    this.startSquares = startPositions;\r\n    this.startSquareIndex = 0;\r\n    this.players = new java.util.ArrayList<nl.tudelft.jpacman.level.Player>();\r\n    this.collisions = collisionMap;\r\n    this.observers = new java.util.HashSet<nl.tudelft.jpacman.level.Level.LevelObserver>();\r\n}", "docComment": "Creates a new level for the board.\r\n\r\n@param board\r\n\t\tThe board for the level.\r\n@param ghosts\r\n\t\tThe ghosts on the board.\r\n@param startPositions\r\n\t\tThe squares on which players start on this board.\r\n@param collisionMap\r\n\t\tThe collection of collisions that should be handled.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "kind": "parameter", "parameterPosition": 5, "metaSrc": "source code", "description": "The height of the square to render."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The desired height of the image."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startStopLock", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The lock that ensures starting and stopping can't interfere with each\r\n * other.\r\n */\r\nprivate final java.lang.Object startStopLock = new java.lang.Object();", "visibility": "private", "simpleName": "startStopLock", "qualifiedName": "nl.tudelft.jpacman.level.Level.startStopLock", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "moveInterval", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The base interval in milliseconds for the ghost's movement."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Map of key events and their actions.\r\n */\r\nprivate final java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> keyMappings;", "visibility": "private", "simpleName": "keyMappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game instance to which the start button will be added."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The type of the collidee unit."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "remainingPellets()", "qualifiedName": "nl.tudelft.jpacman.level.Level.remainingPellets()", "kind": "method", "sourceText": "/**\r\n * Counts the pellets remaining on the board.\r\n *\r\n * @return The amount of pellets remaining on the board.\r\n */\r\npublic int remainingPellets() {\r\n    nl.tudelft.jpacman.board.Board board = this.getBoard();\r\n    int pellets = 0;\r\n    for (int x = 0; x < board.getWidth(); x++) {\r\n        for (int y = 0; y < board.getHeight(); y++) {\r\n            for (nl.tudelft.jpacman.board.Unit unit : board.squareAt(x, y).getOccupants()) {\r\n                if (unit instanceof nl.tudelft.jpacman.level.Pellet) {\r\n                    pellets++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    assert pellets >= 0;\r\n    return pellets;\r\n}", "docComment": "Counts the pellets remaining on the board.\r\n\r\n@return The amount of pellets remaining on the board.\r\n", "metaSrc": "source code", "description": "Returns the total number of pellets remaining on the game board.", "returns": "The total number of pellets as an integer.", "reason": "This method calculates the total number of pellets present in the game board, which is essential for determining the game's progression and end condition.", "howToUse": "Call this method to get the current count of pellets on the board.", "howItWorks": "The method iterates over each square on the board, checks if it contains a pellet, and increments a counter for each pellet found. The final count is returned as the result.", "assertions": {"preConditions": [], "postConditions": ["pellets >= 0"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "labels": ["Structure"], "properties": {"docComment": "Factory that creates ghosts.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "GhostFactory", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The GhostFactory class is responsible for creating instances of different ghost characters in the Pacman game, each with its own unique sprite and behavior.", "keywords": ["GhostFactory", "Pacman", "Ghosts", "SpriteProvider", "Blinky", "Clyde", "Inky", "Pinky"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Blinky\", a.k.a. \"Shadow\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\n// TODO Blinky should speed up when there are a few pellets left, but he\r\n// has no way to find out how many there are.\r\npublic Blinky(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Blinky\", a.k.a. \"Shadow\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes a new Blinky ghost with specified sprite map, move interval, and interval variation.", "returns": "A newly created Blinky ghost instance.", "reason": "Blinky is a specific type of Ghost in the Pacman game, and this constructor initializes it with its unique properties.", "howToUse": "Create a new Blinky ghost by providing a map of sprites for each direction and the move interval and variation.", "howItWorks": "The constructor calls the superclass constructor with the provided sprite map, move interval, and interval variation to initialize the Blinky ghost.", "assertions": {"preConditions": ["spriteMap is not null", "moveInterval is a positive integer", "intervalVariation is a non-negative integer"], "postConditions": ["Blinky instance is created with the specified properties"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI", "labels": ["Structure"], "properties": {"docComment": "The default JPacMan UI frame. The PacManUI consists of the following\r\nelements:\r\n\r\n<ul>\r\n<li>A score panel at the top, displaying the score of the player(s).\r\n<li>A board panel, displaying the current level, i.e. the board and all units\r\non it.\r\n<li>A button panel, containing all buttons provided upon creation.\r\n</ul>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacManUI", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The PacManUI class is responsible for managing the user interface components and handling game updates in a Pac-Man game. It initializes the UI, sets up listeners, and schedules frame updates to refresh scores and game state.", "keywords": ["PacMan", "Game", "User Interface", "Score Panel", "Board Panel", "Key Listeners", "Frame Updates"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setAnimating(boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "kind": "method", "sourceText": "/**\r\n * Starts or stops the animation of this sprite.\r\n *\r\n * @param isAnimating\r\n * \t\t<code>true</code> to animate this sprite or <code>false</code>\r\n * \t\tto stop animating this sprite.\r\n */\r\npublic void setAnimating(boolean isAnimating) {\r\n    this.animating = isAnimating;\r\n}", "docComment": "Starts or stops the animation of this sprite.\r\n\r\n@param isAnimating\r\n\t\t<code>true</code> to animate this sprite or <code>false</code>\r\n\t\tto stop animating this sprite.\r\n", "metaSrc": "source code", "description": "Sets whether the animated sprite is currently animating.", "returns": "", "reason": "This method allows for dynamic control over the animation status of an animated sprite, enabling or disabling its animation.", "howToUse": "Call `setAnimating(true)` to start animating the sprite and `setAnimating(false)` to stop it.", "howItWorks": "The method simply assigns the provided boolean value to the private field `animating`, which is used by other methods to determine if the sprite should be animated or not.", "assertions": {"preConditions": ["The input parameter `isAnimating` must be a valid boolean value."], "postConditions": ["After calling this method, the `animating` field of the object will reflect the new state provided by `isAnimating`."]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "labels": ["Structure"], "properties": {"docComment": "Helper class to keep track of the path.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Node", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "kind": "class", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The Navigation$Node class is responsible for managing navigation paths in the Pacman game. It holds information about the current direction, parent node, and square associated with a ghost. The class provides methods to retrieve these details and construct the path from the root node to the current node.", "keywords": ["navigation", "path", "ghost", "direction", "square"], "roleStereotype": "Structurer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Speedy.\r\n</p>\r\n<p>\r\nNickname: Pinky. Speedy gets his name for an unusual reason. Speedy appears\r\nto try to outsmart Pac-Man and crash into Pac-Man from the opposite\r\ndirection. The truth behind this is that when Speedy isn't patrolling the\r\ntop-left corner of the maze, he tries to attack Pac-Man by moving to where he\r\nis going to be (that is, a few spaces ahead of Pac-Man's current direction)\r\ninstead of right where he is, as Blinky does. It's difficult to use this to\r\nyour advantage, but it's possible. If Pinky is coming at you and you face a\r\ndifferent direction, even briefly, he may just turn away and attempt to cut\r\nyou off in the new direction while you return to your original direction. In\r\nthe original Japanese version, his name is Machibuse/Pinky.\r\n</p>\r\n<p>\r\n<b>AI:</b> When the ghosts are not patrolling their home corners, Pinky wants\r\nto go to the place that is four grid spaces ahead of Pac-Man in the direction\r\nthat Pac-Man is facing. If Pac-Man is facing down, Pinky wants to go to the\r\nlocation exactly four spaces below Pac-Man. Moving towards this place uses\r\nthe same logic that Blinky uses to find Pac-Man's exact location. Pinky is\r\naffected by a targeting bug if Pac-Man is facing up - when he moves or faces\r\nup, Pinky tries moving towards a point up, and left, four spaces.\r\n</p>\r\n<p>\r\n<i>Note: In the original arcade series, the ghosts' genders are unspecified\r\nand assumed to be male. In 1999, the USA division of Namco and Namco Hometech\r\ndeveloped the Pac-Man World series and declared Pinky to be female.</i>\r\n</p>\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Pinky", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The Pinky class is responsible for managing the AI behavior of the Speedy ghost in Pac-Man, including calculating its next move based on the nearest player's position and finding the shortest path to them.", "keywords": ["Pacman", "Ghost", "AI", "Navigation", "Pathfinding"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game instance to initialize the board panel with."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "defaultCollisions()", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "kind": "method", "sourceText": "/**\r\n * Creates the default collisions Player-Ghost and Player-Pellet.\r\n *\r\n * @return The collision map containing collisions for Player-Ghost and\r\nPlayer-Pellet.\r\n */\r\nprivate nl.tudelft.jpacman.level.CollisionInteractionMap defaultCollisions() {\r\n    nl.tudelft.jpacman.level.CollisionInteractionMap collisionMap = new nl.tudelft.jpacman.level.CollisionInteractionMap();\r\n    collisionMap.onCollision(nl.tudelft.jpacman.level.Player.class, nl.tudelft.jpacman.npc.Ghost.class, (nl.tudelft.jpacman.level.Player player,nl.tudelft.jpacman.npc.Ghost ghost) -> {\r\n        this.pointCalculator.collidedWithAGhost(player, ghost);\r\n        player.setAlive(false);\r\n        player.setKiller(ghost);\r\n    });\r\n    collisionMap.onCollision(nl.tudelft.jpacman.level.Player.class, nl.tudelft.jpacman.level.Pellet.class, (nl.tudelft.jpacman.level.Player player,nl.tudelft.jpacman.level.Pellet pellet) -> {\r\n        this.pointCalculator.consumedAPellet(player, pellet);\r\n        pellet.leaveSquare();\r\n    });\r\n    return collisionMap;\r\n}", "docComment": "Creates the default collisions Player-Ghost and Player-Pellet.\r\n\r\n@return The collision map containing collisions for Player-Ghost and\r\nPlayer-Pellet.\r\n", "metaSrc": "source code", "description": "Adds collision handlers for player-ghost and player-pellet interactions in the game.", "returns": "Void", "reason": "The method initializes collision handling for specific interactions between players, ghosts, and pellets to manage game mechanics such as ghost collisions, pellet consumption, and player death.", "howToUse": "Call this method when setting up the collision map for a Pacman game level.", "howItWorks": "The method creates a new CollisionInteractionMap and adds handlers for player-ghost and player-pellet interactions. It updates player points and sets their alive status based on collisions.", "assertions": {"preConditions": ["A CollisionInteractionMap instance is available"], "postConditions": ["Collision handlers are added to the map"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Caption for the default stop button.\r\n */\r\nprivate static final java.lang.String STOP_CAPTION = \"Stop\";", "visibility": "private", "simpleName": "STOP_CAPTION", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that collided with the pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.level.Player.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    if (this.isAlive()) {\r\n        return this.sprites.get(this.getDirection());\r\n    }\r\n    return this.deathSprite;\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the current sprite of the player based on their direction or death sprite if they are not alive.", "returns": "The current sprite of the player as an instance of nl.tudelft.jpacman.sprite.Sprite", "reason": "This method provides a way to dynamically change the visual representation of the player in response to their state (alive or dead) and direction.", "howToUse": "Call this method on an instance of Player to get its current sprite. It is typically used in rendering logic where the player's appearance needs to be updated based on its state.", "howItWorks": "The method checks if the player is alive using `isAlive()`. If true, it returns the sprite corresponding to the player's direction using `getDirection()`. If false, it returns the death sprite stored in `deathSprite`.", "assertions": {"preConditions": ["The Player instance exists and has valid methods `isAlive()` and `getDirection()`"], "postConditions": ["The method returns a Sprite object representing the player's current state"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The direction to move the player."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file containing the sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "kind": "static method", "sourceText": "/**\r\n * Finds a subtype of Unit in a level.\r\n * This method is very useful for finding the ghosts in the parsed map.\r\n *\r\n * @param clazz\r\n * \t\tthe type to search for.\r\n * @param board\r\n * \t\tthe board to find the unit in.\r\n * @param <T>\r\n * \t\tthe return type, same as the type in clazz.\r\n * @return the first unit found of type clazz, or null.\r\n */\r\npublic static <T extends nl.tudelft.jpacman.board.Unit> T findUnitInBoard(java.lang.Class<T> clazz, nl.tudelft.jpacman.board.Board board) {\r\n    for (int y = 0; y < board.getHeight(); y++) {\r\n        for (int x = 0; x < board.getWidth(); x++) {\r\n            final T ghost = nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(clazz, board.squareAt(x, y));\r\n            if (ghost != null) {\r\n                return ghost;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}", "docComment": "Finds a subtype of Unit in a level.\r\n This method is very useful for finding the ghosts in the parsed map.\r\n\r\n@param clazz\r\n\t\tthe type to search for.\r\n@param board\r\n\t\tthe board to find the unit in.\r\n@param <T>\r\n\t\tthe return type, same as the type in clazz.\r\n@return the first unit found of type clazz, or null.\r\n", "metaSrc": "source code", "description": "Finds an instance of a specified unit class on a given board.", "returns": "A T instance if found, otherwise null.", "reason": "This method is used to locate a specific type of unit (ghost) on the game board by iterating through each square and checking for an occupant of the specified class.", "howToUse": "Call this method with the desired unit class and the board object to find a ghost on the board. Example: `findUnitInBoard(Ghost.class, board);`", "howItWorks": "The method iterates over each square on the board using nested loops. For each square, it calls the `findUnit` method with the specified unit class and the current square to check if there is an occupant of that type. If a ghost is found, it returns the ghost instance; otherwise, it continues searching until all squares have been checked.", "assertions": {"preConditions": ["The board object must be valid and not null."], "postConditions": ["If a ghost of the specified class is found on the board, it will be returned. If no such ghost is found, null will be returned."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "labels": ["Variable"], "properties": {"simpleName": "traveller", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The unit that is navigating on the board."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player object involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate to check."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "kind": "static method", "sourceText": "/**\r\n * Determines whether a square has an occupant of a certain type.\r\n *\r\n * @param type\r\n * \t\tThe type to search for.\r\n * @param square\r\n * \t\tThe square to search.\r\n * @param <T>\r\n * \t\tthe type of unit we searched for.\r\n * @return A unit of type T, iff such a unit occupies this square, or\r\n<code>null</code> of none does.\r\n */\r\n@java.lang.SuppressWarnings(\"unchecked\")\r\npublic static <T extends nl.tudelft.jpacman.board.Unit> T findUnit(java.lang.Class<T> type, nl.tudelft.jpacman.board.Square square) {\r\n    for (nl.tudelft.jpacman.board.Unit unit : square.getOccupants()) {\r\n        if (type.isInstance(unit)) {\r\n            assert unit.hasSquare();\r\n            return ((T) (unit));\r\n        }\r\n    }\r\n    return null;\r\n}", "docComment": "Determines whether a square has an occupant of a certain type.\r\n\r\n@param type\r\n\t\tThe type to search for.\r\n@param square\r\n\t\tThe square to search.\r\n@param <T>\r\n\t\tthe type of unit we searched for.\r\n@return A unit of type T, iff such a unit occupies this square, or\r\n<code>null</code> of none does.\r\n", "metaSrc": "source code", "description": "Finds an instance of a specified unit class on a given square.", "returns": "A T instance if found, otherwise null.", "reason": "Provides a utility method to locate specific unit types within a given square, facilitating navigation and interaction logic in the Pacman game.", "howToUse": "Call `findUnit` with the desired unit class and the target square. It will return the first unit of that type found on the square or null if no such unit exists.", "howItWorks": "Iterates over all units occupying the specified square, checks if each unit is an instance of the given class, and returns it if true. Uses assertions to ensure the unit has a square associated with it before returning.", "assertions": {"preConditions": ["The provided square must not be null."], "postConditions": ["If a unit of the specified type is found, it will be returned as an instance of T. If no such unit exists or if the square is null, null will be returned."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "labels": ["Variable"], "properties": {"simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The y-coordinate of the current position in the map."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The square associated with this node.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Square square;", "visibility": "private", "simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory", "labels": ["Structure"], "properties": {"docComment": "Factory that provides Game objects.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "GameFactory", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory", "kind": "class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The GameFactory class is responsible for creating instances of different types of games based on the provided parameters. It manages the creation of players and levels, and provides a way to create single-player games.", "keywords": ["GameFactory", "Game Creation", "Player Factory", "Level Management"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "ghostSprite", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The y-coordinate of the top-left corner of the square on the board."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextMove()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "kind": "method", "sourceText": "/**\r\n * Calculates the next move for this unit and returns the direction to move\r\n * in.\r\n * <p>\r\n * Precondition: The NPC occupies a square (hasSquare() holds).\r\n *\r\n * @return The direction to move in, or <code>null</code> if no move could\r\nbe devised.\r\n */\r\npublic nl.tudelft.jpacman.board.Direction nextMove() {\r\n    return this.nextAiMove().orElseGet(this::randomMove);\r\n}", "docComment": "Calculates the next move for this unit and returns the direction to move\r\nin.\r\n<p>\r\nPrecondition: The NPC occupies a square (hasSquare() holds).\r\n\r\n@return The direction to move in, or <code>null</code> if no move could\r\nbe devised.\r\n", "metaSrc": "source code", "description": "Returns an optional direction for the ghost to move next based on its AI strategy or a random move if AI is impossible.", "returns": "Optional<Direction>", "reason": "The method provides a fallback mechanism for ghosts that cannot make an AI move, ensuring they can still navigate the game board.", "howToUse": "Call `nextMove()` on a Ghost instance to get its next movement direction.", "howItWorks": "First, it tries to calculate a move using `nextAiMove()`. If this fails (returns an empty Optional), it defaults to choosing a random direction using `randomMove().`", "preConditions": ["A valid Ghost instance is provided"], "postConditions": ["Returns an Optional containing the next movement direction or an empty Optional if no AI move is possible."], "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The handler that handles the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getDirection()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The direction for this node, or <code>null</code> if this\r\nnode is a root node.\r\n */\r\nprivate nl.tudelft.jpacman.board.Direction getDirection() {\r\n    return this.direction;\r\n}", "docComment": "\r\n@return The direction for this node, or <code>null</code> if this\r\nnode is a root node.\r\n", "metaSrc": "source code", "description": "Returns the current direction of a ghost in the Pacman game.", "returns": "The current direction of the ghost as an instance of nl.tudelft.jpacman.board.Direction.", "reason": "This method provides access to the current movement direction of a ghost, which is essential for its navigation and behavior in the game.", "howToUse": "To use this method, simply call it on an instance of Navigation$Node representing a ghost. It will return the direction the ghost is currently facing.", "howItWorks": "The method directly returns the value stored in the 'direction' field of the current object, which holds the last known movement direction of the ghost.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "currentSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The frame of the current index.\r\n */\r\nprivate nl.tudelft.jpacman.sprite.Sprite currentSprite() {\r\n    nl.tudelft.jpacman.sprite.Sprite result = nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP;\r\n    if (this.current < this.animationFrames.length) {\r\n        result = this.animationFrames[this.current];\r\n    }\r\n    assert result != null;\r\n    return result;\r\n}", "docComment": "\r\n@return The frame of the current index.\r\n", "metaSrc": "source code", "description": "Returns the current sprite in the animation sequence, or the end of loop sprite if no more frames are available.", "returns": "The current sprite in the animation sequence or the end of loop sprite.", "reason": "This method manages the animation state of an animated sprite by providing access to the current frame and handling cases where there are no more frames left.", "howToUse": "Call this method on an instance of AnimatedSprite to get the current sprite in the animation sequence.", "howItWorks": "The method checks if the current index is within the bounds of the animationFrames array. If it is, it returns the corresponding frame; otherwise, it returns the endOfLoop sprite.", "assertions": {"preConditions": ["this.current < this.animationFrames.length"], "postConditions": ["result != null"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "labels": ["Variable"], "properties": {"simpleName": "isAnimating", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "Initial animation status."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "directionSprite(java.lang.String,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "kind": "method", "sourceText": "/**\r\n * Returns a new map with animations for all directions.\r\n *\r\n * @param resource\r\n * \t\tThe resource name of the sprite.\r\n * @param frames\r\n * \t\tThe number of frames in this sprite.\r\n * @return The animated sprite facing the given direction.\r\n */\r\nprivate java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> directionSprite(java.lang.String resource, int frames) {\r\n    java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> sprite = new java.util.HashMap<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite>();\r\n    nl.tudelft.jpacman.sprite.Sprite baseImage = this.loadSprite(resource);\r\n    for (int i = 0; i < nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS.length; i++) {\r\n        nl.tudelft.jpacman.sprite.Sprite directionSprite = baseImage.split(0, i * nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE, frames * nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE, nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE);\r\n        nl.tudelft.jpacman.sprite.AnimatedSprite animation = this.createAnimatedSprite(directionSprite, frames, nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY, true);\r\n        animation.setAnimating(true);\r\n        sprite.put(nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS[i], animation);\r\n    }\r\n    return sprite;\r\n}", "docComment": "Returns a new map with animations for all directions.\r\n\r\n@param resource\r\n\t\tThe resource name of the sprite.\r\n@param frames\r\n\t\tThe number of frames in this sprite.\r\n@return The animated sprite facing the given direction.\r\n", "metaSrc": "source code", "description": "Creates animated sprites for each direction based on a base image and splits it into frames.", "returns": "A map from directions to animated sprites.", "reason": "This method is responsible for loading and animating Pac-Man's sprite in different directions based on a base image.", "howToUse": "Call this method with the path to the sprite resource file and the number of frames for each animation. It will return a map containing an animated sprite for each direction.", "howItWorks": "The method creates a new HashMap to store the animated sprites. It loads the base image using the loadSprite method, then splits it into multiple frames based on the given number of frames and dimensions. Each frame is converted into an AnimatedSprite object with the specified delay and looping behavior. The animated sprite is added to the map with its corresponding direction.", "assertions": {"preConditions": ["The resource file exists and contains valid sprite images.", "frames is a positive integer."], "postConditions": ["A non-empty map of animated sprites is returned, one for each direction.", "Each animated sprite has the correct number of frames and delay."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getPlayerFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the sprites from {@link #getSpriteStore()}.\r\n */\r\nprotected nl.tudelft.jpacman.level.PlayerFactory getPlayerFactory() {\r\n    return new nl.tudelft.jpacman.level.PlayerFactory(this.getSpriteStore());\r\n}", "docComment": "\r\n@return A new factory using the sprites from {@link #getSpriteStore()}.\r\n", "metaSrc": "source code", "description": "Returns a new instance of PlayerFactory using the current SpriteStore.", "returns": "nl.tudelft.jpacman.level.PlayerFactory", "reason": "The method creates and returns an instance of PlayerFactory, which is responsible for creating player entities in the game. This factory uses the current SpriteStore to provide sprites for the players.", "howToUse": "Call this method from a class that needs to create player objects.", "howItWorks": "The method calls getSpriteStore() to obtain the current SpriteStore instance and then creates a new PlayerFactory using this store. The returned factory is used to create player entities in the game.", "preConditions": [], "postConditions": ["A new PlayerFactory instance is created and returned."], "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 200;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "labels": ["Variable"], "properties": {"simpleName": "caption", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "labels": ["Variable"], "properties": {"simpleName": "c", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "kind": "parameter", "parameterPosition": 5, "metaSrc": "source code", "description": "The character representing the type of square at the current position."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "labels": ["Variable"], "properties": {"simpleName": "color", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The color of the ghost."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.start()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "start()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.start()", "kind": "method", "sourceText": "/**\r\n * Starts the \"engine\", the thread that redraws the interface at set\r\n * intervals.\r\n */\r\npublic void start() {\r\n    this.setVisible(true);\r\n    java.util.concurrent.ScheduledExecutorService service = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\r\n    service.scheduleAtFixedRate(this::nextFrame, 0, nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS);\r\n}", "docComment": "Starts the \"engine\", the thread that redraws the interface at set\r\nintervals.\r\n", "metaSrc": "source code", "description": "Starts the PacMan game by setting visibility to true and scheduling frame updates at regular intervals.", "returns": "", "reason": "The method initializes the UI, sets it visible, and schedules periodic updates for the game's frames.", "howToUse": "Call `start()` on an instance of `PacManUI` to begin the game.", "howItWorks": "The method creates a single-threaded scheduled executor service to run the nextFrame() method at regular intervals defined by FRAME_INTERVAL in milliseconds.", "assertions": {"preConditions": ["An instance of PacManUI is created and initialized."], "postConditions": ["The UI is set visible, and frame updates are scheduled."]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall", "labels": ["Structure"], "properties": {"docComment": "A wall is a square that is inaccessible to anyone.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Wall", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The Wall class is responsible for creating and managing wall squares in the Pacman game. It initializes a new wall square with a specified background sprite, checks if it's accessible to units, and provides methods to retrieve its sprite.", "keywords": ["wall", "square", "Pacman", "game", "background", "sprite", "accessible"], "roleStereotype": "Structurer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * Tries to calculate a move based on the behaviour of the npc.\r\n *\r\n * @return an optional containing the move or empty if the current state of the game\r\nmakes the ai move impossible\r\n */\r\npublic abstract java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove();", "docComment": "Tries to calculate a move based on the behaviour of the npc.\r\n\r\n@return an optional containing the move or empty if the current state of the game\r\nmakes the ai move impossible\r\n", "metaSrc": "source code", "description": "Returns an optional direction for the ghost to move next based on its AI strategy.", "returns": "Optional<Direction>", "reason": "Provides a way for ghosts to make decisions about their movement in the game, enhancing the AI aspect of the Pacman game.", "howToUse": "Call this method from within a ghost's logic class to determine its next move.", "howItWorks": "The method uses an AI strategy to decide which direction the ghost should move. It returns an Optional<Direction> to handle cases where no valid move is possible.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "labels": ["Variable"], "properties": {"simpleName": "map", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map containing classes as keys and objects as values."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(int,nl.tudelft.jpacman.sprite.Sprite)", "qualifiedName": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new pellet.\r\n *\r\n * @param points\r\n * \t\tThe point value of this pellet.\r\n * @param sprite\r\n * \t\tThe sprite of this pellet.\r\n */\r\npublic Pellet(int points, nl.tudelft.jpacman.sprite.Sprite sprite) {\r\n    super();\r\n    this.image = sprite;\r\n    this.value = points;\r\n}", "docComment": "Creates a new pellet.\r\n\r\n@param points\r\n\t\tThe point value of this pellet.\r\n@param sprite\r\n\t\tThe sprite of this pellet.\r\n", "metaSrc": "source code", "description": "Initializes a Pellet with a specified image and points value.", "returns": "A newly created Pellet instance.", "reason": "This method is part of the logic layer as it initializes a new entity in the game, which involves setting properties and initializing resources.", "howToUse": "Create a Pellet by providing the number of points and its visual representation.", "howItWorks": "The constructor sets the image and value of the Pellet. It also calls the superclass constructor to initialize the Unit instance with an east-facing direction.", "assertions": {"preConditions": ["points is a valid integer representing the number of points", "sprite is a valid instance of nl.tudelft.jpacman.sprite.Sprite"], "postConditions": ["A Pellet instance is created with the specified image and points value", "The Pellet's direction is set to east"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "kind": "method", "sourceText": "/**\r\n * Provide formatter for the score.\r\n *\r\n * @param scoreFormatter\r\n * \t\tThe score formatter to be used.\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter) {\r\n    this.scoreFormatter = scoreFormatter;\r\n    return this;\r\n}", "docComment": "Provide formatter for the score.\r\n\r\n@param scoreFormatter\r\n\t\tThe score formatter to be used.\r\n@return The builder.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener", "labels": ["Structure"], "properties": {"docComment": "A key listener based on a set of keyCode-action pairs.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacKeyListener", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener", "kind": "class", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The class is responsible for handling user input in the Pacman game by mapping key presses to specific actions, such as moving the player character.", "keywords": ["KeyListener", "Pacman", "Input Handling", "Game Controller"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "method", "sourceText": "/**\r\n * Adds the collision interaction..\r\n *\r\n * @param collider\r\n * \t\tThe collider type.\r\n * @param collidee\r\n * \t\tThe collidee type.\r\n * @param handler\r\n * \t\tThe handler that handles the collision.\r\n */\r\nprivate void addHandler(java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> collider, java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> collidee, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object> handler) {\r\n    if (!this.handlers.containsKey(collider)) {\r\n        this.handlers.put(collider, new java.util.HashMap<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>>());\r\n    }\r\n    java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>> map = this.handlers.get(collider);\r\n    map.put(collidee, handler);\r\n}", "docComment": "Adds the collision interaction..\r\n\r\n@param collider\r\n\t\tThe collider type.\r\n@param collidee\r\n\t\tThe collidee type.\r\n@param handler\r\n\t\tThe handler that handles the collision.\r\n", "metaSrc": "source code", "description": "Adds a collision handler for a specific pair of units in the game.", "returns": "void", "reason": "Manages collision handling in the game by associating handlers with specific unit pairs.", "howToUse": "Call this method with the appropriate unit classes and a collision handler to register them.", "howItWorks": "Checks if the collider is already in the map, creates it if not. Then adds the collidee and its handler to the map.", "assertions": {"preConditions": ["collider", "collidee", "handler"], "postConditions": ["The collision handler is added for the specified pair of units."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.image;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stop()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "stop()", "qualifiedName": "nl.tudelft.jpacman.level.Level.stop()", "kind": "method", "sourceText": "/**\r\n * Stops or pauses this level, no longer allowing any movement on the board\r\n * and stopping all NPCs.\r\n */\r\npublic void stop() {\r\n    synchronized(this.startStopLock) {\r\n        if (!this.isInProgress()) {\r\n            return;\r\n        }\r\n        this.stopNPCs();\r\n        this.inProgress = false;\r\n    }\r\n}", "docComment": "Stops or pauses this level, no longer allowing any movement on the board\r\nand stopping all NPCs.\r\n", "metaSrc": "source code", "description": "Stops all NPCs in progress and sets the level's progress to false.", "returns": "", "reason": "The method ensures that all NPC movements are stopped when the level is no longer in progress, maintaining game state consistency.", "howToUse": "Call `stop()` on an instance of `Level` to stop NPCs and mark the level as not in progress.", "howItWorks": "Synchronizes access to the startStopLock to ensure thread safety. Checks if the level is in progress before stopping NPCs and setting the inProgress flag to false.", "assertions": {"preConditions": ["The method should only be called when the level is in progress.", "The stopNPCs() method should not throw any exceptions."], "postConditions": ["All NPC movements should have been stopped.", "The inProgress flag of the level should be set to false."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "kind": "constructor", "sourceText": "PointCalculatorLoader() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "labels": ["Variable"], "properties": {"simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The formatter to use for displaying scores."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "labels": ["Variable"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The background sprite for the ground."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWallSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The sprite for the wall.\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite getWallSprite() {\r\n    return this.loadSprite(\"/sprite/wall.png\");\r\n}", "docComment": "\r\n@return The sprite for the wall.\r\n", "metaSrc": "source code", "description": "Loads a wall sprite from a resource file and returns it as an ImageSprite.", "returns": "A new ImageSprite object representing the loaded or cached wall sprite.", "reason": "The method provides a convenient way to access the wall sprite used in the Pacman game, ensuring that the sprite is loaded efficiently and reused if already present.", "howToUse": "Call `getWallSprite()` to retrieve the wall sprite. This method should be called when rendering walls in the game's map.", "howItWorks": "The method uses the `loadSprite` method to load a wall sprite from the specified resource file. If the sprite is not already cached, it will be loaded and cached for future use.", "assertions": {"preConditions": [], "postConditions": ["The returned object is an instance of ImageSprite."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getValue()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getValue()", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.getValue()", "kind": "method", "sourceText": "/**\r\n * Returns the point value of this pellet.\r\n *\r\n * @return The point value of this pellet.\r\n */\r\npublic int getValue() {\r\n    return this.value;\r\n}", "docComment": "Returns the point value of this pellet.\r\n\r\n@return The point value of this pellet.\r\n", "metaSrc": "source code", "description": "Returns the value associated with the Pellet.", "returns": "The integer value of the Pellet.", "reason": "This method provides a simple getter for the value attribute of the Pellet class, which is essential for accessing the value in various parts of the game logic.", "howToUse": "To use this method, simply call it on an instance of the Pellet class. For example: Pellet pellet = new Pellet(); int value = pellet.getValue();", "howItWorks": "The method directly returns the value attribute of the Pellet object. This is a straightforward implementation that does not involve any complex logic or external dependencies.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "kind": "static method", "sourceText": "/**\r\n * Calculates the shortest path. This is done by BFS. This search ensures\r\n * the traveller is allowed to occupy the squares on the way, or returns the\r\n * shortest path to the square regardless of terrain if no traveller is\r\n * specified.\r\n *\r\n * @param from\r\n * \t\tThe starting square.\r\n * @param to\r\n * \t\tThe destination.\r\n * @param traveller\r\n * \t\tThe traveller attempting to reach the destination. If\r\n * \t\ttraveller is set to <code>null</code>, this method will ignore\r\n * \t\tterrain and find the shortest path whether it can actually be\r\n * \t\treached or not.\r\n * @return The shortest path to the destination or <code>null</code> if no\r\nsuch path could be found. When the destination is the current\r\nsquare, an empty list is returned.\r\n */\r\npublic static java.util.List<nl.tudelft.jpacman.board.Direction> shortestPath(nl.tudelft.jpacman.board.Square from, nl.tudelft.jpacman.board.Square to, nl.tudelft.jpacman.board.Unit traveller) {\r\n    if (from.equals(to)) {\r\n        return new java.util.ArrayList<nl.tudelft.jpacman.board.Direction>();\r\n    }\r\n    java.util.List<nl.tudelft.jpacman.npc.ghost.Navigation.Node> targets = new java.util.ArrayList<nl.tudelft.jpacman.npc.ghost.Navigation.Node>();\r\n    java.util.Set<nl.tudelft.jpacman.board.Square> visited = new java.util.HashSet<nl.tudelft.jpacman.board.Square>();\r\n    targets.add(new nl.tudelft.jpacman.npc.ghost.Navigation.Node(null, from, null));\r\n    while (!targets.isEmpty()) {\r\n        nl.tudelft.jpacman.npc.ghost.Navigation.Node node = targets.remove(0);\r\n        nl.tudelft.jpacman.board.Square square = node.getSquare();\r\n        if (square.equals(to)) {\r\n            return node.getPath();\r\n        }\r\n        visited.add(square);\r\n        nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(traveller, targets, visited, node, square);\r\n    } \r\n    return null;\r\n}", "docComment": "Calculates the shortest path. This is done by BFS. This search ensures\r\nthe traveller is allowed to occupy the squares on the way, or returns the\r\nshortest path to the square regardless of terrain if no traveller is\r\nspecified.\r\n\r\n@param from\r\n\t\tThe starting square.\r\n@param to\r\n\t\tThe destination.\r\n@param traveller\r\n\t\tThe traveller attempting to reach the destination. If\r\n\t\ttraveller is set to <code>null</code>, this method will ignore\r\n\t\tterrain and find the shortest path whether it can actually be\r\n\t\treached or not.\r\n@return The shortest path to the destination or <code>null</code> if no\r\nsuch path could be found. When the destination is the current\r\nsquare, an empty list is returned.\r\n", "metaSrc": "source code", "description": "Finds the shortest path from one square to another on a Pacman board using a breadth-first search algorithm.", "returns": "A list of directions representing the shortest path from 'from' to 'to'.", "reason": "This method implements a pathfinding algorithm to determine the optimal sequence of moves for a Pacman character to reach its target location.", "howToUse": "Call this method with the starting and ending squares, along with the unit that is navigating. It will return a list of directions indicating how to move from the start to the end.", "howItWorks": "The method uses a breadth-first search (BFS) algorithm to explore all possible paths from the starting square to the target square. It keeps track of visited squares and adds new targets based on accessible squares in all four cardinal directions. The path is reconstructed by backtracking from the target square.", "assertions": {"preConditions": ["The 'from' and 'to' squares must be valid and exist within the board.", "The 'traveller' unit must be a valid Pacman character."], "postConditions": ["If a path exists, it will return a list of directions. If no path is found, it returns null."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate of the top-left corner of the sub-image."}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException", "labels": ["Structure"], "properties": {"docComment": "Exception that is thrown when JPacman cannot be properly loaded\r\nfrom its resources.\r\n\r\n@author Arie van Deursen, 2014\r\n", "simpleName": "PacmanConfigurationException", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for handling configuration-related exceptions in the Pacman game implementation. It provides two constructors to create a configuration exception with either a direct message or a message along with a root cause.", "keywords": ["configuration", "exception", "Pacman", "Java"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getWidth() {\r\n    return this.image.getWidth(null);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of frames in the pacman dying animation.\r\n */\r\nprivate static final int PACMAN_DEATH_FRAMES = 11;", "visibility": "private", "simpleName": "PACMAN_DEATH_FRAMES", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "labels": ["Variable"], "properties": {"simpleName": "buttons", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map of button captions to corresponding action objects."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store containing the Pac-Man sprites.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player who has moved."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player that will die."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createClyde()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "kind": "method", "sourceText": "/**\r\n * Creates a new Clyde / Pokey, the orange Ghost.\r\n *\r\n * @see Clyde\r\n * @return A new Clyde.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createClyde() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Clyde(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE));\r\n}", "docComment": "Creates a new Clyde / Pokey, the orange Ghost.\r\n\r\n@see Clyde\r\n@return A new Clyde.\r\n", "metaSrc": "source code", "description": "Creates an instance of Clyde, a ghost in the Pacman game.", "returns": "A new instance of Clyde, a ghost in the Pacman game.", "reason": "The method creates an instance of Clyde by using the provided sprites and returns it.", "howToUse": "Call this method with an array of sprites to create a Clyde object.", "howItWorks": "The method calls getGhostSprite with the color ORANGE and uses the returned map to create a new Clyde object.", "assertions": {"preConditions": ["sprites is not null"], "postConditions": ["returns a non-null instance of Clyde"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame", "labels": ["Structure"], "properties": {"docComment": "A game with one player and a single level.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "SinglePlayerGame", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The SinglePlayerGame class is responsible for managing a single-player game instance, including initializing the game with a player, level, and point calculator, and providing methods to access the current level and players.", "keywords": ["single-player", "game management", "player", "level", "point calculator"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map of directions to their corresponding sprite objects."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> iff this UI has the default buttons.\r\n */\r\nprivate boolean defaultButtons;", "visibility": "private", "simpleName": "defaultButtons", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(java.io.InputStream)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "kind": "method", "sourceText": "/**\r\n * Parses the provided input stream as a character stream and passes it\r\n * result to {@link #parseMap(List)}.\r\n *\r\n * @param source\r\n * \t\tThe input stream that will be read.\r\n * @return The parsed level as represented by the text on the input stream.\r\n * @throws IOException\r\n * \t\twhen the source could not be read.\r\n */\r\npublic nl.tudelft.jpacman.level.Level parseMap(java.io.InputStream source) throws java.io.IOException {\r\n    try (java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(source, \"UTF-8\"))) {\r\n        java.util.List<java.lang.String> lines = new java.util.ArrayList<java.lang.String>();\r\n        while (reader.ready()) {\r\n            lines.add(reader.readLine());\r\n        } \r\n        return this.parseMap(lines);\r\n    }\r\n}", "docComment": "Parses the provided input stream as a character stream and passes it\r\nresult to {@link #parseMap(List)}.\r\n\r\n@param source\r\n\t\tThe input stream that will be read.\r\n@return The parsed level as represented by the text on the input stream.\r\n@throws IOException\r\n\t\twhen the source could not be read.\r\n", "metaSrc": "source code", "description": "Parses a text representation of a Pacman game map into an actual level by reading lines from an input stream and converting them to a list of strings.", "returns": "An instance of nl.tudelft.jpacman.level.Level representing the parsed level.", "reason": "This method provides a convenient way to parse a text-based map into an actual game level, which is essential for initializing and running the game.", "howToUse": "To use this method, provide an input stream containing the text representation of the map. The method will read the lines from the stream, convert them into a list of strings, and then parse the list to create the level.", "howItWorks": "The method uses a BufferedReader to read lines from the input stream. Each line is added to a list of strings. After reading all lines, it calls the parseMap method with the list of strings as an argument to convert the text into a game level.", "assertions": {"preConditions": ["The input stream must be non-null and open."], "postConditions": ["The returned level should be valid and correctly initialized based on the parsed map."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setKiller(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Sets the cause of death.\r\n *\r\n * @param killer\r\n * \t\tis set if collision with ghost happens.\r\n */\r\npublic void setKiller(nl.tudelft.jpacman.board.Unit killer) {\r\n    this.killer = killer;\r\n}", "docComment": "Sets the cause of death.\r\n\r\n@param killer\r\n\t\tis set if collision with ghost happens.\r\n", "metaSrc": "source code", "description": "Sets the killer unit for the player in the game.", "returns": "", "reason": "This method allows the player to specify a unit that can kill other units in the game.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.board.Unit to set it as the killer for the player.", "howItWorks": "The method assigns the provided Unit object to the private field 'killer' of the Player class, which is used in game logic to determine if a unit can kill another unit.", "assertions": {"preConditions": ["A valid nl.tudelft.jpacman.board.Unit instance must be passed as an argument."], "postConditions": ["The 'killer' field of the Player class is set to the provided Unit object."]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "kind": "constructor", "sourceText": "/**\r\n * Creates a new, empty collision map.\r\n */\r\npublic CollisionInteractionMap() {\r\n    super();\r\n    this.handlers = new java.util.HashMap<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>>>();\r\n}", "docComment": "Creates a new, empty collision map.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createInky()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "kind": "method", "sourceText": "/**\r\n * Creates a new Inky / Bashful, the cyan Ghost.\r\n *\r\n * @see Inky\r\n * @return A new Inky.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createInky() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Inky(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN));\r\n}", "docComment": "Creates a new Inky / Bashful, the cyan Ghost.\r\n\r\n@see Inky\r\n@return A new Inky.\r\n", "metaSrc": "source code", "description": "Creates an Inky ghost using its sprite based on the specified color.", "returns": "A new Inky ghost instance.", "reason": "This method provides a way to create an Inky ghost by specifying its color, which is essential for game logic and rendering.", "howToUse": "Call this method with the desired GhostColor to get an Inky ghost object.", "howItWorks": "The method retrieves the sprite for the specified color using the `getGhostSprite` method and creates a new Inky ghost instance with that sprite.", "assertions": {"preConditions": ["A valid GhostColor is provided."], "postConditions": ["An Inky ghost object is returned."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player whose score needs to be formatted."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getBoardFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new board factory using the sprite store from\r\n{@link #getSpriteStore()}.\r\n */\r\nprotected nl.tudelft.jpacman.board.BoardFactory getBoardFactory() {\r\n    return new nl.tudelft.jpacman.board.BoardFactory(this.getSpriteStore());\r\n}", "docComment": "\r\n@return A new board factory using the sprite store from\r\n{@link #getSpriteStore()}.\r\n", "metaSrc": "source code", "description": "Returns a new instance of BoardFactory using the current SpriteStore.", "returns": "nl.tudelft.jpacman.board.BoardFactory", "reason": "The method provides a way to create a board factory based on the current sprite store, which is essential for initializing game boards in Pacman.", "howToUse": "Call this method from within another class that needs to create a board factory.", "howItWorks": "The method creates a new BoardFactory instance by passing the current SpriteStore to its constructor.", "assertions": {"preConditions": [], "postConditions": ["A new BoardFactory is returned."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "labels": ["Variable"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The visual representation of the Pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "mover", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is moving."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction", "labels": ["Structure"], "properties": {"docComment": "An enumeration of possible directions on a two-dimensional square grid.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Direction", "qualifiedName": "nl.tudelft.jpacman.board.Direction", "kind": "enum", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The enum `Direction` in the Pacman implementation is responsible for managing and providing information about different movement directions. It acts as a service provider by handling requests to retrieve direction-specific data, such as delta values and opposite directions.", "keywords": ["direction", "movement", "enum", "service provider"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The height of the target sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "loadSprite(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Loads a sprite from a resource on the class path.\r\n * Sprites are loaded once, and then stored in the store\r\n * so that they can be efficiently retrieved.\r\n *\r\n * @param resource\r\n * \t\tThe resource path.\r\n * @return The sprite for the resource.\r\n * @throws IOException\r\n * \t\tWhen the resource could not be loaded.\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite loadSprite(java.lang.String resource) throws java.io.IOException {\r\n    nl.tudelft.jpacman.sprite.Sprite result = this.spriteMap.get(resource);\r\n    if (result == null) {\r\n        result = this.loadSpriteFromResource(resource);\r\n        this.spriteMap.put(resource, result);\r\n    }\r\n    return result;\r\n}", "docComment": "Loads a sprite from a resource on the class path.\r\nSprites are loaded once, and then stored in the store\r\nso that they can be efficiently retrieved.\r\n\r\n@param resource\r\n\t\tThe resource path.\r\n@return The sprite for the resource.\r\n@throws IOException\r\n\t\tWhen the resource could not be loaded.\r\n", "metaSrc": "source code", "description": "Loads a sprite from a resource file if it doesn't already exist in the cache, otherwise retrieves it from the cache.", "returns": "A new ImageSprite object representing the loaded or cached sprite.", "reason": "This method ensures that sprites are efficiently managed and reused, reducing memory usage and improving performance by avoiding repeated loading of the same resources.", "howToUse": "Call this method with the path to a resource file containing a sprite. The method will return an ImageSprite object representing the loaded or cached sprite.", "howItWorks": "The method first checks if the sprite is already in the cache using `this.spriteMap.get(resource)`. If it's not, it calls `loadSpriteFromResource(resource)` to load the sprite from the file and then adds it to the cache using `this.spriteMap.put(resource, result).", "assertions": {"preConditions": ["The resource path is valid and points to a file containing a sprite."], "postConditions": ["If the sprite was not already in the cache, it will be added to the cache.", "The method returns an ImageSprite object representing the loaded or cached sprite."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Caption for the default start button.\r\n */\r\nprivate static final java.lang.String START_CAPTION = \"Start\";", "visibility": "private", "simpleName": "START_CAPTION", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The algorithm used to calculate the points that\r\n * they player gets whenever some action happens.\r\n */\r\nprivate nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.Game.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "targets", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A list to store the new targets."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGame()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getGame()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getGame()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The game object this launcher will start when {@link #launch()}\r\nis called.\r\n */\r\npublic nl.tudelft.jpacman.game.Game getGame() {\r\n    return this.game;\r\n}", "docComment": "\r\n@return The game object this launcher will start when {@link #launch()}\r\nis called.\r\n", "metaSrc": "source code", "description": "Returns the current game instance.", "returns": "The Game instance", "reason": "This method provides access to the current state of the Pacman game, allowing for manipulation or inspection of the game's components.", "howToUse": "Call this method from a class that has an instance of Launcher to retrieve the current game.", "howItWorks": "The method simply returns the `game` field of the Launcher instance. This is a straightforward accessor method.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 250;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.WEST", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * West, or left.\r\n */\r\nWEST(-1, 0)", "visibility": "public", "simpleName": "WEST", "qualifiedName": "nl.tudelft.jpacman.board.Direction.WEST", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new ground square.\r\n *\r\n * @param sprite\r\n * \t\tThe background for the square.\r\n */\r\nGround(nl.tudelft.jpacman.sprite.Sprite sprite) {\r\n    super();\r\n    this.background = sprite;\r\n}", "docComment": "Creates a new ground square.\r\n\r\n@param sprite\r\n\t\tThe background for the square.\r\n", "metaSrc": "source code", "description": "Initializes a new Ground object by setting its background sprite.", "returns": "A newly created instance of Ground with the specified background sprite.", "reason": "This method is part of the logic layer as it initializes a new object and sets its properties based on input parameters.", "howToUse": "Create a new Ground object by passing a Sprite to the constructor.", "howItWorks": "The constructor calls super() to initialize the Square class, then sets the background sprite for the ground.", "assertions": {"preConditions": ["A valid Sprite object is provided as input."], "postConditions": ["A new Ground object with the specified background sprite is created."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new random ghost.\r\n *\r\n * @param ghostSprite\r\n * \t\tThe sprite for the ghost.\r\n */\r\nRandomGhost(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> ghostSprite) {\r\n    super(ghostSprite, ((int) (nl.tudelft.jpacman.level.LevelFactory.RandomGhost.DELAY)), 0);\r\n}", "docComment": "Creates a new random ghost.\r\n\r\n@param ghostSprite\r\n\t\tThe sprite for the ghost.\r\n", "metaSrc": "source code", "description": "Initializes a new RandomGhost instance with specified sprite map, move interval, and default interval variation.", "returns": "A newly created RandomGhost instance.", "reason": "This method provides a convenient way to create a new Ghost instance with default values for move interval and interval variation.", "howToUse": "To use this method, pass a map of sprite objects for each direction to the constructor. This will initialize a new RandomGhost instance with these sprites.", "howItWorks": "The method calls the superclass constructor with the provided ghostSprite, a default move interval (defined in DELAY), and a default interval variation (0).", "assertions": {"preConditions": ["ghostSprite is not null"], "postConditions": ["A new RandomGhost instance is created with the specified sprite map."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square()", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.board.Square()", "kind": "constructor", "sourceText": "/**\r\n * Creates a new, empty square.\r\n */\r\nprotected Square() {\r\n    super();\r\n    this.occupants = new java.util.ArrayList<nl.tudelft.jpacman.board.Unit>();\r\n    this.neighbours = new java.util.EnumMap<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.board.Square>(nl.tudelft.jpacman.board.Direction.class);\r\n    assert this.invariant();\r\n}", "docComment": "Creates a new, empty square.\r\n", "metaSrc": "source code", "description": "Initializes a new Square object, setting up its occupants and neighbours lists.", "returns": "A newly created instance of Square.", "reason": "The constructor initializes the basic structure of a square in the Pacman game, preparing it for further use.", "howToUse": "Create an instance of Square by calling its default constructor.", "howItWorks": "The constructor sets up two lists: occupants and neighbours. It also calls an assertion to ensure the object's state is valid.", "assertions": {"preConditions": [], "postConditions": ["this.occupants is initialized as an empty ArrayList<nl.tudelft.jpacman.board.Unit>", "this.neighbours is initialized as an EnumMap<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.board.Square>"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground", "labels": ["Structure"], "properties": {"docComment": "A ground square is a square that is accessible to anyone.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Ground", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground", "kind": "class", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The Ground class is responsible for managing the background sprite and accessibility of squares in the game board.", "keywords": ["ground", "square", "background", "accessibility"], "roleStereotype": "Structurer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "labels": ["Variable"], "properties": {"simpleName": "action", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel", "labels": ["Container", "Structure"], "properties": {"docComment": "A panel consisting of a column for each player, with the numbered players on\r\ntop and their respective scores underneath.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "ScorePanel", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The ScorePanel class is responsible for displaying and updating scores in the Pacman game, managing player labels, and applying custom score formatting.", "keywords": ["Score Panel", "Pacman Game", "UI Component", "Player Scores", "Score Formatting"], "roleStereotype": "User Interfacer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaX", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delta x (width difference) to an element in the direction in a grid\r\n * with 0,0 (x,y) as its top-left element.\r\n */\r\nprivate final int deltaX;", "visibility": "private", "simpleName": "deltaX", "qualifiedName": "nl.tudelft.jpacman.board.Direction.deltaX", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The type of the collider unit."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "labels": ["Structure"], "properties": {"docComment": "An symmetrical copy of a collision hander.\r\n\r\n@author Michael de Jong\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee type.\r\n", "simpleName": "InverseCollisionHandler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The CollisionInteractionMap$InverseCollisionHandler class is responsible for handling collisions between units in a Pacman game by delegating to another handler, ensuring compatibility with initial collision logic.", "keywords": ["collision", "handler", "delegation", "Pacman", "game"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "labels": ["Structure"], "properties": {"docComment": "Implementation of an NPC that wanders around randomly.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "RandomGhost", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The RandomGhost class is responsible for creating and managing random ghost entities in the Pacman game. It initializes ghosts with specific sprite maps, move intervals, and interval variations, and provides a method to determine their next AI move.", "keywords": ["RandomGhost", "Pacman", "Ghosts", "AI", "Move Interval", "Interval Variation"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "newDirection", "qualifiedName": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The new direction to set for the unit."}}}, {"data": {"id": "java.lang.String", "labels": ["Structure"], "properties": {"simpleName": "String", "qualifiedName": "java.lang.String", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate of the square to retrieve."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "labels": ["Structure"], "properties": {"docComment": "An extensible default interaction map for collisions caused by the player.\r\n\r\nThe implementation makes use of the interactionmap, and as such can be easily\r\nand declaratively extended when new types of units (ghosts, players, ...) are\r\nadded.\r\n\r\n@author Arie van Deursen\r\n@author Jeroen Roosen\r\n", "simpleName": "DefaultPlayerInteractionMap", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The class is responsible for managing player interactions in a Pacman game, including collision detection and handling points.", "keywords": ["collision", "interaction", "point", "Pacman"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "keyPressed(java.awt.event.KeyEvent)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void keyPressed(java.awt.event.KeyEvent event) {\r\n    assert event != null;\r\n    nl.tudelft.jpacman.ui.Action action = this.mappings.get(event.getKeyCode());\r\n    if (action != null) {\r\n        action.doAction();\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Processes key presses to trigger game actions in Pacman.", "returns": "", "reason": "Handles user input for controlling the game's actions.", "howToUse": "Call this method when a key is pressed to execute corresponding game actions.", "howItWorks": "Retrieves the action associated with the pressed key from a mapping and executes it if found.", "assertions": {"preConditions": ["event is not null"], "postConditions": []}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader", "labels": ["Structure"], "properties": {"docComment": "The responsibility of this loader is to obtain the appropriate points calculator.\r\nBy default the {@link DefaultPointCalculator} is returned.\r\n", "simpleName": "PointCalculatorLoader", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader", "kind": "class", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The PointCalculatorLoader class is responsible for managing the loading and configuration of point calculators in a Pacman game. It provides methods to load a specific point calculator class dynamically, either from a properties file or using a default implementation.", "keywords": ["point calculator", "scoring system", "configuration management", "dynamic loading"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaY", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delta y (height difference) to an element in the direction in a grid\r\n * with 0,0 (x,y) as its top-left element.\r\n */\r\nprivate final int deltaY;", "visibility": "private", "simpleName": "deltaY", "qualifiedName": "nl.tudelft.jpacman.board.Direction.deltaY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "run()", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void run() {\r\n    nl.tudelft.jpacman.board.Direction nextMove = this.npc.nextMove();\r\n    if (nextMove != null) {\r\n        this.move(this.npc, nextMove);\r\n    }\r\n    long interval = this.npc.getInterval();\r\n    this.service.schedule(this, interval, java.util.concurrent.TimeUnit.MILLISECONDS);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Runs an NPC's move task by determining its next move and scheduling it to repeat at a specified interval.", "returns": "", "reason": "The method is responsible for managing the movement of NPCs in the game, ensuring they follow their AI strategy or make random moves when necessary.", "howToUse": "Call this method on an instance of Level$NpcMoveTask to start its execution.", "howItWorks": "1. Determine the next move for the NPC using the `nextMove()` method.\n2. If a valid move is determined, execute it using the `move()` method.\n3. Schedule the task to run again after the specified interval using the `schedule()` method of the service.", "assertions": {"preConditions": ["The NPC has a square occupied and an AI strategy or random movement logic available."], "postConditions": ["The NPC moves according to its AI strategy or makes a random move, and the task is scheduled to repeat at the specified interval."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "occupy(nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "kind": "method", "sourceText": "/**\r\n * Occupies the target square iff this unit is allowed to as decided by\r\n * {@link Square#isAccessibleTo(Unit)}.\r\n *\r\n * @param target\r\n * \t\tThe square to occupy.\r\n */\r\npublic void occupy(nl.tudelft.jpacman.board.Square target) {\r\n    assert target != null;\r\n    if (this.square != null) {\r\n        this.square.remove(this);\r\n    }\r\n    this.square = target;\r\n    target.put(this);\r\n    assert this.invariant();\r\n}", "docComment": "Occupies the target square iff this unit is allowed to as decided by\r\n{@link Square#isAccessibleTo(Unit)}.\r\n\r\n@param target\r\n\t\tThe square to occupy.\r\n", "metaSrc": "source code", "description": "Adds an occupant to the target square and removes the current occupant from its previous square.", "returns": "", "reason": "Manages the occupancy of squares by units in a Pacman game.", "howToUse": "Call this method with the target square where the unit should occupy.", "howItWorks": "Removes the current occupant from its previous square, adds the new occupant to the target square, and asserts that the invariant is maintained.", "assertions": {"preConditions": ["target != null", "this.square != null"], "postConditions": ["this.square == target", "target.contains(this)", "this.invariant()"]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getInterval()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "kind": "method", "sourceText": "/**\r\n * The time that should be taken between moves.\r\n *\r\n * @return The suggested delay between moves in milliseconds.\r\n */\r\npublic long getInterval() {\r\n    return this.moveInterval + new java.util.Random().nextInt(this.intervalVariation);\r\n}", "docComment": "The time that should be taken between moves.\r\n\r\n@return The suggested delay between moves in milliseconds.\r\n", "metaSrc": "source code", "description": "Returns the interval for ghost movement, which is the sum of moveInterval and a random integer between 0 and intervalVariation.", "returns": "A long value representing the interval for ghost movement.", "reason": "The method provides a dynamic interval for ghost movement to add variability to their behavior.", "howToUse": "Call this method to get the current interval for ghost movement.", "howItWorks": "The method calculates the interval by adding moveInterval and a random integer between 0 and intervalVariation. This ensures that each ghost moves at a slightly different speed, making the game more challenging.", "assertions": {"preConditions": [], "postConditions": ["The returned value is a long representing the interval for ghost movement."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.board", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The board of this level.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Board board;", "visibility": "private", "simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.level.Level.board", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.value", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The point value of this pellet.\r\n */\r\nprivate final int value;", "visibility": "private", "simpleName": "value", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.value", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getHeight() {\r\n    return 0;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.pacManUI", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.ui.PacManUI pacManUI;", "visibility": "private", "simpleName": "pacManUI", "qualifiedName": "nl.tudelft.jpacman.Launcher.pacManUI", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate of the square to retrieve."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "labels": ["Variable"], "properties": {"simpleName": "loop", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "Whether or not this sprite should be looping."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "labels": ["Variable"], "properties": {"simpleName": "builder", "qualifiedName": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The builder object to which key mappings will be added."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "private nl.tudelft.jpacman.ui.Action moveTowardsDirection(nl.tudelft.jpacman.board.Direction direction) {\r\n    return () -> {\r\n        assert this.game != null;\r\n        this.getGame().move(this.getSinglePlayer(this.getGame()), direction);\r\n    };\r\n}", "docComment": "", "metaSrc": "source code", "description": "Creates an action to move a single player in the game board towards a specified direction.", "returns": "A lambda expression that represents an action to move the player.", "reason": "This method provides a way to encapsulate the logic for moving a player in the game board, allowing it to be executed as an action.", "howToUse": "Call this method with the desired direction to create an action that can be executed later.", "howItWorks": "The method creates a lambda expression that checks if the game is not null and then moves the single player in the specified direction using the `move` method of the game.", "assertions": {"preConditions": ["this.game != null"], "postConditions": []}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The square from which to find new targets."}}}, {"data": {"id": "nl", "labels": ["Container"], "properties": {"simpleName": "nl", "qualifiedName": "nl", "kind": "package", "metaSrc": "source code", "description": "Manages game logic, including parsing level maps, creating and moving players, handling user input, and providing actions to move players towards specified directions.", "title": "Game Logic Manager", "keywords": ["game", "logic", "level", "maps", "players", "input", "actions"], "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The way to format the score information.\r\n */\r\nprivate nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter = nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER;", "visibility": "private", "simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "randomMove()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "kind": "method", "sourceText": "/**\r\n * Determines a possible move in a random direction.\r\n *\r\n * @return A direction in which the ghost can move, or <code>null</code> if\r\nthe ghost is shut in by inaccessible squares.\r\n */\r\nprotected nl.tudelft.jpacman.board.Direction randomMove() {\r\n    nl.tudelft.jpacman.board.Square square = this.getSquare();\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> directions = new java.util.ArrayList<nl.tudelft.jpacman.board.Direction>();\r\n    for (nl.tudelft.jpacman.board.Direction direction : nl.tudelft.jpacman.board.Direction.values()) {\r\n        if (square.getSquareAt(direction).isAccessibleTo(this)) {\r\n            directions.add(direction);\r\n        }\r\n    }\r\n    if (directions.isEmpty()) {\r\n        return null;\r\n    }\r\n    int i = new java.util.Random().nextInt(directions.size());\r\n    return directions.get(i);\r\n}", "docComment": "Determines a possible move in a random direction.\r\n\r\n@return A direction in which the ghost can move, or <code>null</code> if\r\nthe ghost is shut in by inaccessible squares.\r\n", "metaSrc": "source code", "description": "Returns a random accessible direction for the ghost to move.", "returns": "A Direction object representing the chosen random accessible direction.", "reason": "The method provides a way for ghosts to navigate the game board by choosing a random direction that allows them to access an adjacent square.", "howToUse": "Call the method on an instance of a Ghost class to get a random accessible direction.", "howItWorks": "The method first retrieves the current square of the ghost. It then iterates over all possible directions and checks if each direction leads to an accessible square for the ghost. If no accessible squares are found, it returns null. Otherwise, it randomly selects one of the accessible directions and returns it.", "assertions": {"preConditions": ["The method is called on a valid instance of a Ghost class."], "postConditions": ["The returned Direction object represents a random accessible direction for the ghost to move."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The index of the current frame.\r\n */\r\nprivate int current;", "visibility": "private", "simpleName": "current", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap", "labels": ["Structure"], "properties": {"docComment": "A table containing all (relevant) collisions between different types of\r\nunits.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "CollisionMap", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap", "kind": "interface", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "Handles collision detection between units in the Pacman game, managing interactions and updates based on collisions.", "keywords": ["collision", "unit", "game", "interaction"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is colliding."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation ID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The background colour of the board.\r\n */\r\nprivate static final java.awt.Color BACKGROUND_COLOR = java.awt.Color.BLACK;", "visibility": "private", "simpleName": "BACKGROUND_COLOR", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new board panel that will display the provided game.\r\n *\r\n * @param game\r\n * \t\tThe game to display.\r\n */\r\nBoardPanel(nl.tudelft.jpacman.game.Game game) {\r\n    super();\r\n    assert game != null;\r\n    this.game = game;\r\n    nl.tudelft.jpacman.board.Board board = game.getLevel().getBoard();\r\n    int w = board.getWidth() * nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE;\r\n    int h = board.getHeight() * nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE;\r\n    java.awt.Dimension size = new java.awt.Dimension(w, h);\r\n    this.setMinimumSize(size);\r\n    this.setPreferredSize(size);\r\n}", "docComment": "Creates a new board panel that will display the provided game.\r\n\r\n@param game\r\n\t\tThe game to display.\r\n", "metaSrc": "source code", "description": "Initializes the board panel for displaying the game board.", "returns": "A new BoardPanel instance initialized with the given game.", "reason": "This method sets up the initial state of the board panel by creating a new JPanel, setting its size based on the game's board dimensions, and configuring it for minimum and preferred sizes.", "howToUse": "Create an instance of Game and pass it to the BoardPanel constructor to initialize the board panel with the corresponding game state.", "howItWorks": "The method first checks if the provided game is not null. It then retrieves the board from the current level of the game, calculates its dimensions in pixels, and sets these dimensions as both the minimum and preferred size for the JPanel. This ensures that the panel can display the entire game board.", "assertions": {"preConditions": ["The provided game instance is not null."], "postConditions": ["A new BoardPanel instance is created with the given game.", "The panel's size is set to match the dimensions of the game's board.", "The panel is configured for minimum and preferred sizes."]}, "stereotype": "Creational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createBoard(nl.tudelft.jpacman.board.Square[][])", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "kind": "method", "sourceText": "/**\r\n * Creates a new board from a grid of cells and connects it.\r\n *\r\n * @param grid\r\n * \t\tThe square grid of cells, in which grid[x][y] corresponds to\r\n * \t\tthe square at position x,y.\r\n * @return A new board, wrapping a grid of connected cells.\r\n */\r\npublic nl.tudelft.jpacman.board.Board createBoard(nl.tudelft.jpacman.board.Square[][] grid) {\r\n    assert grid != null;\r\n    nl.tudelft.jpacman.board.Board board = new nl.tudelft.jpacman.board.Board(grid);\r\n    int width = board.getWidth();\r\n    int height = board.getHeight();\r\n    for (int x = 0; x < width; x++) {\r\n        for (int y = 0; y < height; y++) {\r\n            nl.tudelft.jpacman.board.Square square = grid[x][y];\r\n            for (nl.tudelft.jpacman.board.Direction dir : nl.tudelft.jpacman.board.Direction.values()) {\r\n                int dirX = ((width + x) + dir.getDeltaX()) % width;\r\n                int dirY = ((height + y) + dir.getDeltaY()) % height;\r\n                nl.tudelft.jpacman.board.Square neighbour = grid[dirX][dirY];\r\n                square.link(neighbour, dir);\r\n            }\r\n        }\r\n    }\r\n    return board;\r\n}", "docComment": "Creates a new board from a grid of cells and connects it.\r\n\r\n@param grid\r\n\t\tThe square grid of cells, in which grid[x][y] corresponds to\r\n\t\tthe square at position x,y.\r\n@return A new board, wrapping a grid of connected cells.\r\n", "metaSrc": "source code", "description": "Creates a board by linking each square to its neighbors in all directions, wrapping around the edges.", "returns": "A new Board instance with linked squares.", "reason": "This method initializes a board by connecting each square to its neighbors in all directions, ensuring that the game can be played on a toroidal board (wrapping around edges).", "howToUse": "Call this method with a 2D array of Square objects representing the board's layout.", "howItWorks": "The method iterates over each square in the grid and links it to its neighbors in all eight possible directions. It uses modulo arithmetic to wrap around the edges of the board.", "assertions": {"preConditions": ["grid is not null"], "postConditions": ["All squares are linked to their neighbors in all directions."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "squareAt(int,int)", "qualifiedName": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "kind": "method", "sourceText": "/**\r\n * Returns the square at the given <code>x,y</code> position.\r\n *\r\n * Precondition: The <code>(x, y)</code> coordinates are within the\r\n * width and height of the board.\r\n *\r\n * @param x\r\n * \t\tThe <code>x</code> position (column) of the requested square.\r\n * @param y\r\n * \t\tThe <code>y</code> position (row) of the requested square.\r\n * @return The square at the given <code>x,y</code> position (never null).\r\n */\r\npublic nl.tudelft.jpacman.board.Square squareAt(int x, int y) {\r\n    assert this.withinBorders(x, y);\r\n    nl.tudelft.jpacman.board.Square result = this.board[x][y];\r\n    assert result != null : \"Follows from invariant.\";\r\n    return result;\r\n}", "docComment": "Returns the square at the given <code>x,y</code> position.\r\n\r\nPrecondition: The <code>(x, y)</code> coordinates are within the\r\nwidth and height of the board.\r\n\r\n@param x\r\n\t\tThe <code>x</code> position (column) of the requested square.\r\n@param y\r\n\t\tThe <code>y</code> position (row) of the requested square.\r\n@return The square at the given <code>x,y</code> position (never null).\r\n", "metaSrc": "source code", "description": "Returns the square at the specified coordinates on the board, asserting that the coordinates are within bounds.", "returns": "The Square object at the specified coordinates.", "reason": "This method provides a safe way to access squares on the board, ensuring that the coordinates are within valid bounds before attempting to retrieve the square.", "howToUse": "Call this method with the desired x and y coordinates to get the corresponding Square object. Ensure that the coordinates are within the board's boundaries.", "howItWorks": "The method first checks if the given coordinates are within the board's borders using the `withinBorders` method. If they are, it retrieves the square at those coordinates from the `board` array and returns it. The method also includes assertions to ensure that the retrieved square is not null.", "assertions": {"preConditions": ["x and y are within the bounds of the board"], "postConditions": ["the returned Square object is not null"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The service executing the task.\r\n */\r\nprivate final java.util.concurrent.ScheduledExecutorService service;", "visibility": "private", "simpleName": "service", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite", "labels": ["Structure"], "properties": {"docComment": "Empty Sprite which does not contain any data. When this sprite is drawn,\r\nnothing happens.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "EmptySprite", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite", "kind": "class", "metaSrc": "source code", "description": "The EmptySprite class is responsible for representing an empty space in the game grid, providing basic drawing functionality and dimensions.", "keywords": ["empty", "space", "grid", "drawing", "dimensions"], "roleStereotype": "Information Holder"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "labels": ["Variable"], "properties": {"simpleName": "message", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "labels": ["Variable"], "properties": {"simpleName": "baseImage", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The base image to be split into frames."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "squaresAheadOf(int)", "qualifiedName": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "kind": "method", "sourceText": "/**\r\n * A utility method for implementing the ghost AI.\r\n *\r\n * @param amountToLookAhead\r\n * \t\tthe amount of squares to follow this units direction in.\r\n * @return The square amountToLookAhead spaces in front of this unit.\r\n */\r\npublic nl.tudelft.jpacman.board.Square squaresAheadOf(int amountToLookAhead) {\r\n    nl.tudelft.jpacman.board.Direction targetDirection = this.getDirection();\r\n    nl.tudelft.jpacman.board.Square destination = this.getSquare();\r\n    for (int i = 0; i < amountToLookAhead; i++) {\r\n        destination = destination.getSquareAt(targetDirection);\r\n    }\r\n    return destination;\r\n}", "docComment": "A utility method for implementing the ghost AI.\r\n\r\n@param amountToLookAhead\r\n\t\tthe amount of squares to follow this units direction in.\r\n@return The square amountToLookAhead spaces in front of this unit.\r\n", "metaSrc": "source code", "description": "Returns the square that is 'amountToLookAhead' steps ahead in the current direction from the unit's current position.", "returns": "The Square object representing the square that is 'amountToLookAhead' steps ahead in the current direction from the unit's current position.", "reason": "This method provides a way to determine the location of a unit at a future point in time based on its current position and direction.", "howToUse": "Call this method with an integer value representing the number of squares you want to look ahead. The method will return the square that is 'amountToLookAhead' steps ahead from the unit's current position.", "howItWorks": "The method first retrieves the current direction and the current square of the unit. It then iterates 'amountToLookAhead' times, moving one step in the current direction each time, until it reaches the desired destination square.", "preConditions": ["The unit must have a valid square and direction."], "postConditions": ["The returned square is the square that is 'amountToLookAhead' steps ahead of the unit's current position in the current direction."], "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map of directions to sprites for the player."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new task.\r\n *\r\n * @param service\r\n * \t\tThe service that executes the task.\r\n * @param npc\r\n * \t\tThe NPC to move.\r\n */\r\nNpcMoveTask(java.util.concurrent.ScheduledExecutorService service, nl.tudelft.jpacman.npc.Ghost npc) {\r\n    super();\r\n    this.service = service;\r\n    this.npc = npc;\r\n}", "docComment": "Creates a new task.\r\n\r\n@param service\r\n\t\tThe service that executes the task.\r\n@param npc\r\n\t\tThe NPC to move.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void draw(java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    graphics.drawImage(this.image, x, y, x + width, y + height, 0, 0, this.image.getWidth(null), this.image.getHeight(null), null);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "keyMappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new player factory.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite store containing the Pac-Man sprites.\r\n */\r\npublic PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n}", "docComment": "Creates a new player factory.\r\n\r\n@param spriteStore\r\n\t\tThe sprite store containing the Pac-Man sprites.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The way to calculate points upon collisions.\r\n */\r\nprivate final nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The x-coordinate of the top-left corner where the sprite should be drawn."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square", "labels": ["Structure"], "properties": {"docComment": "A square on a {@link Board}, which can (or cannot, depending on the type) be\r\noccupied by units.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Square", "qualifiedName": "nl.tudelft.jpacman.board.Square", "kind": "abstract class", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The abstract class manages the state and behavior of game entities, providing methods to add and remove occupants, put and remove units, link squares, and retrieve information about the square's occupants.", "keywords": ["game", "entity", "state", "behavior", "occupants", "units", "squares"], "roleStereotype": "Structurer"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The point calculator to use for scoring in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit to be moved."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "labels": ["Variable"], "properties": {"simpleName": "map", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A 2D array representing the layout of the game board."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator", "labels": ["Structure"], "properties": {"docComment": "A simple, minimalistic point calculator just\r\nadding points for each pellet consumed.\r\n", "simpleName": "DefaultPointCalculator", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator", "kind": "class", "metaSrc": "source code", "dependencyProfile": "outbound", "description": "The class is responsible for calculating and updating points in the game based on player actions such as consuming pellets and colliding with ghosts.", "keywords": ["point calculator", "game logic", "player score"], "roleStereotype": "Service Provider"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.hasSquare()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "hasSquare()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.hasSquare()", "kind": "method", "sourceText": "/**\r\n * Returns whether this unit is currently on  a square.\r\n *\r\n * @return True iff the unit is occupying a square at the moment.\r\n */\r\npublic boolean hasSquare() {\r\n    return this.square != null;\r\n}", "docComment": "Returns whether this unit is currently on  a square.\r\n\r\n@return True iff the unit is occupying a square at the moment.\r\n", "metaSrc": "source code", "description": "Checks if the unit has a square associated with it.", "returns": "Boolean indicating whether the unit has a square.", "reason": "The method provides a simple way to determine if an object is part of a grid or board, which is essential for many game mechanics in Pacman.", "howToUse": "Call `hasSquare()` on an instance of `Unit` to check if it is associated with a square.", "howItWorks": "The method checks if the `square` field of the unit is not null. If it is not null, the unit has a square; otherwise, it does not.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "map", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The character array representing the game board."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "labels": ["Variable"], "properties": {"sourceText": "private static final int SQUARES_AHEAD = 4;", "visibility": "private", "simpleName": "SQUARES_AHEAD", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new animating sprite that will change frames every interval.\r\n *\r\n * @param frames\r\n * \t\tThe frames of this animation.\r\n * @param delay\r\n * \t\tThe delay between frames.\r\n * @param loop\r\n * \t\tWhether or not this sprite should be looping.\r\n * @param isAnimating\r\n * \t\tWhether or not this sprite is animating from the start.\r\n */\r\npublic AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[] frames, int delay, boolean loop, boolean isAnimating) {\r\n    super();\r\n    assert frames.length > 0;\r\n    this.animationFrames = frames.clone();\r\n    this.animationDelay = delay;\r\n    this.looping = loop;\r\n    this.animating = isAnimating;\r\n    this.current = 0;\r\n    this.lastUpdate = java.lang.System.currentTimeMillis();\r\n}", "docComment": "Creates a new animating sprite that will change frames every interval.\r\n\r\n@param frames\r\n\t\tThe frames of this animation.\r\n@param delay\r\n\t\tThe delay between frames.\r\n@param loop\r\n\t\tWhether or not this sprite should be looping.\r\n@param isAnimating\r\n\t\tWhether or not this sprite is animating from the start.\r\n", "metaSrc": "source code", "description": "Initializes an animated sprite with given frames, delay, looping, and animation status.", "returns": "The newly created AnimatedSprite instance.", "reason": "This method initializes an animated sprite with specified frames, delay, looping behavior, and initial animation state.", "howToUse": "Create a new AnimatedSprite by providing the necessary parameters such as frames, delay, loop setting, and initial animation status.", "howItWorks": "The method sets up the sprite's properties including cloning the frame array, initializing delay, looping flag, and animation status. It also initializes current frame index and last update time.", "assertions": {"preConditions": ["frames.length > 0", "delay >= 0"], "postConditions": ["this.animationFrames == frames.clone()", "this.animationDelay == delay", "this.looping == loop", "this.animating == isAnimating", "this.current == 0", "this.lastUpdate > 0"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The NPC to move.\r\n */\r\nprivate final nl.tudelft.jpacman.npc.Ghost npc;", "visibility": "private", "simpleName": "npc", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "byte", "labels": ["Primitive"], "properties": {"simpleName": "byte", "qualifiedName": "byte", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player consuming the pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "labels": ["Variable"], "properties": {"simpleName": "parent", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The parent JFrame that will receive focus after a button is clicked."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "kind": "method", "sourceText": "/**\r\n * Returns a portion of this sprite as a new Sprite.\r\n *\r\n * @param x\r\n * \t\tThe x start coordinate.\r\n * @param y\r\n * \t\tThe y start coordinate.\r\n * @param width\r\n * \t\tThe width of the target sprite.\r\n * @param height\r\n * \t\tThe height of the target sprite.\r\n * @return A new sprite of width x height, or a new {@link EmptySprite} if\r\nthe region was not in the current sprite.\r\n */\r\nnl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height);", "docComment": "Returns a portion of this sprite as a new Sprite.\r\n\r\n@param x\r\n\t\tThe x start coordinate.\r\n@param y\r\n\t\tThe y start coordinate.\r\n@param width\r\n\t\tThe width of the target sprite.\r\n@param height\r\n\t\tThe height of the target sprite.\r\n@return A new sprite of width x height, or a new {@link EmptySprite} if\r\nthe region was not in the current sprite.\r\n", "metaSrc": "source code", "description": "Splits the sprite into multiple smaller sprites based on given coordinates and dimensions.", "returns": "A new Sprite object representing the smaller sprite.", "reason": "This method allows for the creation of sub-sprites, which can be useful for animations or visual effects in a game.", "howToUse": "Call this method on an instance of a Sprite to create a new Sprite that is a portion of the original sprite. Specify the coordinates and dimensions of the region you want to split.", "howItWorks": "The method creates a new Sprite object by extracting a sub-region from the original sprite's image data based on the provided coordinates and dimensions.", "preConditions": ["The provided x, y, width, and height values must be within the bounds of the original sprite's image."], "postConditions": ["A new Sprite object is returned that represents the sub-region of the original sprite."], "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The handler that handles the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The background for this square.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite background;", "visibility": "private", "simpleName": "background", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 250;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The square on which to search for units."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The pellet that was consumed by the player."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "to", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The target square of the path."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "labels": ["Variable"], "properties": {"simpleName": "keyCode", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The key code associated with the action."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.board.Board.getWidth()", "kind": "method", "sourceText": "/**\r\n * Returns the number of columns.\r\n *\r\n * @return The width of this board.\r\n */\r\npublic int getWidth() {\r\n    return this.board.length;\r\n}", "docComment": "Returns the number of columns.\r\n\r\n@return The width of this board.\r\n", "metaSrc": "source code", "description": "Returns the width of the board.", "returns": "The width of the board as an integer.", "reason": "This method provides a simple way to access the width of the game board, which is essential for determining the layout and placement of game elements.", "howToUse": "To use this method, simply call it on an instance of the Board class.", "howItWorks": "The method returns the length of the board array, which represents the number of columns in the grid.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel", "labels": ["Structure"], "properties": {"docComment": "A panel containing a button for every registered action.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "ButtonPanel", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel", "kind": "class", "metaSrc": "source code", "dependencyProfile": "hidden", "description": "The ButtonPanel class is responsible for creating and managing a user interface in the Pacman game, including buttons that perform actions and focus the parent window.", "keywords": ["ButtonPanel", "Pacman", "UI", "ActionListener", "JFrame"], "roleStereotype": "User Interfacer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.alive", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> iff this player is alive.\r\n */\r\nprivate boolean alive;", "visibility": "private", "simpleName": "alive", "qualifiedName": "nl.tudelft.jpacman.level.Player.alive", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getGroundSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The sprite for the ground.\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite getGroundSprite() {\r\n    return this.loadSprite(\"/sprite/floor.png\");\r\n}", "docComment": "\r\n@return The sprite for the ground.\r\n", "metaSrc": "source code", "description": "Loads a floor sprite from a resource file and returns it as an ImageSprite.", "returns": "A new ImageSprite representing the loaded or cached floor sprite.", "reason": "The method provides a convenient way to access the floor sprite used in the Pacman game, ensuring that the sprite is loaded efficiently and reused if already present.", "howToUse": "Call `getGroundSprite()` to retrieve the floor sprite. This method should be called when rendering the game board or any other area where the floor needs to be displayed.", "howItWorks": "The method uses the `loadSprite` method from the superclass to load the floor sprite from a resource file. If the sprite is not already cached, it will be loaded and cached for future use.", "assertions": {"preConditions": [], "postConditions": ["The returned object is an instance of ImageSprite."]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The main game instance to be displayed."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "registerPlayer(nl.tudelft.jpacman.level.Player)", "qualifiedName": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "kind": "method", "sourceText": "/**\r\n * Registers a player on this level, assigning him to a starting position. A\r\n * player can only be registered once, registering a player again will have\r\n * no effect.\r\n *\r\n * @param player\r\n * \t\tThe player to register.\r\n */\r\npublic void registerPlayer(nl.tudelft.jpacman.level.Player player) {\r\n    assert player != null;\r\n    assert !this.startSquares.isEmpty();\r\n    if (this.players.contains(player)) {\r\n        return;\r\n    }\r\n    this.players.add(player);\r\n    nl.tudelft.jpacman.board.Square square = this.startSquares.get(this.startSquareIndex);\r\n    player.occupy(square);\r\n    this.startSquareIndex++;\r\n    this.startSquareIndex %= this.startSquares.size();\r\n}", "docComment": "Registers a player on this level, assigning him to a starting position. A\r\nplayer can only be registered once, registering a player again will have\r\nno effect.\r\n\r\n@param player\r\n\t\tThe player to register.\r\n", "metaSrc": "source code", "description": "Registers a player on the level, assigns them to a start square, and updates the game state.", "returns": "", "reason": "This method manages the registration of players on a game level, ensuring they are assigned to start squares and updated in the game state.", "howToUse": "Call this method with an instance of Player to register them on the current level. Ensure that the player is not null and that there are available start squares before calling this method.", "howItWorks": "The method first checks if the player is already registered, returning early if so. It then assigns the player to a start square from the list of available start squares, updates the game state by occupying the square, and increments the index for the next start square. The index wraps around using modulo arithmetic.", "assertions": {"preConditions": ["player != null", "!this.startSquares.isEmpty()"], "postConditions": ["this.players.contains(player)", "player is occupied by a square in this.level"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new UI for a JPacman game.\r\n *\r\n * @param game\r\n * \t\tThe game to play.\r\n * @param buttons\r\n * \t\tThe map of caption-to-action entries that will appear as\r\n * \t\tbuttons on the interface.\r\n * @param keyMappings\r\n * \t\tThe map of keyCode-to-action entries that will be added as key\r\n * \t\tlisteners to the interface.\r\n * @param scoreFormatter\r\n * \t\tThe formatter used to display the current score.\r\n */\r\npublic PacManUI(final nl.tudelft.jpacman.game.Game game, final java.util.Map<java.lang.String, nl.tudelft.jpacman.ui.Action> buttons, final java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> keyMappings, nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter) {\r\n    super(\"JPacman\");\r\n    assert game != null;\r\n    assert buttons != null;\r\n    assert keyMappings != null;\r\n    this.setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\r\n    nl.tudelft.jpacman.ui.PacKeyListener keys = new nl.tudelft.jpacman.ui.PacKeyListener(keyMappings);\r\n    this.addKeyListener(keys);\r\n    javax.swing.JPanel buttonPanel = new nl.tudelft.jpacman.ui.ButtonPanel(buttons, this);\r\n    this.scorePanel = new nl.tudelft.jpacman.ui.ScorePanel(game.getPlayers());\r\n    if (scoreFormatter != null) {\r\n        this.scorePanel.setScoreFormatter(scoreFormatter);\r\n    }\r\n    this.boardPanel = new nl.tudelft.jpacman.ui.BoardPanel(game);\r\n    java.awt.Container contentPanel = this.getContentPane();\r\n    contentPanel.setLayout(new java.awt.BorderLayout());\r\n    contentPanel.add(buttonPanel, java.awt.BorderLayout.SOUTH);\r\n    contentPanel.add(this.scorePanel, java.awt.BorderLayout.NORTH);\r\n    contentPanel.add(this.boardPanel, java.awt.BorderLayout.CENTER);\r\n    this.pack();\r\n}", "docComment": "Creates a new UI for a JPacman game.\r\n\r\n@param game\r\n\t\tThe game to play.\r\n@param buttons\r\n\t\tThe map of caption-to-action entries that will appear as\r\n\t\tbuttons on the interface.\r\n@param keyMappings\r\n\t\tThe map of keyCode-to-action entries that will be added as key\r\n\t\tlisteners to the interface.\r\n@param scoreFormatter\r\n\t\tThe formatter used to display the current score.\r\n", "metaSrc": "source code", "description": "Initializes the PacMan user interface by setting up game components and listeners.", "returns": "The initialized PacManUI instance.", "reason": "This method sets up the user interface components and listeners required to run a PacMan game, including buttons, key mappings, and a score panel.", "howToUse": "Create an instance of PacManUI by passing the necessary game, button, and key mapping configurations. Optionally, provide a score formatter for customizing score display.", "howItWorks": "The method initializes the window with a title 'JPacman', sets up key listeners based on the provided mappings, creates panels for buttons, score, and board, and arranges them in a BorderLayout layout.", "assertions": {"preConditions": ["game is not null", "buttons is not null", "keyMappings is not null"], "postConditions": ["PacManUI instance is created with all necessary components and listeners set up."]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "keyTyped(java.awt.event.KeyEvent)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void keyTyped(java.awt.event.KeyEvent event) {\r\n    // do nothing\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic boolean isAccessibleTo(nl.tudelft.jpacman.board.Unit unit) {\r\n    return true;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.opposite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "opposite()", "qualifiedName": "nl.tudelft.jpacman.board.Direction.opposite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The direction that is opposite to this direction.\r\n */\r\npublic nl.tudelft.jpacman.board.Direction opposite() {\r\n    switch (this) {\r\n        case NORTH :\r\n            return nl.tudelft.jpacman.board.Direction.SOUTH;\r\n        case SOUTH :\r\n            return nl.tudelft.jpacman.board.Direction.NORTH;\r\n        case WEST :\r\n            return nl.tudelft.jpacman.board.Direction.EAST;\r\n        case EAST :\r\n            return nl.tudelft.jpacman.board.Direction.WEST;\r\n        default :\r\n            throw new java.lang.IllegalStateException(\"Received an unknown enum value.\");\r\n    }\r\n}", "docComment": "\r\n@return The direction that is opposite to this direction.\r\n", "metaSrc": "source code", "description": "Returns the opposite direction of the current direction in the Pacman game.", "returns": "The opposite Direction enum value", "reason": "Provides a convenient way to get the opposite direction for navigation in the Pacman game.", "howToUse": "Call `opposite()` on an instance of `Direction` to get its opposite.", "howItWorks": "Uses a switch statement to return the opposite direction based on the current direction.", "assertions": {"preConditions": ["The input is a valid Direction enum value"], "postConditions": ["The returned value is also a valid Direction enum value"]}, "stereotype": "Accessor", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "from", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The starting square of the path."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "labels": ["Operation"], "properties": {"visibility": "default", "simpleName": "createGhost()", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "kind": "method", "sourceText": "/**\r\n * Creates a new ghost.\r\n *\r\n * @return The new ghost.\r\n */\r\nnl.tudelft.jpacman.npc.Ghost createGhost() {\r\n    this.ghostIndex++;\r\n    this.ghostIndex %= nl.tudelft.jpacman.level.LevelFactory.GHOSTS;\r\n    switch (this.ghostIndex) {\r\n        case nl.tudelft.jpacman.level.LevelFactory.BLINKY :\r\n            return this.ghostFact.createBlinky();\r\n        case nl.tudelft.jpacman.level.LevelFactory.INKY :\r\n            return this.ghostFact.createInky();\r\n        case nl.tudelft.jpacman.level.LevelFactory.PINKY :\r\n            return this.ghostFact.createPinky();\r\n        case nl.tudelft.jpacman.level.LevelFactory.CLYDE :\r\n            return this.ghostFact.createClyde();\r\n        default :\r\n            return new nl.tudelft.jpacman.level.LevelFactory.RandomGhost(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.RED));\r\n    }\r\n}", "docComment": "Creates a new ghost.\r\n\r\n@return The new ghost.\r\n", "metaSrc": "source code", "description": "Creates a new ghost instance based on the current index and returns it.", "returns": "An instance of a Ghost class.", "reason": "The method generates different ghosts in sequence, cycling through predefined types.", "howToUse": "Call this method to get the next ghost in the sequence.", "howItWorks": "Increments the ghost index, wraps around if necessary, and returns the corresponding ghost based on the index.", "assertions": {"preConditions": ["The ghostFact object is initialized.", "The sprites object has a valid sprite for each ghost color."], "postConditions": ["Returns an instance of a Ghost class."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Handles this collision by flipping the collider and collidee, making\r\n * it compatible with the initial collision.\r\n */\r\n@java.lang.Override\r\npublic void handleCollision(C1 collider, C2 collidee) {\r\n    this.handler.handleCollision(collidee, collider);\r\n}", "docComment": "Handles this collision by flipping the collider and collidee, making\r\nit compatible with the initial collision.\r\n", "metaSrc": "source code", "description": "Handles collisions between units in the Pacman game by delegating to another handler.", "returns": "", "reason": "This method provides a way to handle collisions between units in the Pacman game by delegating the actual collision handling logic to another handler.", "howToUse": "Call this method with two `Unit` objects as arguments. The first argument is the collider, and the second argument is the collidee.", "howItWorks": "The method simply calls the `handleCollision` method of the stored handler object, passing the collidee and collider as arguments.", "assertions": {"preConditions": ["Both collider and collidee are valid instances of nl.tudelft.jpacman.board.Unit."], "postConditions": ["The collision handling logic is delegated to the stored handler."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "npc", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createPacMan()", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "kind": "method", "sourceText": "/**\r\n * Creates a new player with the classic Pac-Man sprites.\r\n *\r\n * @return A new player.\r\n */\r\npublic nl.tudelft.jpacman.level.Player createPacMan() {\r\n    return new nl.tudelft.jpacman.level.Player(this.getSprites().getPacmanSprites(), this.getSprites().getPacManDeathAnimation());\r\n}", "docComment": "Creates a new player with the classic Pac-Man sprites.\r\n\r\n@return A new player.\r\n", "metaSrc": "source code", "description": "Creates a new PacMan player instance using the specified sprites and death animation.", "returns": "A new Player instance representing PacMan.", "reason": "The method is responsible for initializing the PacMan character in the game, providing both its visual representation and its death animation.", "howToUse": "Call this method to create a new PacMan player object. It requires that the `getSprites()` and `getPacManDeathAnimation()` methods are properly implemented to provide the necessary resources for the player.", "howItWorks": "The method constructs a new Player instance by passing the PacMan sprites and death animation to its constructor. This setup allows the game to render PacMan correctly and handle his death animations as needed.", "assertions": {"preConditions": ["The `getSprites()` method must return a valid PacManSprites object containing all necessary sprites.", "The `getPacManDeathAnimation()` method must return an AnimatedSprite representing Pac-Man's death animation."], "postConditions": ["A new Player instance is created with the specified sprites and death animation."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic boolean isAccessibleTo(nl.tudelft.jpacman.board.Unit unit) {\r\n    return false;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPlayers()", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic java.util.List<nl.tudelft.jpacman.level.Player> getPlayers() {\r\n    return com.google.common.collect.ImmutableList.of(this.player);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "labels": ["Variable"], "properties": {"simpleName": "levelFactory", "qualifiedName": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The animation itself, in frames.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite[] animationFrames;", "visibility": "private", "simpleName": "animationFrames", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "players", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate of the top-left corner of the sub-image."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost", "labels": ["Structure"], "properties": {"docComment": "A non-player unit.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Ghost", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost", "kind": "abstract class", "metaSrc": "source code", "dependencyProfile": "transit", "description": "The abstract class `nl.tudelft.jpacman.npc.Ghost` is responsible for managing the behavior and movement of ghosts in a Pacman game. It provides methods to initialize, calculate intervals, retrieve sprites, determine AI moves, and choose random directions. These responsibilities are fulfilled by various methods within the class.", "keywords": ["initialize", "calculate interval", "retrieve sprite", "determine ai move", "choose random direction"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Method called whevener a player makes a successful move.\r\n * It can be used to update the player's points accordingly.\r\n *\r\n * @param player\r\n * \t\tThe player making a move.\r\n * @param direction\r\n * \t\tThe direction of the move.\r\n */\r\nvoid pacmanMoved(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Direction direction);", "docComment": "Method called whevener a player makes a successful move.\r\nIt can be used to update the player's points accordingly.\r\n\r\n@param player\r\n\t\tThe player making a move.\r\n@param direction\r\n\t\tThe direction of the move.\r\n", "metaSrc": "source code", "description": "Calculates points for a player based on their movement in the game.", "returns": "void", "reason": "This method is part of the point calculation logic for a Pacman game, updating the player's score based on their movement.", "howToUse": "Call this method whenever a player moves in the game. Provide the player object and the direction they moved as arguments.", "howItWorks": "The method checks the direction of the move and updates the player's score accordingly. It may also trigger other point-related calculations or effects based on the movement.", "assertions": {"preConditions": ["The player object is not null.", "The direction object is not null."], "postConditions": ["The player's score has been updated based on their move.", "Additional point-related calculations or effects may have been triggered."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.occupants", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The units occupying this square, in order of appearance.\r\n */\r\nprivate final java.util.List<nl.tudelft.jpacman.board.Unit> occupants;", "visibility": "private", "simpleName": "occupants", "qualifiedName": "nl.tudelft.jpacman.board.Square.occupants", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "restart()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "kind": "method", "sourceText": "/**\r\n * (Re)starts the current animation.\r\n */\r\npublic void restart() {\r\n    this.current = 0;\r\n    this.lastUpdate = java.lang.System.currentTimeMillis();\r\n    this.setAnimating(true);\r\n}", "docComment": "(Re)starts the current animation.\r\n", "metaSrc": "source code", "description": "Resets the animated sprite to its initial state by setting current frame to 0, last update time to current system time, and starting animation.", "returns": "", "reason": "The method resets the animated sprite's state to ensure it starts from the beginning of its animation sequence.", "howToUse": "Call `restart()` on an instance of `AnimatedSprite` to reset its animation.", "howItWorks": "Sets current frame to 0, updates last update time to current system time, and calls setAnimating(true) to start the animation.", "assertions": {"preConditions": [], "postConditions": ["current frame is set to 0", "last update time is updated to current system time", "animation is started"]}, "stereotype": "Mutator", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height) {\r\n    this.update();\r\n    return this.currentSprite().split(x, y, width, height);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Splits the current animated sprite into a smaller sprite based on given coordinates and dimensions.", "returns": "A new Sprite object representing the smaller sprite.", "reason": "This method allows for the dynamic splitting of an animated sprite into smaller parts, which can be useful for creating more complex visual effects or for implementing game mechanics like zooming in on specific areas of a sprite.", "howToUse": "Call this method with appropriate coordinates and dimensions to split the current animated sprite. The returned object will represent the new smaller sprite.", "howItWorks": "The method first updates the animation state of the sprite using `update()`. It then calls the `split()` method on the current sprite, passing the provided coordinates and dimensions. This results in a new Sprite object that represents the portion of the original sprite defined by the given parameters.", "preConditions": ["The animated sprite must be initialized and have at least one frame available."], "postConditions": ["A new Sprite object representing the smaller part of the current animated sprite is returned.", "If the specified region is not within the current sprite, an EmptySprite may be returned instead."], "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "qualifiedName": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new player with a score of 0 points.\r\n *\r\n * @param spriteMap\r\n * \t\tA map containing a sprite for this player for every direction.\r\n * @param deathAnimation\r\n * \t\tThe sprite to be shown when this player dies.\r\n */\r\nprotected Player(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap, nl.tudelft.jpacman.sprite.AnimatedSprite deathAnimation) {\r\n    super();\r\n    this.score = 0;\r\n    this.alive = true;\r\n    this.sprites = spriteMap;\r\n    this.deathSprite = deathAnimation;\r\n    this.deathSprite.setAnimating(false);\r\n}", "docComment": "Creates a new player with a score of 0 points.\r\n\r\n@param spriteMap\r\n\t\tA map containing a sprite for this player for every direction.\r\n@param deathAnimation\r\n\t\tThe sprite to be shown when this player dies.\r\n", "metaSrc": "source code", "description": "Initializes a player with sprite mappings and a death animation, setting the death sprite to non-animating.", "returns": "A newly created Player instance.", "reason": "This method initializes a new player object with its properties set, including sprite mappings and a death animation.", "howToUse": "Create a new Player instance by providing a map of directions to sprites and an animated sprite for the death animation.", "howItWorks": "The constructor sets up the player's score, alive status, sprite mappings, death sprite, and initializes the death sprite to non-animating.", "assertions": {"preConditions": ["spriteMap is not null", "deathAnimation is not null"], "postConditions": ["Player instance is created with initialized properties", "Death sprite is set to non-animating"]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Map of buttons and their actions.\r\n */\r\nprivate final java.util.Map<java.lang.String, nl.tudelft.jpacman.ui.Action> buttons;", "visibility": "private", "simpleName": "buttons", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "labels": ["Variable"], "properties": {"simpleName": "cause", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "short", "labels": ["Primitive"], "properties": {"simpleName": "short", "qualifiedName": "short", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder", "labels": ["Structure"], "properties": {"docComment": "Builder for the JPac-Man UI.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacManUiBuilder", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder", "kind": "class", "metaSrc": "source code", "dependencyProfile": "inbound", "description": "The class is responsible for building and configuring the user interface for a PacMan game, including adding start and stop buttons if specified. It also provides methods to set default buttons and provide a formatter for the score.", "keywords": ["PacMan", "UI builder", "start button", "stop button", "default buttons", "score formatter"], "roleStereotype": "Controller"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game to build the UI for."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * Clyde has two basic AIs, one for when he's far from Pac-Man, and one for\r\n * when he is near to Pac-Man.\r\n * When Clyde is far away from Pac-Man (beyond eight grid spaces),\r\n * Clyde behaves very much like Blinky, trying to move to Pac-Man's exact\r\n * location. However, when Clyde gets within eight grid spaces of Pac-Man,\r\n * he automatically changes his behavior and runs away\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    nl.tudelft.jpacman.board.Unit nearest = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if (nearest == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert nearest.hasSquare();\r\n    nl.tudelft.jpacman.board.Square target = nearest.getSquare();\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), target, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        nl.tudelft.jpacman.board.Direction direction = path.get(0);\r\n        if (path.size() <= nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS) {\r\n            return java.util.Optional.of(direction.opposite());\r\n        }\r\n        return java.util.Optional.of(direction);\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nClyde has two basic AIs, one for when he's far from Pac-Man, and one for\r\nwhen he is near to Pac-Man. \r\nWhen Clyde is far away from Pac-Man (beyond eight grid spaces),\r\nClyde behaves very much like Blinky, trying to move to Pac-Man's exact\r\nlocation. However, when Clyde gets within eight grid spaces of Pac-Man,\r\nhe automatically changes his behavior and runs away\r\n</p>\r\n", "metaSrc": "source code", "description": "Determines the next move for Clyde based on the nearest player and navigates to them, avoiding shyness if necessary.", "returns": "Optional<Direction>", "reason": "The method implements a strategy for Clyde's AI behavior in Pacman, which involves finding the nearest player and navigating towards them while considering Clyde's shyness level.", "howToUse": "Call nextAiMove() to get the next direction Clyde should move based on its current state and the game board.", "howItWorks": "The method first checks if Clyde has a square. It then finds the nearest player using Navigation.findNearest(). If no player is found, it returns an empty Optional. Otherwise, it calculates the shortest path to the player using Navigation.shortestPath() and determines the next direction based on the path length and Clyde's shyness level.", "assertions": {"preConditions": ["Clyde has a square", "The game board is initialized"], "postConditions": ["Returns an Optional<Direction> representing Clyde's next move"]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The number of frames in the animation."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "labels": ["Variable"], "properties": {"simpleName": "observer", "qualifiedName": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "kind": "method", "sourceText": "/**\r\n * Parses the list of strings into a 2-dimensional character array and\r\n * passes it on to {@link #parseMap(char[][])}.\r\n *\r\n * @param text\r\n * \t\tThe plain text, with every entry in the list being a equally\r\n * \t\tsized row of squares on the board and the first element being\r\n * \t\tthe top row.\r\n * @return The level as represented by the text.\r\n * @throws PacmanConfigurationException\r\n * \t\tIf text lines are not properly formatted.\r\n */\r\npublic nl.tudelft.jpacman.level.Level parseMap(java.util.List<java.lang.String> text) {\r\n    this.checkMapFormat(text);\r\n    int height = text.size();\r\n    int width = text.get(0).length();\r\n    char[][] map = new char[width][height];\r\n    for (int x = 0; x < width; x++) {\r\n        for (int y = 0; y < height; y++) {\r\n            map[x][y] = text.get(y).charAt(x);\r\n        }\r\n    }\r\n    return this.parseMap(map);\r\n}", "docComment": "Parses the list of strings into a 2-dimensional character array and\r\npasses it on to {@link #parseMap(char[][])}.\r\n\r\n@param text\r\n\t\tThe plain text, with every entry in the list being a equally\r\n\t\tsized row of squares on the board and the first element being\r\n\t\tthe top row.\r\n@return The level as represented by the text.\r\n@throws PacmanConfigurationException\r\n\t\tIf text lines are not properly formatted.\r\n", "metaSrc": "source code", "description": "Parses a text representation of a Pacman game map into an actual level by creating a grid of squares and initializing ghosts and start positions.", "returns": "An instance of nl.tudelft.jpacman.level.Level.", "reason": "The method parses a text representation of a Pacman game map into an actual level by creating a grid of squares and initializing ghosts and start positions.", "howToUse": "Call the parseMap method with a list of strings representing the rows of the map.", "howItWorks": "The method first checks if the input text is valid for parsing as a map. It then creates a character array from the input text, where each element represents a square in the grid. The method initializes the level by calling the parseMap method with the character array.", "assertions": {"preConditions": ["The input text must be a list of strings representing the rows of the map.", "Each string in the list must have the same length."], "postConditions": ["The returned level is an instance of nl.tudelft.jpacman.level.Level."]}, "stereotype": "Collaborational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The ghost causing the player to die."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player who consumed the pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getLevelFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the sprites from {@link #getSpriteStore()}\r\nand the ghosts from {@link #getGhostFactory()}.\r\n */\r\nprotected nl.tudelft.jpacman.level.LevelFactory getLevelFactory() {\r\n    return new nl.tudelft.jpacman.level.LevelFactory(this.getSpriteStore(), this.getGhostFactory(), this.loadPointCalculator());\r\n}", "docComment": "\r\n@return A new factory using the sprites from {@link #getSpriteStore()}\r\nand the ghosts from {@link #getGhostFactory()}.\r\n", "metaSrc": "source code", "description": "Returns a LevelFactory instance initialized with the current SpriteStore, GhostFactory, and PointCalculator.", "returns": "Nl.tudelft.jpacman.level.LevelFactory", "reason": "The method initializes a LevelFactory using the necessary components to create game levels dynamically.", "howToUse": "Call this method from within the Launcher class to obtain a LevelFactory instance.", "howItWorks": "The method creates a new LevelFactory by passing the SpriteStore, GhostFactory, and PointCalculator instances to its constructor.", "assertions": {"preConditions": [], "postConditions": []}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Whether this sprite is currently animating or not.\r\n */\r\nprivate boolean animating;", "visibility": "private", "simpleName": "animating", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withDefaultButtons()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "kind": "method", "sourceText": "/**\r\n * Adds a start and stop button to the UI. The actual actions for these\r\n * buttons will be added upon building the UI.\r\n *\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder withDefaultButtons() {\r\n    this.defaultButtons = true;\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION, null);\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION, null);\r\n    return this;\r\n}", "docComment": "Adds a start and stop button to the UI. The actual actions for these\r\nbuttons will be added upon building the UI.\r\n\r\n@return The builder.\r\n", "metaSrc": "source code", "description": "Sets default buttons for the PacMan UI builder.", "returns": "The updated PacManUiBuilder instance.", "reason": "Provides a convenient way to configure the UI with default start and stop buttons.", "howToUse": "Call `withDefaultButtons()` on an instance of PacManUiBuilder to enable default buttons in the UI.", "howItWorks": "Sets the 'defaultButtons' flag to true and adds entries for 'START_CAPTION' and 'STOP_CAPTION' with null values to the 'buttons' map.", "assertions": {"preConditions": ["An instance of PacManUiBuilder is created."], "postConditions": ["The 'defaultButtons' flag is set to true.", "'buttons' contains entries for 'START_CAPTION' and 'STOP_CAPTION'."]}, "stereotype": "Accessor", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "kind": "method", "sourceText": "/**\r\n * Creates a new level from the provided data.\r\n *\r\n * @param board\r\n * \t\tThe board with all ghosts and pellets occupying their squares.\r\n * @param ghosts\r\n * \t\tA list of all ghosts on the board.\r\n * @param startPositions\r\n * \t\tA list of squares from which players may start the game.\r\n * @return A new level for the board.\r\n */\r\npublic nl.tudelft.jpacman.level.Level createLevel(nl.tudelft.jpacman.board.Board board, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions) {\r\n    // We'll adopt the simple collision map for now.\r\n    nl.tudelft.jpacman.level.CollisionMap collisionMap = new nl.tudelft.jpacman.level.PlayerCollisions(this.pointCalculator);\r\n    return new nl.tudelft.jpacman.level.Level(board, ghosts, startPositions, collisionMap);\r\n}", "docComment": "Creates a new level from the provided data.\r\n\r\n@param board\r\n\t\tThe board with all ghosts and pellets occupying their squares.\r\n@param ghosts\r\n\t\tA list of all ghosts on the board.\r\n@param startPositions\r\n\t\tA list of squares from which players may start the game.\r\n@return A new level for the board.\r\n", "metaSrc": "source code", "description": "Creates a new level for the Pacman game by initializing a collision map and returning a Level instance.", "returns": "An instance of nl.tudelft.jpacman.level.Level.", "reason": "This method is responsible for creating a new game level by initializing necessary components such as collision detection and setting up the board, ghosts, and starting positions.", "howToUse": "To use this method, you need to provide a Board object, a list of Ghost objects, and a list of Square objects representing the starting positions. The method will return a Level instance that can be used to start playing the game.", "howItWorks": "The method creates a new CollisionMap using the PointCalculator from the level factory. It then uses this collision map along with the provided board, ghosts, and start positions to create a new Level object.", "assertions": {"preConditions": ["The provided board must be valid and not null.", "The list of ghosts must contain at least one ghost.", "The list of startPositions must contain at least two squares: one for the player and one for another entity."], "postConditions": ["A new Level instance is returned with the specified components.", "The collision map is correctly initialized to handle collisions between entities on the board."]}, "stereotype": "Creational", "layer": "Logic"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "kind": "method", "sourceText": "/**\r\n * Renders the board on the given graphics context to the given dimensions.\r\n *\r\n * @param board\r\n * \t\tThe board to render.\r\n * @param graphics\r\n * \t\tThe graphics context to draw on.\r\n * @param window\r\n * \t\tThe dimensions to scale the rendered board to.\r\n */\r\nprivate void render(nl.tudelft.jpacman.board.Board board, java.awt.Graphics graphics, java.awt.Dimension window) {\r\n    int cellW = window.width / board.getWidth();\r\n    int cellH = window.height / board.getHeight();\r\n    graphics.setColor(nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR);\r\n    graphics.fillRect(0, 0, window.width, window.height);\r\n    for (int y = 0; y < board.getHeight(); y++) {\r\n        for (int x = 0; x < board.getWidth(); x++) {\r\n            int cellX = x * cellW;\r\n            int cellY = y * cellH;\r\n            nl.tudelft.jpacman.board.Square square = board.squareAt(x, y);\r\n            this.render(square, graphics, cellX, cellY, cellW, cellH);\r\n        }\r\n    }\r\n}", "docComment": "Renders the board on the given graphics context to the given dimensions.\r\n\r\n@param board\r\n\t\tThe board to render.\r\n@param graphics\r\n\t\tThe graphics context to draw on.\r\n@param window\r\n\t\tThe dimensions to scale the rendered board to.\r\n", "metaSrc": "source code", "description": "Renders the game board by drawing each square and its occupants on the screen.", "returns": "Void.", "reason": "This method is responsible for drawing the game board and its contents on the screen, providing a visual representation of the game state.", "howToUse": "Call this method with an instance of `nl.tudelft.jpacman.board.Board`, a `java.awt.Graphics` object, and a `java.awt.Dimension` representing the window size to render the game board.", "howItWorks": "The method calculates the width and height of each cell on the board based on the window dimensions. It then fills the background with a specified color and iterates over each square in the board, rendering it using the `renderSquare` method.", "assertions": {"preConditions": ["The provided `board` is not null.", "The provided `graphics` object is not null.", "The provided `window` dimensions are valid."], "postConditions": ["The game board is rendered on the screen using the specified graphics context and window dimensions."]}, "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "start", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The starting square from which to begin following the path."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite files are vertically stacked series for each direction, this\r\n * array denotes the order.\r\n */\r\nprivate static final nl.tudelft.jpacman.board.Direction[] DIRECTIONS = new nl.tudelft.jpacman.board.Direction[]{ nl.tudelft.jpacman.board.Direction.NORTH, nl.tudelft.jpacman.board.Direction.EAST, nl.tudelft.jpacman.board.Direction.SOUTH, nl.tudelft.jpacman.board.Direction.WEST };", "visibility": "private", "simpleName": "DIRECTIONS", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "killer", "qualifiedName": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that will be set as the killer."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void draw(java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    this.update();\r\n    this.currentSprite().draw(graphics, x, y, width, height);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Draws the current animated sprite at the specified position on the given graphics context.", "returns": "Void", "reason": "This method is responsible for rendering the animated sprite on the screen.", "howToUse": "Call this method with a valid Graphics object and the desired position and size to render the current frame of the animated sprite.", "howItWorks": "The method first updates the animation state by calling `update()`, then it retrieves the current sprite using `currentSprite()` and draws it at the specified position on the given graphics context.", "preConditions": ["A valid Graphics object is provided.", "The x, y, width, and height parameters are within the bounds of the screen."], "postConditions": ["The current frame of the animated sprite is drawn at the specified position on the given graphics context."], "stereotype": "Collaborational", "layer": "UI"}}}, {"data": {"id": "layer:UI", "labels": ["Grouping"], "properties": {"kind": "architectural layer", "simpleName": "UI", "qualifiedName": "UI", "description": "Handles user interface, such as instatiating, setting properties of, or laying out widget objects and capturing user interactions.", "layerOrder": 0}}}, {"data": {"id": "layer:Logic", "labels": ["Grouping"], "properties": {"kind": "architectural layer", "simpleName": "Logic", "qualifiedName": "Logic", "description": "Handles application and domain logic, i.e., neither UI nor data access.", "layerOrder": 1}}}, {"data": {"id": "layer:Data", "labels": ["Grouping"], "properties": {"kind": "architectural layer", "simpleName": "Data", "qualifiedName": "Data", "description": "Handles data access, e.g., managing database connections, querying databases, reading/writing files, and invoking web services.", "layerOrder": 2}}}], "edges": [{"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Inky", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Inky", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-returnType-boolean", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)-returnType-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)-returnType-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaY()-returnType-int", "source": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)-returnType-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGame()-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.getGame()", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()-returnType-boolean", "source": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSquare()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.getSquare()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)-returnType-java.lang.String", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "target": "java.lang.String", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)-returnType-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-returnType-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.level.MapParser", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-returnType-boolean", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getDirection()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Unit.getDirection()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)-returnType-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()-returnType-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)-returnType-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-returnType-boolean", "source": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Pellet.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()-returnType-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)-returnType-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "target": "nl.tudelft.jpacman.Launcher", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()-returnType-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-returnType-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)-returnType-nl.tudelft.jpacman.ui.PacKeyListener", "source": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "target": "nl.tudelft.jpacman.ui.PacKeyListener", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()-returnType-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()-returnType-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-returnType-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-returnType-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-returnType-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite()-returnType-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite()", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getScore()-returnType-int", "source": "nl.tudelft.jpacman.level.Player.getScore()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-returnType-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.opposite()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.opposite()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getKiller()-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player.getKiller()", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder()-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getValue()-returnType-int", "source": "nl.tudelft.jpacman.level.Pellet.getValue()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.invariant()-returnType-boolean", "source": "nl.tudelft.jpacman.board.Unit.invariant()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.game.SinglePlayerGame", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)-returnType-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)-returnType-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-returnType-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.ui.Action", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap()-returnType-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.level.PlayerCollisions", "source": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.PlayerCollisions", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-returnType-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.Square.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)-returnType-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-returnType-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()-returnType-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore()-returnType-nl.tudelft.jpacman.sprite.SpriteStore", "source": "nl.tudelft.jpacman.sprite.SpriteStore()", "target": "nl.tudelft.jpacman.sprite.SpriteStore", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()-returnType-java.lang.String", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "target": "java.lang.String", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-returnType-boolean", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction(int,int)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor()-returnType-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)-returnType-boolean", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)-returnType-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getLevel()-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.Game.getLevel()", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader()-returnType-nl.tudelft.jpacman.points.PointCalculatorLoader", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSpriteStore()-returnType-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaX()-returnType-int", "source": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getPlayers()-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.Game.getPlayers()", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()-returnType-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "target": "nl.tudelft.jpacman.level.Pellet", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.board.Board.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites()-returnType-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.sprite.PacManSprites()", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()-returnType-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelMap()-returnType-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.getLevelMap()", "target": "java.lang.String", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Clyde", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Clyde", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)-returnType-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "target": "nl.tudelft.jpacman.level.MapParser", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.isAlive()-returnType-boolean", "source": "nl.tudelft.jpacman.level.Player.isAlive()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher()-returnType-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman.Launcher()", "target": "nl.tudelft.jpacman.Launcher", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()-returnType-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.Launcher.getGameFactory()", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator()-returnType-nl.tudelft.jpacman.points.DefaultPointCalculator", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()-returnType-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.invariant()-returnType-boolean", "source": "nl.tudelft.jpacman.board.Board.invariant()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Player.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit()-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Unit()", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)-returnType-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-returnType-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-returnType-nl.tudelft.jpacman.ui.ButtonPanel", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.ButtonPanel", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-returnType-int", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getOccupants()-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.getOccupants()", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation()-returnType-nl.tudelft.jpacman.npc.ghost.Navigation", "source": "nl.tudelft.jpacman.npc.ghost.Navigation()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Blinky", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Blinky", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Pinky", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Pinky", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-returnType-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.level.Pellet", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)-returnType-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.isInProgress()-returnType-boolean", "source": "nl.tudelft.jpacman.game.Game.isInProgress()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()-returnType-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])-returnType-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-returnType-boolean", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isInProgress()-returnType-boolean", "source": "nl.tudelft.jpacman.level.Level.isInProgress()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.getBoard()-returnType-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.Level.getBoard()", "target": "nl.tudelft.jpacman.board.Board", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.Unit.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getInterval()-returnType-long", "source": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "target": "long", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.board.Board.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.hasSquare()-returnType-boolean", "source": "nl.tudelft.jpacman.board.Unit.hasSquare()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasScript-nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory.createGround()", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasScript-nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasScript-nl.tudelft.jpacman.npc.ghost.GhostColor()", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator-hasScript-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.points.PointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasScript-nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.getSprite()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getGhostFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.getScore()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.getScore()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator-hasScript-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.points.PointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasScript-nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasScript-nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasScript-nl.tudelft.jpacman.level.Pellet.getValue()", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.getValue()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.levelWon()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.levelWon()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getMapParser()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getMapParser()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasScript-nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasScript-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator-hasScript-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.points.PointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.makeLevel()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.makeLevel()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver-hasScript-nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "source": "nl.tudelft.jpacman.level.Level$LevelObserver", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.levelLost()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.levelLost()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator()", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder()", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasScript-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.start()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.start()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.getSprite()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getLevelMap()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getLevelMap()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction.opposite()", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.opposite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite()", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.stopNPCs()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.stopNPCs()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasScript-nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasScript-nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel-hasScript-nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "source": "nl.tudelft.jpacman.ui.ButtonPanel", "target": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasScript-nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasScript-nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory.createWall()", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasScript-nl.tudelft.jpacman.ui.PacManUI.start()", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.start()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasScript-nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.getSprite()", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap-hasScript-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionMap", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory.createPellet()", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.stop()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.stop()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.addPoints(int)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.addPoints(int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasScript-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.start()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.start()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasScript-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasScript-nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasScript-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter-hasScript-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square()", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.getSprite()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getGame()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getGame()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasScript-nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getBoardFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.nextMove()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction.getDeltaY()", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasScript-nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasScript-nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasScript-nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-hasScript-nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getLevelFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap()", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasScript-nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasScript-nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.invariant()", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.invariant()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.launch()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.launch()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-hasScript-nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasScript-nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.setAlive(boolean)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasScript-nl.tudelft.jpacman.ui.ScorePanel.refresh()", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.randomMove()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.makeGame()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.makeGame()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.updateObservers()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.updateObservers()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasScript-nl.tudelft.jpacman.level.Pellet.getSprite()", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasScript-nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.stop()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.stop()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.Action-hasScript-nl.tudelft.jpacman.ui.Action.doAction()", "source": "nl.tudelft.jpacman.ui.Action", "target": "nl.tudelft.jpacman.ui.Action.doAction()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException-hasScript-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "source": "nl.tudelft.jpacman.PacmanConfigurationException", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getGameFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getGameFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.loadPointCalculator()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasScript-nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.getPlayers()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.getPlayers()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasScript-nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory.createGhost()", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.getKiller()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.getKiller()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasScript-nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getPlayerFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction.getDeltaX()", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.remainingPellets()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.remainingPellets()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore()", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasScript-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasScript-nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.getInterval()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasScript-nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.dispose()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.dispose()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasScript-nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.leaveSquare()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException-hasScript-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "source": "nl.tudelft.jpacman.PacmanConfigurationException", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasScript-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.startNPCs()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startNPCs()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction(int,int)", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasScript-nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver-hasScript-nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "source": "nl.tudelft.jpacman.level.Level$LevelObserver", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-hasParameter-nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)-hasParameter-nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "source": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "target": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)-hasParameter-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-hasParameter-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "target": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)-hasParameter-nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "source": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "target": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)-hasParameter-nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)-hasParameter-nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "source": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "target": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-hasParameter-nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])-hasParameter-nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)-hasParameter-nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "source": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "target": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)-hasParameter-nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)-hasParameter-nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)-hasParameter-nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "source": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "target": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)-hasParameter-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-hasParameter-nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-hasParameter-nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)-hasParameter-nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "target": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])-hasParameter-nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "target": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-hasParameter-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)-hasParameter-nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "target": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)-hasParameter-nl.tudelft.jpacman.board.Direction(int,int).0", "source": "nl.tudelft.jpacman.board.Direction(int,int)", "target": "nl.tudelft.jpacman.board.Direction(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-hasParameter-nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)-hasParameter-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)-hasParameter-nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "source": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "target": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)-hasParameter-nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "source": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "target": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int)-hasParameter-nl.tudelft.jpacman.level.Player.addPoints(int).0", "source": "nl.tudelft.jpacman.level.Player.addPoints(int)", "target": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "source": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-hasParameter-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)-hasParameter-nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "target": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "source": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)-hasParameter-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)-hasParameter-nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "source": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)-hasParameter-nl.tudelft.jpacman.board.Direction(int,int).1", "source": "nl.tudelft.jpacman.board.Direction(int,int)", "target": "nl.tudelft.jpacman.board.Direction(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-hasParameter-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaX-type-int", "source": "nl.tudelft.jpacman.board.Direction.deltaX", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.level.Level", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.players-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.Level.players", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.board-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Board.board", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate-type-long", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.EAST-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.EAST", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.levelMap-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.levelMap", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PINKY-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2-type-boolean", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.sprites-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Player.sprites", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.image-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Pellet.image", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.value-type-int", "source": "nl.tudelft.jpacman.level.Pellet.value", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.SPRITE_STORE-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1-type-int", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0-type-java.lang.String", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0-type-int", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).1-type-int", "source": "nl.tudelft.jpacman.board.Direction(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.boardPanel-type-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1-type-int", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.direction-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Unit.direction", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int).0-type-int", "source": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0-type-int", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1-type-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "target": "nl.tudelft.jpacman.level.Level", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.occupants-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.occupants", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.level-type-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "target": "nl.tudelft.jpacman.level.Level", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.mappings-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0-type-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0-type-char", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "target": "char", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2-type-int", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0-type-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1-type-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaY-type-int", "source": "nl.tudelft.jpacman.board.Direction.deltaY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0-type-int", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.board.BoardFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.Game.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.inProgress-type-boolean", "source": "nl.tudelft.jpacman.game.Game.inProgress", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.sprites-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.Ghost.sprites", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2-type-int", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2-type-int", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.WEST-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.WEST", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.game-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.BoardPanel.game", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3-type-boolean", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.background-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).0-type-int", "source": "nl.tudelft.jpacman.board.Direction(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.moveInterval-type-int", "source": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0-type-boolean", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.boardCreator-type-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.level.MapParser.boardCreator", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.LevelFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.intervalVariation-type-int", "source": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.board-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.Level.board", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.pacManUI-type-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.Launcher.pacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1-type-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4-type-int", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0-type-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons-type-boolean", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.INKY-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.INKY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0-type-java.lang.String", "source": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0-type-java.lang.String", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.scorePanel-type-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.npcs-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level.npcs", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.NORTH-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.NORTH", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.inProgress-type-boolean", "source": "nl.tudelft.jpacman.level.Level.inProgress", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostFact-type-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.deathSprite-type-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.level.Player.deathSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.collisions-type-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.Level.collisions", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5-type-char", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "target": "char", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.alive-type-boolean", "source": "nl.tudelft.jpacman.level.Player.alive", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.sprites-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.Player.sprites", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0-type-int", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.playerFactory-type-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3-type-int", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.killer-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player.killer", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.sprites-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.sprites", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions-type-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0-type-char", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "target": "char", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL-type-int", "source": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.SOUTH-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.SOUTH", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.square-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.square", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.levelCreator-type-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level.MapParser.levelCreator", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.current-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1-type-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquares-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.Level.startSquares", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.CLYDE-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.neighbours-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.neighbours", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.neighbours-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Square.neighbours", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1-type-int", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0-type-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY-type-long", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1-type-int", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.player-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0-type-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.background-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3-type-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.observers-type-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level.observers", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1-type-int", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.BLINKY-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.score-type-int", "source": "nl.tudelft.jpacman.level.Player.score", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquareIndex-type-int", "source": "nl.tudelft.jpacman.level.Level.startSquareIndex", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.game-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.game", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-invokes-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.Unit()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-invokes-nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-invokes-nl.tudelft.jpacman.Launcher.getGhostFactory()", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level.remainingPellets()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level.remainingPellets()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.leaveSquare()-invokes-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.level.Player.setAlive(boolean)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-invokes-nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Direction.getDeltaY()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-invokes-nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-invokes-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stop()-invokes-nl.tudelft.jpacman.level.Level.stopNPCs()", "source": "nl.tudelft.jpacman.level.Level.stop()", "target": "nl.tudelft.jpacman.level.Level.stopNPCs()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Board.invariant()", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()-invokes-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.level.Player.getSprite()", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.level.LevelFactory.createGhost()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-invokes-nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.board.BoardFactory.createWall()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.Level.updateObservers()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.updateObservers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.Launcher.getGame()", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.Launcher.getGame()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()-invokes-nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-invokes-nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-invokes-nl.tudelft.jpacman.Launcher.getMapParser()", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.Launcher.getMapParser()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.board.Direction.opposite()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction.opposite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()-invokes-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()-invokes-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game.stop()", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()-invokes-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.level.Player.getSprite()", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelWon()-invokes-nl.tudelft.jpacman.game.Game.stop()", "source": "nl.tudelft.jpacman.game.Game.levelWon()", "target": "nl.tudelft.jpacman.game.Game.stop()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)-invokes-nl.tudelft.jpacman.board.Square()", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.Square()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.board.BoardFactory.createGround()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "label": "invokes", "properties": {"weight": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.board.Unit.getSprite()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.board.Unit.getSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-invokes-nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-invokes-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()-invokes-nl.tudelft.jpacman.npc.Ghost.getInterval()", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "target": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()-invokes-nl.tudelft.jpacman.sprite.Sprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "target": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)-invokes-nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()-invokes-nl.tudelft.jpacman.level.Level.stop()", "source": "nl.tudelft.jpacman.game.Game.stop()", "target": "nl.tudelft.jpacman.level.Level.stop()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.Launcher.getGameFactory()", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.Launcher.getGameFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-invokes-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.level.Player.setAlive(boolean)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-invokes-nl.tudelft.jpacman.sprite.Sprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)-invokes-nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "target": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stop()-invokes-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level.stop()", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])-invokes-nl.tudelft.jpacman.Launcher.launch()", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "target": "nl.tudelft.jpacman.Launcher.launch()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "source": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.ui.PacManUI.start()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUI.start()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-invokes-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.Launcher.loadPointCalculator()", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-invokes-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.start()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.start()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-invokes-nl.tudelft.jpacman.Launcher.getLevelMap()", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.Launcher.getLevelMap()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.level.Pellet.getValue()", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.Pellet.getValue()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.level.LevelFactory.createPellet()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-invokes-nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-invokes-nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.Launcher.getGame()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.Launcher.getGame()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.board.Unit.leaveSquare()", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSquare()-invokes-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit.getSquare()", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-invokes-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Direction.getDeltaX()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()-invokes-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level.start()", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.refresh()-invokes-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startNPCs()-invokes-nl.tudelft.jpacman.npc.Ghost.getInterval()", "source": "nl.tudelft.jpacman.level.Level.startNPCs()", "target": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-invokes-nl.tudelft.jpacman.Launcher.getLevelFactory()", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.level.Player.addPoints(int)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.Player.addPoints(int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelLost()-invokes-nl.tudelft.jpacman.game.Game.stop()", "source": "nl.tudelft.jpacman.game.Game.levelLost()", "target": "nl.tudelft.jpacman.game.Game.stop()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-invokes-nl.tudelft.jpacman.game.Game.getPlayers()", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.game.Game.getPlayers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.invariant()-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.board.Unit.invariant()", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-invokes-nl.tudelft.jpacman.ui.Action.doAction()", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.Action.doAction()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getSprite()-invokes-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game.stop()", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()-invokes-nl.tudelft.jpacman.level.Level.startNPCs()", "source": "nl.tudelft.jpacman.level.Level.start()", "target": "nl.tudelft.jpacman.level.Level.startNPCs()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.refresh()-invokes-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()-invokes-nl.tudelft.jpacman.ui.ScorePanel.refresh()", "source": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "target": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-invokes-nl.tudelft.jpacman.Launcher.getBoardFactory()", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.game.Game.getPlayers()", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.game.Game.getPlayers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()-invokes-nl.tudelft.jpacman.sprite.Sprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "target": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()-invokes-nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "source": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.board.BoardFactory.createGround()", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()-invokes-nl.tudelft.jpacman.npc.Ghost.nextMove()", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "target": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-invokes-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.remainingPellets()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.remainingPellets()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.Launcher.makeGame()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.Launcher.makeGame()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()-invokes-nl.tudelft.jpacman.level.Level.updateObservers()", "source": "nl.tudelft.jpacman.level.Level.start()", "target": "nl.tudelft.jpacman.level.Level.updateObservers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextMove()-invokes-nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "source": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "target": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.board.Unit.leaveSquare()", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-invokes-nl.tudelft.jpacman.sprite.Sprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-invokes-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.board.Unit()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)-invokes-nl.tudelft.jpacman.ui.Action.doAction()", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.Action.doAction()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-invokes-nl.tudelft.jpacman.Launcher.loadPointCalculator()", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-invokes-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-invokes-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()-invokes-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()-invokes-nl.tudelft.jpacman.Launcher.getPlayerFactory()", "source": "nl.tudelft.jpacman.Launcher.getGameFactory()", "target": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites()-invokes-nl.tudelft.jpacman.sprite.SpriteStore()", "source": "nl.tudelft.jpacman.sprite.PacManSprites()", "target": "nl.tudelft.jpacman.sprite.SpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)-invokes-nl.tudelft.jpacman.board.Square()", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.Square()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.leaveSquare()-invokes-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-invokes-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-invokes-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.board.Unit()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.board.Square.getSprite()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.board.Square.getSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.Launcher.makeLevel()", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.Launcher.makeLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()-invokes-nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-invokes-nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft-contains-nl.tudelft.jpacman", "source": "nl.tudelft", "target": "nl.tudelft.jpacman", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-contains-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Pinky", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Pinky", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Inky", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Inky", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.PacKeyListener", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.PacKeyListener", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Square", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc-contains-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-contains-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points-contains-nl.tudelft.jpacman.points.PointCalculatorLoader", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game-contains-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.sprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Pellet", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.game", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.game", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game-contains-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.game.Game", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Board", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.Launcher", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.board", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Clyde", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Clyde", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Blinky", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Blinky", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Player", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl-contains-nl.tudelft", "source": "nl", "target": "nl.tudelft", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.points", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-contains-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points-contains-nl.tudelft.jpacman.points.DefaultPointCalculator", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-contains-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.level", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-contains-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.PlayerCollisions", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.PlayerCollisions", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.npc", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.npc", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-contains-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Unit", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.ui", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.ui", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc-contains-nl.tudelft.jpacman.npc.ghost", "source": "nl.tudelft.jpacman.npc", "target": "nl.tudelft.jpacman.npc.ghost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.ButtonPanel", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.ButtonPanel", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points-contains-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.SpriteStore", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.SpriteStore", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.MapParser", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Navigation", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Navigation", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Direction", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game-contains-nl.tudelft.jpacman.game.SinglePlayerGame", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.game.SinglePlayerGame", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.Action", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Level", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-contains-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.current", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasVariable-nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.startSquareIndex", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startSquareIndex", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.boardPanel", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.EAST", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.EAST", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.moveLock", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.moveLock", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasVariable-nl.tudelft.jpacman.board.Board.board", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.board", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasVariable-nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasVariable-nl.tudelft.jpacman.game.GameFactory.playerFactory", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.npcs", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.npcs", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.alive", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.alive", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasVariable-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasVariable-nl.tudelft.jpacman.board.BoardFactory.sprites", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.SOUTH", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.SOUTH", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasVariable-nl.tudelft.jpacman.game.Game.progressLock", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.progressLock", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasVariable-nl.tudelft.jpacman.board.Square.neighbours", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.neighbours", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasVariable-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.levelMap", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.levelMap", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasVariable-nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasVariable-nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.game", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.game", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasVariable-nl.tudelft.jpacman.board.Unit.direction", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.direction", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel-hasVariable-nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "source": "nl.tudelft.jpacman.ui.ButtonPanel", "target": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.game", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.game", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasVariable-nl.tudelft.jpacman.level.MapParser.boardCreator", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.boardCreator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.PINKY", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasVariable-nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasVariable-nl.tudelft.jpacman.level.Pellet.image", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.image", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.players", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.players", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasVariable-nl.tudelft.jpacman.npc.Ghost.sprites", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasVariable-nl.tudelft.jpacman.board.BoardFactory$Wall.background", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.ghostFact", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasVariable-nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasVariable-nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasVariable-nl.tudelft.jpacman.game.Game.inProgress", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.inProgress", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-hasVariable-nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasVariable-nl.tudelft.jpacman.game.SinglePlayerGame.player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasVariable-nl.tudelft.jpacman.game.SinglePlayerGame.level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.inProgress", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.inProgress", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.score", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.score", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.deltaY", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.deltaY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasVariable-nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasVariable-nl.tudelft.jpacman.level.PlayerFactory.sprites", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasVariable-nl.tudelft.jpacman.npc.Ghost.intervalVariation", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasVariable-nl.tudelft.jpacman.board.Square.occupants", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.occupants", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.pacManUI", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.pacManUI", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasVariable-nl.tudelft.jpacman.sprite.ImageSprite.image", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.image", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasVariable-nl.tudelft.jpacman.board.BoardFactory$Ground.background", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-hasVariable-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasVariable-nl.tudelft.jpacman.game.Game.pointCalculator", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.scorePanel", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasVariable-nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasVariable-nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.startStopLock", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startStopLock", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasVariable-nl.tudelft.jpacman.npc.Ghost.moveInterval", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.board", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.board", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasVariable-nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.BLINKY", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasVariable-nl.tudelft.jpacman.ui.PacKeyListener.mappings", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasVariable-nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.SPRITE_STORE", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.deltaX", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.deltaX", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.NORTH", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.NORTH", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasVariable-nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasVariable-nl.tudelft.jpacman.board.Unit.square", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.square", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.startSquares", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startSquares", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasVariable-nl.tudelft.jpacman.level.Pellet.value", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.value", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.collisions", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.collisions", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.INKY", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.INKY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.sprites", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.observers", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.observers", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasVariable-nl.tudelft.jpacman.level.MapParser.levelCreator", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.levelCreator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.sprites", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.killer", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.killer", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasVariable-nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasVariable-nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.CLYDE", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.WEST", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.WEST", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.deathSprite", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.deathSprite", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-specializes-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.board.Unit", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-specializes-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.Game", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-specializes-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.Square", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-specializes-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-specializes-nl.tudelft.jpacman.sprite.SpriteStore", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.SpriteStore", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-specializes-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.board.Unit", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-specializes-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-specializes-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.Square", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-specializes-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-specializes-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-specializes-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-specializes-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-specializes-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-specializes-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-specializes-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.board.Unit", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-specializes-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-instantiates-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.Level", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()-instantiates-nl.tudelft.jpacman.npc.ghost.Pinky", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "target": "nl.tudelft.jpacman.npc.ghost.Pinky", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-instantiates-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-instantiates-nl.tudelft.jpacman.game.SinglePlayerGame", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-instantiates-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()-instantiates-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-instantiates-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startNPCs()-instantiates-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level.Level.startNPCs()", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-instantiates-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.level.Player", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-instantiates-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-instantiates-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)-instantiates-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-instantiates-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()-instantiates-nl.tudelft.jpacman.npc.ghost.Blinky", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "target": "nl.tudelft.jpacman.npc.ghost.Blinky", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()-instantiates-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-instantiates-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.level.MapParser", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()-instantiates-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.ButtonPanel", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ButtonPanel", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()-instantiates-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "target": "nl.tudelft.jpacman.level.Pellet", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-instantiates-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-instantiates-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()-instantiates-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.Launcher.getGameFactory()", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-instantiates-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()-instantiates-nl.tudelft.jpacman.npc.ghost.Inky", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "target": "nl.tudelft.jpacman.npc.ghost.Inky", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])-instantiates-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "target": "nl.tudelft.jpacman.Launcher", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()-instantiates-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()-instantiates-nl.tudelft.jpacman.npc.ghost.Clyde", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "target": "nl.tudelft.jpacman.npc.ghost.Clyde", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-instantiates-nl.tudelft.jpacman.level.PlayerCollisions", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.PlayerCollisions", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-instantiates-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()-instantiates-nl.tudelft.jpacman.points.PointCalculatorLoader", "source": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()-instantiates-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.PacKeyListener", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacKeyListener", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-instantiates-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-instantiates-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-instantiates-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "layer:UI-allowedDependency-layer:Logic", "source": "layer:UI", "target": "layer:Logic", "label": "allowedDependency", "properties": {"weight": 1}}}, {"data": {"id": "layer:Logic-allowedDependency-layer:Data", "source": "layer:Logic", "target": "layer:Data", "label": "allowedDependency", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaY()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)-implements-layer:Data", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "target": "layer:Data", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.getBoard()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.getBoard()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getHeight()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Board.getHeight()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-implements-layer:Logic", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stopNPCs()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.stopNPCs()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-implements-layer:Logic", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getLevel()-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.getLevel()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.invariant()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Board.invariant()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getDirection()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.getDirection()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getOccupants()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.getOccupants()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-implements-layer:Logic", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-implements-layer:UI", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGame()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getGame()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.opposite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Direction.opposite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.isAlive()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Player.isAlive()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.hasSquare()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.hasSquare()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.isInProgress()-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.isInProgress()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.getSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getInterval()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getWidth()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getWidth()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Board.getWidth()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isInProgress()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.isInProgress()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.start()-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUI.start()", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelMap()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getLevelMap()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getValue()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Pellet.getValue()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaX()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSpriteStore()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Player.addPoints(int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getPlayers()-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.getPlayers()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.Action.doAction()-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.Action.doAction()", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getHeight()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.SpriteStore()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.getSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()-implements-layer:Logic", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.invariant()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.invariant()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Player.getSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startNPCs()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.startNPCs()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stop()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.stop()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-implements-layer:Logic", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.refresh()-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextMove()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-implements-layer:UI", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()-implements-layer:Logic", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.leaveSquare()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSquare()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.getSquare()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.stop()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getGameFactory()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()-implements-layer:Logic", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelWon()-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.levelWon()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelLost()-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.levelLost()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()-implements-layer:Logic", "source": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-implements-layer:UI", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level.start()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-implements-layer:Logic", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)-implements-layer:UI", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-implements-layer:Logic", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])-implements-layer:Logic", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-implements-layer:Logic", "source": "nl.tudelft.jpacman.sprite", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.game-implements-layer:Logic", "source": "nl.tudelft.jpacman.game", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board-implements-layer:Logic", "source": "nl.tudelft.jpacman.board", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.points-implements-layer:Logic", "source": "nl.tudelft.jpacman.points", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.level-implements-layer:Logic", "source": "nl.tudelft.jpacman.level", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.ui-implements-layer:UI", "source": "nl.tudelft.jpacman.ui", "target": "layer:UI", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc.ghost", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.npc-implements-layer:Logic", "source": "nl.tudelft.jpacman.npc", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman-implements-layer:Logic", "source": "nl.tudelft.jpacman", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft-implements-layer:Logic", "source": "nl.tudelft", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl-implements-layer:Logic", "source": "nl", "target": "layer:Logic", "label": "implements", "properties": {"weight": 1}}}, {"data": {"id": "nl.tudelft.jpacman.board-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.board package and the nl.tudelft.jpacman.sprite package are designed to work together to create and manage game boards and their elements, respectively. The board package provides classes for managing the game grid and its components, while the sprite package manages the visual representation of these elements, including loading and rendering images."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package and the nl.tudelft.jpacman.sprite package are designed to work together to manage game entities and their visual representations in a Pac-Man game. The level package provides classes for managing game levels, player interactions, collision detection, and entity management, while the sprite package manages game sprites, including handling animations, rendering images, and providing access to various game elements. These two packages are interdependent as they work together to create and render the visual aspects of a Pac-Man game, ensuring that all entities in the game have appropriate visual representations and interactions."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package and the nl.tudelft.jpacman.sprite package are designed to work together seamlessly in a Pac-Man game implementation. The ui package provides user interface components for rendering the game board, score, and buttons, while the sprite package manages game sprites such as characters, walls, and other elements. The dependency between these packages is crucial for rendering the game's visual representation accurately, ensuring that each square on the board is correctly rendered with its occupants and that the user interface updates in real-time to reflect changes in the game state."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc.ghost package and the nl.tudelft.jpacman.sprite package are designed to work together in a Pac-Man game implementation. The ghost classes rely on sprite management provided by the sprite package to render their visual representations, while the sprite package provides methods for creating animated sprites that are used by the ghost classes to animate their movements and behaviors."}}}, {"data": {"id": "nl.tudelft.jpacman.game-dependsOn-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.points", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.game package manages game state and logic, including player movement and level progression, while the nl.tudelft.jpacman.points package handles game points, calculating and updating scores based on player actions such as consuming pellets and colliding with ghosts. The Game class in the game package invokes methods from the PointCalculator interface to update player scores based on their movements, demonstrating a dependency between these two packages for managing game state and scoring."}}}, {"data": {"id": "nl.tudelft.jpacman.game-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.game package manages the game's state and logic, including player movement and level progression, while the nl.tudelft.jpacman.level package contains classes and interfaces that manage game levels, player interactions, collision detection, and entity management in a Pac-Man game. The two packages are interdependent as they work together to create and manage the game's various components, such as players, levels, and entities, ensuring that the game runs smoothly and provides an engaging experience for players."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.game", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.game", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package provides user interface components for the Pac-Man game, while the nl.tudelft.jpacman.game package manages the game's state and logic. The ui package depends on the game package to access game-related information such as levels, players, and scores, enabling the UI to display and update these elements in real-time."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.game", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.game", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package manages game logic and provides utilities for parsing level maps, creating players, handling user input, and moving players towards specified directions. The nl.tudelft.jpacman.game package manages the game's state and logic, including player movement and level progression. These two packages are interdependent as they work together to create a functional Pacman implementation in Java."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package provides the game logic and management for Pac-Man, while the nl.tudelft.jpacman.board package manages the physical layout and interactions within the game board. They are designed as separate packages to allow for easy modification and expansion of either component without affecting the other."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package and the nl.tudelft.jpacman.board package are tightly coupled, with the ui package depending on the board package for rendering game elements such as the board itself, squares, and units. The board package provides the necessary data structures and methods to represent and manipulate the game state, while the ui package uses this data to render the game visually in a user-friendly interface."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc.ghost package and the nl.tudelft.jpacman.board package are designed to work together to create a game environment where ghosts navigate and interact with the board, which includes obstacles, walls, and other entities that affect their movement and behavior in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.npc-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.npc", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc package and the nl.tudelft.jpacman.board package are designed to work together to manage navigation, pathfinding, and AI behavior for ghosts in a Pac-Man game. The board provides the necessary structure and functionality for the ghosts to move around the game board, while the NPCs handle their specific behaviors and movement patterns."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.points", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package and the nl.tudelft.jpacman.points package are designed to work together to manage game points and interactions between different entities in a Pac-Man game. The level package handles the state of the game, including player health, pellets remaining, and notifying observers about significant events like losing or winning. The points package manages point calculations based on player actions such as consuming pellets and colliding with ghosts, updating player scores accordingly."}}}, {"data": {"id": "nl.tudelft.jpacman.points-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.points package and the nl.tudelft.jpacman.level package are designed to work together in a Pac-Man game. The points package manages game points, including calculating scores based on player actions such as consuming pellets and colliding with ghosts. The level package handles game levels, player interactions, collision detection, and entity management. The points package interacts with the level package by providing methods that update player scores based on these interactions, ensuring a seamless integration between point calculation and game state management in the Pac-Man game."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.points", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package manages game logic and interacts with the nl.tudelft.jpacman.points package for managing game points, including calculating scores based on player actions such as consuming pellets and colliding with ghosts. The Launcher class in the jpacman package uses a PointCalculatorLoader to dynamically load or use a point calculator, which is essential for accurately tracking and updating player scores throughout the game."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package provides user interface components for the Pac-Man game, while the nl.tudelft.jpacman.level package manages the game's level state and interactions. The ui package depends on the level package to access game data such as the board and players, and to update the UI based on these changes."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.npc.ghost", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.npc.ghost", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package and the nl.tudelft.jpacman.npc.ghost package are designed to work together to manage game entities, specifically ghosts, within a Pac-Man game. The level package provides classes for managing game levels, player interactions, collision detection, and entity management, while the ghost package contains classes for implementing AI logic and movement for various ghost characters in the game. The level package relies on the ghost package to create and manage ghost entities, using methods from the ghost package to initialize and control their behavior within the game environment."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.npc", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.npc", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package manages game levels and player interactions, while the nl.tudelft.jpacman.npc package handles navigation, pathfinding, and AI behavior for ghosts in a Pac-Man game. The level package uses NPC classes to manage ghost movement and interactions with other entities, ensuring that the game's mechanics are consistent and responsive."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package manages game logic and user interactions, while the nl.tudelft.jpacman.level package handles game levels, player interactions, collision detection, and entity management. The Launcher class in the jpacman package uses the MapParser to parse level maps into Level objects, which are then used by other components of the game to manage game state and behavior."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.ui", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.ui", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package manages game logic, while the nl.tudelft.jpacman.ui package handles user interface components for a Pac-Man game. The nl.tudelft.jpacman package provides classes and interfaces that interact with the nl.tudelft.jpacman.ui package to create and manage the game board, score, and buttons, as well as handle user input and update the game state accordingly."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-dependsOn-nl.tudelft.jpacman.npc", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc.ghost package provides specific implementations for various ghost characters in the Pac-Man game, while the nl.tudelft.jpacman.npc package manages navigation, pathfinding, and AI behavior for all ghosts. The two packages are interconnected through a common superclass `Ghost` which is used to initialize and manage the behavior of all ghost characters."}}}]}}